<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>Nim手册</title>
<style type="text/css" >
/*
Stylesheet for use with Docutils/rst2html.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.

Modified from Chad Skeeters' rst2html-style
https://bitbucket.org/cskeeters/rst2html-style/

Modified by Boyd Greenfield and narimiran
*/

html {
  font-size: 100%;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%; }

body {
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif;
  font-weight: 400;
  font-size: 1.125em;
  line-height: 1.5;
  color: #222;
  background-color: #FCFCFC; }

/* Skeleton grid */
.container {
  position: relative;
  width: 100%;
  max-width: 1050px;
  margin: 0 auto;
  padding: 0;
  box-sizing: border-box; }

.column,
.columns {
  width: 100%;
  float: left;
  box-sizing: border-box;
  margin-left: 1%;
}

.column:first-child,
.columns:first-child {
  margin-left: 0; }

.three.columns {
  width: 19%; }

.nine.columns {
  width: 80.0%; }

.twelve.columns {
  width: 100%;
  margin-left: 0; }

@media screen and (max-width: 860px) {
  .three.columns {
    display: none;
  }
  .nine.columns {
    width: 98.0%;
  }
  body {
    font-size: 1em;
    line-height: 1.35;
  }
}

cite {
  font-style: italic !important; }


/* Nim search input */
div#searchInputDiv {
  margin-bottom: 1em;
}
input#searchInput {
  width: 80%;
}

/*
 * Some custom formatting for input forms.
 * This also fixes input form colors on Firefox with a dark system theme on Linux.
 */
input {
  -moz-appearance: none;
  color: #333;
  background-color: #f8f8f8;
  border: 1px solid #aaa;
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif;
  font-size: 0.9em;
  padding: 6px;
}
input:focus {
  border: 1px solid #1fa0eb;
  box-shadow: 0 0 2px #1fa0eb;
}

/* Docgen styles */
/* Links */
a {
  color: #07b;
  text-decoration: none;
}

a span.Identifier {
  text-decoration: underline;
  text-decoration-color: #aab;
}

a.reference-toplevel {
  font-weight: bold;
}

a.toc-backref {
  text-decoration: none;
  color: #222; }

a.link-seesrc {
  color: #607c9f;
  font-size: 0.9em;
  font-style: italic; }

a:hover,
a:focus {
  color: #607c9f;
  text-decoration: underline; }

a:hover span.Identifier {
  color: #607c9f;
}


sub,
sup {
  position: relative;
  font-size: 75%;
  line-height: 0;
  vertical-align: baseline; }

sup {
  top: -0.5em; }

sub {
  bottom: -0.25em; }

img {
  width: auto;
  height: auto;
  max-width: 100%;
  vertical-align: middle;
  border: 0;
  -ms-interpolation-mode: bicubic; }

@media print {
  * {
    color: black !important;
    text-shadow: none !important;
    background: transparent !important;
    box-shadow: none !important; }

  a,
  a:visited {
    text-decoration: underline; }

  a[href]:after {
    content: " (" attr(href) ")"; }

  abbr[title]:after {
    content: " (" attr(title) ")"; }

  .ir a:after,
  a[href^="javascript:"]:after,
  a[href^="#"]:after {
    content: ""; }

  pre,
  blockquote {
    border: 1px solid #999;
    page-break-inside: avoid; }

  thead {
    display: table-header-group; }

  tr,
  img {
    page-break-inside: avoid; }

  img {
    max-width: 100% !important; }

  @page {
    margin: 0.5cm; }

  h1 {
    page-break-before: always; }

  h1.title {
    page-break-before: avoid; }

  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3; }

  h2,
  h3 {
    page-break-after: avoid; }
}


p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

small {
  font-size: 85%; }

strong {
  font-weight: 600;
  font-size: 0.95em;
  color: #3c3c3c;
}

em {
  font-style: italic; }

h1 {
  font-size: 1.8em;
  font-weight: 400;
  padding-bottom: .25em;
  border-bottom: 1px solid #aaa;
  margin-top: 2.5em;
  margin-bottom: 1em;
  line-height: 1.2em; }

h1.title {
  padding-bottom: 1em;
  border-bottom: 0px;
  font-size: 2.5em;
  text-align: center;
  font-weight: 900;
  margin-top: 0.75em;
  margin-bottom: 0em;
}

h2 {
  font-size: 1.3em;
  margin-top: 2em; }

h2.subtitle {
  text-align: center; }

h3 {
  font-size: 1.125em;
  font-style: italic;
  margin-top: 1.5em; }

h4 {
  font-size: 1.125em;
  margin-top: 1em; }

h5 {
  font-size: 1.125em;
  margin-top: 0.75em; }

h6 {
  font-size: 1.1em; }


ul,
ol {
  padding: 0;
  margin-top: 0.5em;
  margin-left: 0.75em; }

ul ul,
ul ol,
ol ol,
ol ul {
  margin-bottom: 0;
  margin-left: 1.25em; }

li {
    list-style-type: circle;
}

ul.simple-boot li {
    list-style-type: none;
    margin-left: 0em;
    margin-bottom: 0.5em;
}

ol.simple > li, ul.simple > li {
  margin-bottom: 0.25em;
  margin-left: 0.4em }

ul.simple.simple-toc > li {
    margin-top: 1em;
}

ul.simple-toc {
  list-style: none;
  font-size: 0.9em;
  margin-left: -0.3em;
  margin-top: 1em; }

ul.simple-toc > li {
    list-style-type: none;
}

ul.simple-toc-section {
  list-style-type: circle;
  margin-left: 1em;
  color: #6c9aae; }


ol.arabic {
  list-style: decimal; }

ol.loweralpha {
  list-style: lower-alpha; }

ol.upperalpha {
  list-style: upper-alpha; }

ol.lowerroman {
  list-style: lower-roman; }

ol.upperroman {
  list-style: upper-roman; }

ul.auto-toc {
  list-style-type: none; }


dl {
  margin-bottom: 1.5em; }

dt {
  margin-bottom: -0.5em;
  margin-left: 0.0em; }

dd {
  margin-left: 2.0em;
  margin-bottom: 3.0em;
  margin-top: 0.5em; }


hr {
  margin: 2em 0;
  border: 0;
  border-top: 1px solid #aaa; }

blockquote {
  font-size: 0.9em;
  font-style: italic;
  padding-left: 0.5em;
  margin-left: 0;
  border-left: 5px solid #bbc;
}

.pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  font-weight: 500;
  font-size: 0.85em;
  background-color: #f0f3ff;
  padding-left: 3px;
  padding-right: 3px;
  border-radius: 4px;
}

pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  color: #222;
  font-weight: 500;
  display: inline-block;
  box-sizing: border-box;
  min-width: 100%;
  padding: 0.5em;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  font-size: 0.85em;
  white-space: pre !important;
  overflow-y: hidden;
  overflow-x: visible;
  background-color: ghostwhite;
  border: 1px solid #dde;
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.pre-scrollable {
  max-height: 340px;
  overflow-y: scroll; }


/* Nim line-numbered tables */
.line-nums-table {
  width: 100%;
  table-layout: fixed; }

table.line-nums-table {
  border-radius: 4px;
  border: 1px solid #cccccc;
  background-color: ghostwhite;
  border-collapse: separate;
  margin-top: 15px;
  margin-bottom: 25px; }

.line-nums-table tbody {
  border: none; }

.line-nums-table td pre {
  border: none;
  background-color: transparent; }

.line-nums-table td.blob-line-nums {
  width: 28px; }

.line-nums-table td.blob-line-nums pre {
  color: #b0b0b0;
  -webkit-filter: opacity(75%);
  text-align: right;
  border-color: transparent;
  background-color: transparent;
  padding-left: 0px;
  margin-left: 0px;
  padding-right: 0px;
  margin-right: 0px; }


table {
  max-width: 100%;
  background-color: transparent;
  margin-top: 0.5em;
  margin-bottom: 1.5em;
  border-collapse: collapse;
  border-color: #ccc;
  border-spacing: 0;
  font-size: 0.9em;
}

table th, table td {
  padding: 0px 0.5em 0px;
}

table th {
  background-color: #e8e8e8;
  font-weight: bold; }

table th.docinfo-name {
    background-color: transparent;
}

table tr:hover {
  background-color: ghostwhite; }


/* rst2html default used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0; }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 !important; }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 !important; }

.last, .with-subtitle {
  margin-bottom: 0 !important; }

.hidden {
  display: none; }

blockquote.epigraph {
  margin: 2em 5em; }

dl.docutils dd {
  margin-bottom: 0.5em; }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden; }


div.figure {
  margin-left: 2em;
  margin-right: 2em; }

div.footer, div.header {
  clear: both;
  text-align: center;
  color: #666;
  font-size: smaller; }

div.footer {
    padding-top: 5em;
}

div.line-block {
  display: block;
  margin-top: 1em;
  margin-bottom: 1em; }

div.line-block div.line-block {
  margin-top: 0;
  margin-bottom: 0;
  margin-left: 1.5em; }

div.topic {
  margin: 2em; }

div.search_results {
  background-color: antiquewhite;
  margin: 3em;
  padding: 1em;
  border: 1px solid #4d4d4d;
}

div#global-links ul {
  margin-left: 0;
  list-style-type: none;
}

div#global-links > simple-boot {
    margin-left: 3em;
}

hr.docutils {
  width: 75%; }

img.align-left, .figure.align-left, object.align-left {
  clear: left;
  float: left;
  margin-right: 1em; }

img.align-right, .figure.align-right, object.align-right {
  clear: right;
  float: right;
  margin-left: 1em; }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto; }

.align-left {
  text-align: left; }

.align-center {
  clear: both;
  text-align: center; }

.align-right {
  text-align: right; }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit; }

p.attribution {
  text-align: right;
  margin-left: 50%; }

p.caption {
  font-style: italic; }

p.credits {
  font-style: italic;
  font-size: smaller; }

p.label {
  white-space: nowrap; }

p.rubric {
  font-weight: bold;
  font-size: larger;
  color: maroon;
  text-align: center; }

p.topic-title {
  font-weight: bold; }

pre.address {
  margin-bottom: 0;
  margin-top: 0;
  font: inherit; }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em;
  margin-right: 2em; }

pre.code .ln {
  color: grey; }

/* line numbers */
pre.code, code {
  background-color: #eeeeee; }

pre.code .comment, code .comment {
  color: #5c6576; }

pre.code .keyword, code .keyword {
  color: #3B0D06;
  font-weight: bold; }

pre.code .literal.string, code .literal.string {
  color: #0c5404; }

pre.code .name.builtin, code .name.builtin {
  color: #352b84; }

pre.code .deleted, code .deleted {
  background-color: #DEB0A1; }

pre.code .inserted, code .inserted {
  background-color: #A3D289; }

span.classifier {
  font-style: oblique; }

span.classifier-delimiter {
  font-weight: bold; }

span.option {
  white-space: nowrap; }

span.problematic {
  color: #b30000; }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80%; }

span.DecNumber {
  color: #252dbe; }

span.BinNumber {
  color: #252dbe; }

span.HexNumber {
  color: #252dbe; }

span.OctNumber {
  color: #252dbe; }

span.FloatNumber {
  color: #252dbe; }

span.Identifier {
  color: #222; }

span.Keyword {
  font-weight: 600;
  color: #5e8f60; }

span.StringLit {
  color: #a4255b; }

span.LongStringLit {
  color: #a4255b; }

span.CharLit {
  color: #a4255b; }

span.EscapeSequence {
  color: black; }

span.Operator {
  color: black; }

span.Punctuation {
  color: black; }

span.Comment, span.LongComment {
  font-style: italic;
  font-weight: 400;
  color: #484a86; }

span.RegularExpression {
  color: darkviolet; }

span.TagStart {
  color: darkviolet; }

span.TagEnd {
  color: darkviolet; }

span.Key {
  color: #252dbe; }

span.Value {
  color: #252dbe; }

span.RawData {
  color: #a4255b; }

span.Assembler {
  color: #252dbe; }

span.Preprocessor {
  color: #252dbe; }

span.Directive {
  color: #252dbe; }

span.Command, span.Rule, span.Hyperlink, span.Label, span.Reference,
span.Other {
  color: black; }

/* Pop type, const, proc, and iterator defs in nim def blocks */
dt pre > span.Identifier, dt pre > span.Operator {
  color: #155da4;
  font-weight: 700; }

dt pre > span.Keyword ~ span.Identifier, dt pre > span.Identifier ~ span.Identifier,
dt pre > span.Operator ~ span.Identifier, dt pre > span.Other ~ span.Identifier {
  color: inherit;
  font-weight: inherit; }

/* Nim sprite for the footer (taken from main page favicon) */
.nim-sprite {
  display: inline-block;
  height: 16px;
  width: 16px;
  background-position: 0 0;
  background-size: 16px 16px;
  -webkit-filter: opacity(50%);
  background-repeat: no-repeat;
  background-image: url("data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA==");
  margin-bottom: -5px; }

span.pragmadots {
  /* Position: relative frees us up to make the dots
  look really nice without fucking up the layout and
  causing bulging in the parent container */
  position: relative;
  /* 1px down looks slightly nicer */
  top: 1px;
  padding: 2px;
  background-color: #e8e8e8;
  border-radius: 4px;
  margin: 0 2px;
  cursor: pointer;
  font-size: 0.8em;
}

span.pragmadots:hover {
  background-color: #DBDBDB;
}
span.pragmawrap {
  display: none;
}

span.attachedType {
  display: none;
  visibility: hidden;
}
</style>

<script type="text/javascript" src="dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }
}
</script>

</head>
<body onload="main()">
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Nim手册</h1>
    <div class="row">
  <div class="three columns">
  <div id="global-links">
    <ul class="simple-boot">
      <li>
        <a href="manual.html">Manual</a>
      </li>
      <li>
        <a href="lib.html">Standard library</a>
      </li>
      <li>
        <a href="theindex.html">Index</a>
      </li>
    </ul>
  </div>
  <div id="searchInputDiv">
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
  <ul class="simple simple-toc" id="toc-list">
<li><a class="reference" id="关于本文_toc" href="#关于本文">关于本文</a></li>
<li><a class="reference" id="定义_toc" href="#定义">定义</a></li>
<li><a class="reference" id="词法分析_toc" href="#词法分析">词法分析</a></li>
<ul class="simple"><li><a class="reference" id="词法分析-编码_toc" href="#词法分析-编码">编码</a></li>
<li><a class="reference" id="词法分析-缩进_toc" href="#词法分析-缩进">缩进</a></li>
<li><a class="reference" id="词法分析-注释_toc" href="#词法分析-注释">注释</a></li>
<li><a class="reference" id="词法分析-多行注释_toc" href="#词法分析-多行注释">多行注释</a></li>
<li><a class="reference" id="词法分析-标识符-amp-关键字_toc" href="#词法分析-标识符-amp-关键字">标识符 &amp; 关键字</a></li>
<li><a class="reference" id="词法分析-标识符相等性_toc" href="#词法分析-标识符相等性">标识符相等性</a></li>
<li><a class="reference" id="词法分析-字符串字面值_toc" href="#词法分析-字符串字面值">字符串字面值</a></li>
<li><a class="reference" id="词法分析-三引用字符串字面值_toc" href="#词法分析-三引用字符串字面值">三引用字符串字面值</a></li>
<li><a class="reference" id="词法分析-原始字符串字面值_toc" href="#词法分析-原始字符串字面值">原始字符串字面值</a></li>
<li><a class="reference" id="词法分析-广义原始字符串字面值_toc" href="#词法分析-广义原始字符串字面值">广义原始字符串字面值</a></li>
<li><a class="reference" id="词法分析-字符字面值_toc" href="#词法分析-字符字面值">字符字面值</a></li>
<li><a class="reference" id="词法分析-数值常量_toc" href="#词法分析-数值常量">数值常量</a></li>
<li><a class="reference" id="词法分析-操作符_toc" href="#词法分析-操作符">操作符</a></li>
<li><a class="reference" id="词法分析-其它标记_toc" href="#词法分析-其它标记">其它标记</a></li>
</ul><li><a class="reference" id="句法_toc" href="#句法">句法</a></li>
<ul class="simple"><li><a class="reference" id="句法-结合律_toc" href="#句法-结合律">结合律</a></li>
<li><a class="reference" id="句法-语法_toc" href="#句法-语法">语法</a></li>
</ul><li><a class="reference" id="求值顺序_toc" href="#求值顺序">求值顺序</a></li>
<li><a class="reference" id="常量和常量表达式_toc" href="#常量和常量表达式">常量和常量表达式</a></li>
<li><a class="reference" id="编译期执行限制_toc" href="#编译期执行限制">编译期执行限制</a></li>
<li><a class="reference" id="类型_toc" href="#类型">类型</a></li>
<ul class="simple"><li><a class="reference" id="类型-序数类型_toc" href="#类型-序数类型">序数类型</a></li>
<li><a class="reference" id="类型-预定义整数类型_toc" href="#类型-预定义整数类型">预定义整数类型</a></li>
<li><a class="reference" id="类型-子范围类型_toc" href="#类型-子范围类型">子范围类型</a></li>
<li><a class="reference" id="类型-预定义浮点类型_toc" href="#类型-预定义浮点类型">预定义浮点类型</a></li>
<li><a class="reference" id="类型-布尔类型_toc" href="#类型-布尔类型">布尔类型</a></li>
<li><a class="reference" id="类型-字符类型_toc" href="#类型-字符类型">字符类型</a></li>
<li><a class="reference" id="类型-枚举类型_toc" href="#类型-枚举类型">枚举类型</a></li>
<li><a class="reference" id="类型-字符串类型_toc" href="#类型-字符串类型">字符串类型</a></li>
<li><a class="reference" id="类型-cstring类型_toc" href="#类型-cstring类型">cstring类型</a></li>
<li><a class="reference" id="类型-结构化类型_toc" href="#类型-结构化类型">结构化类型</a></li>
<li><a class="reference" id="类型-数组和序列类型_toc" href="#类型-数组和序列类型">数组和序列类型</a></li>
<li><a class="reference" id="类型-开放数组（openarray）_toc" href="#类型-开放数组（openarray）">开放数组（openarray）</a></li>
<li><a class="reference" id="类型-可变参数_toc" href="#类型-可变参数">可变参数</a></li>
<li><a class="reference" id="类型-未检查数组_toc" href="#类型-未检查数组">未检查数组</a></li>
<li><a class="reference" id="类型-元组和对象类型_toc" href="#类型-元组和对象类型">元组和对象类型</a></li>
<li><a class="reference" id="类型-对象构造_toc" href="#类型-对象构造">对象构造</a></li>
<li><a class="reference" id="类型-对象变体_toc" href="#类型-对象变体">对象变体</a></li>
<li><a class="reference" id="类型-集合类型_toc" href="#类型-集合类型">集合类型</a></li>
<ul class="simple"><li><a class="reference" id="集合类型-位字段_toc" href="#集合类型-位字段">位字段</a></li>
</ul><li><a class="reference" id="类型-引用和指针类型_toc" href="#类型-引用和指针类型">引用和指针类型</a></li>
<li><a class="reference" id="类型-将gc内存和-ptr-混用_toc" href="#类型-将gc内存和-ptr-混用">将GC内存和 <tt class="docutils literal"><span class="pre">ptr</span></tt> 混用</a></li>
<li><a class="reference" id="类型-not-nil注解_toc" href="#类型-not-nil注解">Not nil注解</a></li>
<li><a class="reference" id="类型-过程类型_toc" href="#类型-过程类型">过程类型</a></li>
<li><a class="reference" id="类型-distinct类型_toc" href="#类型-distinct类型">Distinct类型</a></li>
<ul class="simple"><li><a class="reference" id="distinct类型-模拟货币_toc" href="#distinct类型-模拟货币">模拟货币</a></li>
<li><a class="reference" id="distinct类型-避免sql注入攻击_toc" href="#distinct类型-避免sql注入攻击">避免SQL注入攻击</a></li>
</ul><li><a class="reference" id="类型-自动类型_toc" href="#类型-自动类型">自动类型</a></li>
</ul><li><a class="reference" id="类型关系_toc" href="#类型关系">类型关系</a></li>
<ul class="simple"><li><a class="reference" id="类型关系-类型相等性_toc" href="#类型关系-类型相等性">类型相等性</a></li>
<li><a class="reference" id="类型关系-类型相等与类型区分_toc" href="#类型关系-类型相等与类型区分">类型相等与类型区分</a></li>
<li><a class="reference" id="类型关系-子类型关系_toc" href="#类型关系-子类型关系">子类型关系</a></li>
<li><a class="reference" id="类型关系-可转换关系_toc" href="#类型关系-可转换关系">可转换关系</a></li>
<li><a class="reference" id="类型关系-赋值兼容性_toc" href="#类型关系-赋值兼容性">赋值兼容性</a></li>
</ul><li><a class="reference" id="重载解析_toc" href="#重载解析">重载解析</a></li>
<ul class="simple"><li><a class="reference" id="重载解析-基于-var-t-的重载_toc" href="#重载解析-基于-var-t-的重载">基于 'var T' 的重载</a></li>
<li><a class="reference" id="重载解析-无类型的延迟类型解析_toc" href="#重载解析-无类型的延迟类型解析">无类型的延迟类型解析</a></li>
<li><a class="reference" id="重载解析-可变参数匹配_toc" href="#重载解析-可变参数匹配">可变参数匹配</a></li>
</ul><li><a class="reference" id="语句和表达式_toc" href="#语句和表达式">语句和表达式</a></li>
<ul class="simple"><li><a class="reference" id="语句和表达式-语句列表表达式_toc" href="#语句和表达式-语句列表表达式">语句列表表达式</a></li>
<li><a class="reference" id="语句和表达式-discard表达式_toc" href="#语句和表达式-discard表达式">Discard表达式</a></li>
<li><a class="reference" id="语句和表达式-void上下文_toc" href="#语句和表达式-void上下文">Void上下文</a></li>
<li><a class="reference" id="语句和表达式-var语句_toc" href="#语句和表达式-var语句">Var语句</a></li>
<li><a class="reference" id="语句和表达式-let语句_toc" href="#语句和表达式-let语句">Let语句</a></li>
<li><a class="reference" id="语句和表达式-元组解包_toc" href="#语句和表达式-元组解包">元组解包</a></li>
<li><a class="reference" id="语句和表达式-常量段_toc" href="#语句和表达式-常量段">常量段</a></li>
<li><a class="reference" id="语句和表达式-静态语句和表达式_toc" href="#语句和表达式-静态语句和表达式">静态语句和表达式</a></li>
<li><a class="reference" id="语句和表达式-if语句_toc" href="#语句和表达式-if语句">If语句</a></li>
<li><a class="reference" id="语句和表达式-case语句_toc" href="#语句和表达式-case语句">Case语句</a></li>
<li><a class="reference" id="语句和表达式-when语句_toc" href="#语句和表达式-when语句">When语句</a></li>
<li><a class="reference" id="语句和表达式-when-nimvm语句_toc" href="#语句和表达式-when-nimvm语句">When nimvm语句</a></li>
<li><a class="reference" id="语句和表达式-return语句_toc" href="#语句和表达式-return语句">Return语句</a></li>
<li><a class="reference" id="语句和表达式-yield语句_toc" href="#语句和表达式-yield语句">Yield语句</a></li>
<li><a class="reference" id="语句和表达式-block语句_toc" href="#语句和表达式-block语句">Block语句</a></li>
<li><a class="reference" id="语句和表达式-break语句_toc" href="#语句和表达式-break语句">Break语句</a></li>
<li><a class="reference" id="语句和表达式-while语句_toc" href="#语句和表达式-while语句">While语句</a></li>
<li><a class="reference" id="语句和表达式-continue语句_toc" href="#语句和表达式-continue语句">Continue语句</a></li>
<li><a class="reference" id="语句和表达式-汇编语句_toc" href="#语句和表达式-汇编语句">汇编语句</a></li>
<li><a class="reference" id="语句和表达式-using语句_toc" href="#语句和表达式-using语句">Using语句</a></li>
<li><a class="reference" id="语句和表达式-if表达式_toc" href="#语句和表达式-if表达式">If表达式</a></li>
<li><a class="reference" id="语句和表达式-when表达式_toc" href="#语句和表达式-when表达式">When表达式</a></li>
<li><a class="reference" id="语句和表达式-case表达式_toc" href="#语句和表达式-case表达式">Case表达式</a></li>
<li><a class="reference" id="语句和表达式-block表达式_toc" href="#语句和表达式-block表达式">Block表达式</a></li>
<li><a class="reference" id="语句和表达式-table构造函数_toc" href="#语句和表达式-table构造函数">Table构造函数</a></li>
<li><a class="reference" id="语句和表达式-类型转换_toc" href="#语句和表达式-类型转换">类型转换</a></li>
<li><a class="reference" id="语句和表达式-类型强转_toc" href="#语句和表达式-类型强转">类型强转</a></li>
<li><a class="reference" id="语句和表达式-addr操作符_toc" href="#语句和表达式-addr操作符">addr操作符</a></li>
<li><a class="reference" id="语句和表达式-unsafeaddr操作符_toc" href="#语句和表达式-unsafeaddr操作符">unsafeAddr操作符</a></li>
</ul><li><a class="reference" id="过程_toc" href="#过程">过程</a></li>
<ul class="simple"><li><a class="reference" id="过程-导出标记_toc" href="#过程-导出标记">导出标记</a></li>
<li><a class="reference" id="过程-方法调用语法_toc" href="#过程-方法调用语法">方法调用语法</a></li>
<li><a class="reference" id="过程-属性_toc" href="#过程-属性">属性</a></li>
<li><a class="reference" id="过程-命令调用语法_toc" href="#过程-命令调用语法">命令调用语法</a></li>
<li><a class="reference" id="过程-闭包_toc" href="#过程-闭包">闭包</a></li>
<ul class="simple"><li><a class="reference" id="闭包-在循环中创建闭包_toc" href="#闭包-在循环中创建闭包">在循环中创建闭包</a></li>
</ul><li><a class="reference" id="过程-匿名过程_toc" href="#过程-匿名过程">匿名过程</a></li>
<li><a class="reference" id="过程-函数_toc" href="#过程-函数">函数</a></li>
<li><a class="reference" id="过程-不可重载的内置_toc" href="#过程-不可重载的内置">不可重载的内置</a></li>
<li><a class="reference" id="过程-var形参_toc" href="#过程-var形参">Var形参</a></li>
<li><a class="reference" id="过程-var返回类型_toc" href="#过程-var返回类型">Var返回类型</a></li>
<ul class="simple"><li><a class="reference" id="var返回类型-未来的方向_toc" href="#var返回类型-未来的方向">未来的方向</a></li>
</ul><li><a class="reference" id="过程-下标操作符重载_toc" href="#过程-下标操作符重载">下标操作符重载</a></li>
</ul><li><a class="reference" id="多方法_toc" href="#多方法">多方法</a></li>
<ul class="simple"><li><a class="reference" id="多方法-通过proccall禁止动态方法解析_toc" href="#多方法-通过proccall禁止动态方法解析">通过procCall禁止动态方法解析</a></li>
</ul><li><a class="reference" id="迭代器和for语句_toc" href="#迭代器和for语句">迭代器和for语句</a></li>
<ul class="simple"><li><a class="reference" id="迭代器和for语句-隐式items和pairs调用_toc" href="#迭代器和for语句-隐式items和pairs调用">隐式items和pairs调用</a></li>
<li><a class="reference" id="迭代器和for语句-第一类迭代器_toc" href="#迭代器和for语句-第一类迭代器">第一类迭代器</a></li>
</ul><li><a class="reference" id="转换器_toc" href="#转换器">转换器</a></li>
<li><a class="reference" id="type段_toc" href="#type段">Type段</a></li>
<li><a class="reference" id="异常处理_toc" href="#异常处理">异常处理</a></li>
<ul class="simple"><li><a class="reference" id="异常处理-try语句_toc" href="#异常处理-try语句">Try语句</a></li>
<li><a class="reference" id="异常处理-try表达式_toc" href="#异常处理-try表达式">Try表达式</a></li>
<li><a class="reference" id="异常处理-排除从句_toc" href="#异常处理-排除从句">排除从句</a></li>
<li><a class="reference" id="异常处理-defer语句_toc" href="#异常处理-defer语句">Defer语句</a></li>
<li><a class="reference" id="异常处理-raise语句_toc" href="#异常处理-raise语句">Raise语句</a></li>
<li><a class="reference" id="异常处理-异常层级_toc" href="#异常处理-异常层级">异常层级</a></li>
<li><a class="reference" id="异常处理-导入的异常_toc" href="#异常处理-导入的异常">导入的异常</a></li>
</ul><li><a class="reference" id="效应系统_toc" href="#效应系统">效应系统</a></li>
<ul class="simple"><li><a class="reference" id="效应系统-异常跟踪_toc" href="#效应系统-异常跟踪">异常跟踪</a></li>
<li><a class="reference" id="效应系统-tag跟踪_toc" href="#效应系统-tag跟踪">Tag跟踪</a></li>
<li><a class="reference" id="效应系统-effects编译指示_toc" href="#效应系统-effects编译指示">Effects编译指示</a></li>
</ul><li><a class="reference" id="泛型_toc" href="#泛型">泛型</a></li>
<ul class="simple"><li><a class="reference" id="泛型-is操作符_toc" href="#泛型-is操作符">Is操作符</a></li>
<li><a class="reference" id="泛型-类型类别_toc" href="#泛型-类型类别">类型类别</a></li>
<li><a class="reference" id="泛型-泛型推导限制_toc" href="#泛型-泛型推导限制">泛型推导限制</a></li>
<li><a class="reference" id="泛型-泛型符号查找_toc" href="#泛型-泛型符号查找">泛型符号查找</a></li>
<ul class="simple"><li><a class="reference" id="泛型符号查找-开放和封闭的符号_toc" href="#泛型符号查找-开放和封闭的符号">开放和封闭的符号</a></li>
</ul><li><a class="reference" id="泛型-mixin语句_toc" href="#泛型-mixin语句">Mixin语句</a></li>
<li><a class="reference" id="泛型-bind语句_toc" href="#泛型-bind语句">Bind语句</a></li>
</ul><li><a class="reference" id="模板_toc" href="#模板">模板</a></li>
<ul class="simple"><li><a class="reference" id="模板-类型化和无类型形参_toc" href="#模板-类型化和无类型形参">类型化和无类型形参</a></li>
<li><a class="reference" id="模板-向模板传代码块_toc" href="#模板-向模板传代码块">向模板传代码块</a></li>
<li><a class="reference" id="模板-无类型可变参数_toc" href="#模板-无类型可变参数">无类型可变参数</a></li>
<li><a class="reference" id="模板-模板符号绑定_toc" href="#模板-模板符号绑定">模板符号绑定</a></li>
<li><a class="reference" id="模板-标识符构造_toc" href="#模板-标识符构造">标识符构造</a></li>
<li><a class="reference" id="模板-模板形参查询规则_toc" href="#模板-模板形参查询规则">模板形参查询规则</a></li>
<li><a class="reference" id="模板-模板卫生_toc" href="#模板-模板卫生">模板卫生</a></li>
<li><a class="reference" id="模板-方法调用语法限制_toc" href="#模板-方法调用语法限制">方法调用语法限制</a></li>
</ul><li><a class="reference" id="宏_toc" href="#宏">宏</a></li>
<ul class="simple"><li><a class="reference" id="宏-debug示例_toc" href="#宏-debug示例">Debug示例</a></li>
<li><a class="reference" id="宏-bindsym_toc" href="#宏-bindsym">BindSym</a></li>
<li><a class="reference" id="宏-caseminusof宏_toc" href="#宏-caseminusof宏">Case-Of宏</a></li>
<li><a class="reference" id="宏-macros用作编译指示_toc" href="#宏-macros用作编译指示">Macros用作编译指示</a></li>
<li><a class="reference" id="宏-for循环宏_toc" href="#宏-for循环宏">For循环宏</a></li>
</ul><li><a class="reference" id="特殊类型_toc" href="#特殊类型">特殊类型</a></li>
<ul class="simple"><li><a class="reference" id="特殊类型-static-t_toc" href="#特殊类型-static-t">static[T]</a></li>
<li><a class="reference" id="特殊类型-typedesc-t_toc" href="#特殊类型-typedesc-t">typedesc[T]</a></li>
<li><a class="reference" id="特殊类型-typeof操作符_toc" href="#特殊类型-typeof操作符">typeof操作符</a></li>
</ul><li><a class="reference" id="模块_toc" href="#模块">模块</a></li>
<ul class="simple"><li><a class="reference" id="模块-import语句_toc" href="#模块-import语句">Import语句</a></li>
<li><a class="reference" id="模块-include语句_toc" href="#模块-include语句">Include语句</a></li>
<li><a class="reference" id="模块-导入的模块名_toc" href="#模块-导入的模块名">导入的模块名</a></li>
<li><a class="reference" id="模块-从目录中集体导入_toc" href="#模块-从目录中集体导入">从目录中集体导入</a></li>
<li><a class="reference" id="模块-伪importslashinclude目录_toc" href="#模块-伪importslashinclude目录">伪import/include目录</a></li>
<li><a class="reference" id="模块-from-import语句_toc" href="#模块-from-import语句">From import语句</a></li>
<li><a class="reference" id="模块-export语句_toc" href="#模块-export语句">Export语句</a></li>
</ul><ul class="simple"><li><a class="reference" id="模块-作用域规则_toc" href="#模块-作用域规则">作用域规则</a></li>
<ul class="simple"><li><a class="reference" id="作用域规则-块作用域_toc" href="#作用域规则-块作用域">块作用域</a></li>
<li><a class="reference" id="作用域规则-元组或对象作用域_toc" href="#作用域规则-元组或对象作用域">元组或对象作用域</a></li>
<li><a class="reference" id="作用域规则-模块作用域_toc" href="#作用域规则-模块作用域">模块作用域</a></li>
<li><a class="reference" id="作用域规则-代码重排_toc" href="#作用域规则-代码重排">代码重排</a></li>
</ul></ul><li><a class="reference" id="编译器消息_toc" href="#编译器消息">编译器消息</a></li>
<li><a class="reference" id="编译指示_toc" href="#编译指示">编译指示</a></li>
<ul class="simple"><li><a class="reference" id="编译指示-deprecated编译指示_toc" href="#编译指示-deprecated编译指示">deprecated编译指示</a></li>
<li><a class="reference" id="编译指示-nosideeffect编译指示_toc" href="#编译指示-nosideeffect编译指示">noSideEffect编译指示</a></li>
<li><a class="reference" id="编译指示-compiletime编译指示_toc" href="#编译指示-compiletime编译指示">compileTime编译指示</a></li>
<li><a class="reference" id="编译指示-noreturn编译指示_toc" href="#编译指示-noreturn编译指示">noReturn编译指示</a></li>
<li><a class="reference" id="编译指示-acyclic编译指示_toc" href="#编译指示-acyclic编译指示">acyclic编译指示</a></li>
<li><a class="reference" id="编译指示-final编译指示_toc" href="#编译指示-final编译指示">final编译指示</a></li>
<li><a class="reference" id="编译指示-shallow编译指示_toc" href="#编译指示-shallow编译指示">shallow编译指示</a></li>
<li><a class="reference" id="编译指示-pure编译指示_toc" href="#编译指示-pure编译指示">pure编译指示</a></li>
<li><a class="reference" id="编译指示-asmnostackframe编译指示_toc" href="#编译指示-asmnostackframe编译指示">asmNoStackFrame编译指示</a></li>
<li><a class="reference" id="编译指示-error编译指示_toc" href="#编译指示-error编译指示">error编译指示</a></li>
<li><a class="reference" id="编译指示-fatal编译指示_toc" href="#编译指示-fatal编译指示">fatal编译指示</a></li>
<li><a class="reference" id="编译指示-warning编译指示_toc" href="#编译指示-warning编译指示">warning编译指示</a></li>
<li><a class="reference" id="编译指示-hint编译指示_toc" href="#编译指示-hint编译指示">hint编译指示</a></li>
<li><a class="reference" id="编译指示-line编译指示_toc" href="#编译指示-line编译指示">line编译指示</a></li>
<li><a class="reference" id="编译指示-linearscanend-编译指示_toc" href="#编译指示-linearscanend-编译指示">linearScanEnd 编译指示</a></li>
<li><a class="reference" id="编译指示-computedgoto编译指示_toc" href="#编译指示-computedgoto编译指示">computedGoto编译指示</a></li>
<li><a class="reference" id="编译指示-unroll编译指示_toc" href="#编译指示-unroll编译指示">unroll编译指示</a></li>
<li><a class="reference" id="编译指示-immediate编译指示_toc" href="#编译指示-immediate编译指示">immediate编译指示</a></li>
<li><a class="reference" id="编译指示-编译选项编译指示_toc" href="#编译指示-编译选项编译指示">编译选项编译指示</a></li>
<li><a class="reference" id="编译指示-push和pop编译指示_toc" href="#编译指示-push和pop编译指示">push和pop编译指示</a></li>
<li><a class="reference" id="编译指示-register编译指示_toc" href="#编译指示-register编译指示">register编译指示</a></li>
<li><a class="reference" id="编译指示-global编译指示_toc" href="#编译指示-global编译指示">global编译指示</a></li>
<li><a class="reference" id="编译指示-pragma编译指示_toc" href="#编译指示-pragma编译指示">pragma编译指示</a></li>
<li><a class="reference" id="编译指示-禁用某些消息_toc" href="#编译指示-禁用某些消息">禁用某些消息</a></li>
<li><a class="reference" id="编译指示-used编译指示_toc" href="#编译指示-used编译指示">used编译指示</a></li>
<li><a class="reference" id="编译指示-experimental编译指示_toc" href="#编译指示-experimental编译指示">experimental编译指示</a></li>
</ul><li><a class="reference" id="特定实现的编译指示_toc" href="#特定实现的编译指示">特定实现的编译指示</a></li>
<ul class="simple"><li><a class="reference" id="特定实现的编译指示-bitsize-编译指示_toc" href="#特定实现的编译指示-bitsize-编译指示">Bitsize 编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-volatile编译指示_toc" href="#特定实现的编译指示-volatile编译指示">Volatile编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-nodecl编译指示_toc" href="#特定实现的编译指示-nodecl编译指示">NoDecl编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-header编译指示_toc" href="#特定实现的编译指示-header编译指示">Header编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-incompletestruct编译指示_toc" href="#特定实现的编译指示-incompletestruct编译指示">IncompleteStruct编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-compile编译指示_toc" href="#特定实现的编译指示-compile编译指示">Compile编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-link编译指示_toc" href="#特定实现的编译指示-link编译指示">Link编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-passc编译指示_toc" href="#特定实现的编译指示-passc编译指示">PassC编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-passl编译指示_toc" href="#特定实现的编译指示-passl编译指示">PassL编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-emit编译指示_toc" href="#特定实现的编译指示-emit编译指示">Emit编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-importcpp编译指示_toc" href="#特定实现的编译指示-importcpp编译指示">ImportCpp编译指示</a></li>
<ul class="simple"><li><a class="reference" id="importcpp编译指示-命名空间_toc" href="#importcpp编译指示-命名空间">命名空间</a></li>
<li><a class="reference" id="importcpp编译指示-枚举importcpp_toc" href="#importcpp编译指示-枚举importcpp">枚举Importcpp</a></li>
<li><a class="reference" id="importcpp编译指示-过程importcpp_toc" href="#importcpp编译指示-过程importcpp">过程Importcpp</a></li>
<li><a class="reference" id="importcpp编译指示-封装构造函数_toc" href="#importcpp编译指示-封装构造函数">封装构造函数</a></li>
<li><a class="reference" id="importcpp编译指示-封装析构函数_toc" href="#importcpp编译指示-封装析构函数">封装析构函数</a></li>
<li><a class="reference" id="importcpp编译指示-对象的importcpp_toc" href="#importcpp编译指示-对象的importcpp">对象的Importcpp</a></li>
</ul><li><a class="reference" id="特定实现的编译指示-importobjc编译指示_toc" href="#特定实现的编译指示-importobjc编译指示">ImportObjC编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-codegendecl编译指示_toc" href="#特定实现的编译指示-codegendecl编译指示">CodegenDecl编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-injectstmt编译指示_toc" href="#特定实现的编译指示-injectstmt编译指示">InjectStmt编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-编译期定义的编译指示_toc" href="#特定实现的编译指示-编译期定义的编译指示">编译期定义的编译指示</a></li>
<li><a class="reference" id="特定实现的编译指示-自定义标注_toc" href="#特定实现的编译指示-自定义标注">自定义标注</a></li>
</ul><li><a class="reference" id="外部函数接口_toc" href="#外部函数接口">外部函数接口</a></li>
<ul class="simple"><li><a class="reference" id="外部函数接口-importc编译指示_toc" href="#外部函数接口-importc编译指示">Importc编译指示</a></li>
<li><a class="reference" id="外部函数接口-exportc编译指示_toc" href="#外部函数接口-exportc编译指示">Exportc编译指示</a></li>
<li><a class="reference" id="外部函数接口-extern编译指示_toc" href="#外部函数接口-extern编译指示">Extern编译指示</a></li>
<li><a class="reference" id="外部函数接口-bycopy编译指示_toc" href="#外部函数接口-bycopy编译指示">Bycopy编译指示</a></li>
<li><a class="reference" id="外部函数接口-byref编译指示_toc" href="#外部函数接口-byref编译指示">Byref编译指示</a></li>
<li><a class="reference" id="外部函数接口-varargs编译指示_toc" href="#外部函数接口-varargs编译指示">Varargs编译指示</a></li>
<li><a class="reference" id="外部函数接口-union编译指示_toc" href="#外部函数接口-union编译指示">Union编译指示</a></li>
<li><a class="reference" id="外部函数接口-packed编译指示_toc" href="#外部函数接口-packed编译指示">Packed编译指示</a></li>
<li><a class="reference" id="外部函数接口-用于导入的dynlib编译指示_toc" href="#外部函数接口-用于导入的dynlib编译指示">用于导入的Dynlib编译指示</a></li>
<li><a class="reference" id="外部函数接口-用于导出的dynlib编译指示_toc" href="#外部函数接口-用于导出的dynlib编译指示">用于导出的Dynlib编译指示</a></li>
</ul><li><a class="reference" id="线程_toc" href="#线程">线程</a></li>
<ul class="simple"><li><a class="reference" id="线程-thread编译指示_toc" href="#线程-thread编译指示">Thread编译指示</a></li>
<li><a class="reference" id="线程-gc安全_toc" href="#线程-gc安全">GC安全</a></li>
<li><a class="reference" id="线程-threadvar编译指示_toc" href="#线程-threadvar编译指示">Threadvar编译指示</a></li>
<li><a class="reference" id="线程-线程和异常_toc" href="#线程-线程和异常">线程和异常</a></li>
</ul>
</ul>

  </div>
  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  
  <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">Authors:</th><td> Andreas Rumpf, Zahary Karadjov</td></tr>
<tr><th class="docinfo-name">Version:</th><td> |nimversion|</td></tr>
</tbody></table><blockquote><p>&quot;复杂度&quot;很像&quot;能量&quot;: 你可以将它从最终用户转移到一个或多个其他玩家，但总量对于给定的任务保持不变。-- Ran</p></blockquote>

<h1><a class="toc-backref" id="关于本文" href="#关于本文">关于本文</a></h1><p><strong>注意</strong> : 这份文件是草案，Nim的一些功能可能需要更精确的措辞。本手册不断发展为合适的规范。</p>
<p><strong>注意</strong> : Nim的实验特性在 <a class="reference external" href="manual_experimental.html">这里</a> 。</p>
<p>本文描述Nim语言的词汇、语法，和语义。</p>
<p>学习如何编译Nim程序和生成文档见 <a class="reference external" href="nimc.html">Compiler User Guide</a> 和 <a class="reference external" href="docgen.html">DocGen Tools Guide</a> 。</p>
<p>语言构造用扩展巴科斯范式（BNF）解释，其中 <tt class="docutils literal"><span class="pre">(a)*</span></tt> 表示 0 或者更多 <tt class="docutils literal"><span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">a+</span></tt> 表示1或更多 <tt class="docutils literal"><span class="pre">a</span></tt>, 以及 <tt class="docutils literal"><span class="pre">(a)?</span></tt> 表示可选 <em>a</em> 。小括号用来对元素进行分组。</p>
<p><tt class="docutils literal"><span class="pre">&amp;</span></tt> 是先行操作符; <tt class="docutils literal"><span class="pre">&amp;a</span></tt> 表示需要 <tt class="docutils literal"><span class="pre">a</span></tt> 但不被消耗。它将在下列规则中消耗。</p>
<p><tt class="docutils literal"><span class="pre">|</span></tt>, <tt class="docutils literal"><span class="pre">/</span></tt> 符号用于标记可选并且优先级最低。 <tt class="docutils literal"><span class="pre">/</span></tt> 是要求解析器尝试给定顺序的可选项的有序选择。 <tt class="docutils literal"><span class="pre">/</span></tt> 常用于确保语法没有歧义。</p>
<p>非终端符以小写字母开始，抽象终端符用大写。</p>
<p>逐字终端符（包括关键字）用 <tt class="docutils literal"><span class="pre">'</span></tt> 引用。示例:<pre>
ifStmt = 'if' expr ':' stmts ('elif' expr ':' stmts)* ('else' stmts)?</pre>
</p>
<p>二元操作符 <tt class="docutils literal"><span class="pre">^*</span></tt> 用于由第二个实参分隔的0或多次出现的简写；不像 <tt class="docutils literal"><span class="pre">^+</span></tt> 表示1或多个出现: <tt class="docutils literal"><span class="pre">a ^+ b</span></tt> 是 <tt class="docutils literal"><span class="pre">a (b a)*</span></tt> 的简写 <tt class="docutils literal"><span class="pre">a ^* b</span></tt> 是 <tt class="docutils literal"><span class="pre">(a (b a)*)?</span></tt> 的简写。示例:<pre>
arrayConstructor = '[' expr ^* ',' ']'</pre>
</p>
<p>Nim的其他部分，如作用域规则或运行时语义，都是非正式描述的。</p>

<h1><a class="toc-backref" id="定义" href="#定义">定义</a></h1><p>Nim代码指定一个计算，该计算作用于由称为 <span id="位置_1">位置</span> 的组件组成的内存。 变量基本上是位置的名称。每个变量和位置都是某种 <span id="类型_1">类型</span> 。 变量类型叫做 <span id="静态类型_1">静态类型</span> ，位置的类型叫做 <span id="动态类型_1">动态类型</span> 。 如果静态类型和动态类型不一样，它是动态类型的一个超类型或子类型。</p>
<blockquote><p><span id="标识符_1">标识符</span> 是声明为变量，类型，过程等的名称的符号。</p></blockquote>
<p>声明适用的程序区域叫做 <span id="作用域_1">作用域</span> 。作用域可以嵌套。 标识符的含义由声明标识符的最小封闭范围确定，除非重载解析规则另有说明。</p>
<p>表达式指定生成值或位置的计算。产生位置的表达式叫 <span id="左值_1">左值</span> 。左值可以表示位置或位置包含的值，具体取决于上下文。</p>
<p>Nim <span id="程序_1">程序</span> 由一个或多个包含Nim代码的文本 <span id="源文件_1">源文件</span> 构成。 它由Nim <span id="编译器_1">编译器</span> 处理成一个 <span id="可执行文件_1">可执行文件</span> 。 可执行文件的类型取决于编译器实现； 例如它可以是原生二进制或JavaScript源代码。</p>
<p>在典型的Nim程序中，多数代码编译成可执行文件。 但是，某些代码可以在 <span id="编译期_1">编译期</span> 执行 。 这可以包括宏定义使用的常量表达式，宏定义，和Nim过程。 编译期支持大部分Nim语言，但有一些限制 -- 详见 <a class="reference external" href="#restrictions-on-compileminustime-execution">Restrictions on Compile-Time Execution</a> 。 我们用术语 <span id="进行时_1">进行时</span> 来涵盖可执行文件中的编译时执行和代码执行。</p>
<p>编译器把Nim源代码解析为称为 <span id="抽象语法树_1">抽象语法树</span> (<span id="ast_1">AST</span>) 的内部数据结构 。 然后，在执行代码或编译成可执行文件前，通过 <span id="语义分析_1">语义分析</span> 变换AST。 这会添加语义信息，诸如表达式类型、标识符含义，以及某些情况下的表达式值。 语义分析期间的错误叫做 <span id="静态错误_1">静态错误</span> 。 未另行指定时，本手册中描述的错误是静态错误。</p>
<p><span id="运行时检查错误_1">运行时检查错误</span> 是实现在运行时检查并报告的错误。 报错此类错误的方法是通过 <em>引发异常</em> 或 <em>以致命错误退出</em> 。 但是，该实现提供了禁用这些 <span id="运行时检查_1">运行时检查</span> 的方法 . 有关详细信息，请参阅 <a class="reference external" href="#pragmas">pragmas</a> 部分。</p>
<p>检查的运行时错误是导致异常还是致命错误取决于实现。 因此以下程序无效；即使代码声称从越界数组访问中捕获 <tt class="docutils literal"><span class="pre">IndexError</span></tt> ，编译器也可以选择允许程序退出致命错误。</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">]</span>
<span class="Keyword">let</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">5</span>
<span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="CharLit">'N'</span>
<span class="Keyword">except</span> <span class="Identifier">IndexError</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;invalid index&quot;</span></pre><p><span id="未经检查的运行时错误_1">未经检查的运行时错误</span> 是一个不能保证被检测到的错误，并且可能导致任意的计算后续行为。 如果仅使用 <span id="safe_1">safe</span> 语言功能并且未禁用运行时检查，则不会发生未经检查的运行时错误。</p>
<p><span id="常量表达式_1">常量表达式</span> 是一个表达式，其值可以在出现的代码的语义分析期间计算。 它不是左值也没有副作用。 常量表达式不仅限于语义分析的功能，例如常量折叠;他们可以使用编译时执行所支持的所有Nim语言功能。 由于常量表达式可以用作语义分析的输入（例如用于定义数组边界），因此这种灵活性要求编译器交错语义分析和编译时代码执行。</p>
<p>在源代码中从上到下和从左到右进行图像语义分析是非常准确的，在必要时交错编译时代码执行以计算后续语义分析所需的值。 我们将在本文档后面看到，宏调用不仅需要这种交错，而且还会产生语义分析不能完全从上到下，从左到右进行的情况。</p>

<h1><a class="toc-backref" id="词法分析" href="#词法分析">词法分析</a></h1>
<h2><a class="toc-backref" id="词法分析-编码" href="#词法分析-编码">编码</a></h2><p>所有Nim源文件都采用UTF-8编码（或其ASCII子集）。 其他编码不受支持。 可以使用任何标准平台行终端序列 - Unix使用ASCII LF（换行），Windows使用ASCII序列CR LF的（返回后跟换行），老的Macintosh使用ASCII CR（返回）字符。 无论什么平台，使用这些形式的效果是一样的。</p>

<h2><a class="toc-backref" id="词法分析-缩进" href="#词法分析-缩进">缩进</a></h2><p>Nim的标准语法描述了一个 <span id="缩进敏感_1">缩进敏感</span> 语言。 这意味着所有控制结构都可以通过缩进识别。 缩进仅由空格组成;制表符是不允许的。</p>
<p>缩进处理按如下方式实现：词法分析器使用前面的空格数注释以下标记;缩进不是一个单独的标记。 这个技巧允许只用1个先行标记解析Nim。</p>
<p>解析器使用由整数个空格组成的缩进堆栈级别。 缩进信息在解析器重要的位置上查询，否则被忽略：伪终端 <tt class="docutils literal"><span class="pre">IND{&gt;}</span></tt> 表示由比在堆栈顶部更多的空格构成； <tt class="docutils literal"><span class="pre">IND{=}</span></tt> 缩进具有相同数量的空格。 <tt class="docutils literal"><span class="pre">DED</span></tt> 是描述从堆栈弹出一个值的运作的伪代码， <tt class="docutils literal"><span class="pre">IND{&gt;}</span></tt> 意味着推到栈上。</p>
<p>使用这种表示法，我们现在可以轻松定义语法的核心：一个语句块（简化示例）:<pre>
ifStmt = 'if' expr ':' stmt
         (IND{=} 'elif' expr ':' stmt)*
         (IND{=} 'else' ':' stmt)?

simpleStmt = ifStmt / ...

stmt = IND{&gt;} stmt ^+ IND{=} DED  # list of statements
     / simpleStmt                 # or a simple statement</pre>
</p>

<h2><a class="toc-backref" id="词法分析-注释" href="#词法分析-注释">注释</a></h2><p>注释从字符串或字符字面值外的任何地方开始，并带有哈希字符 <tt class="docutils literal"><span class="pre">#</span></tt> 。 注释包含 <span id="注释片段_1">注释片段</span> 的连接。 评论文章以 <tt class="docutils literal"><span class="pre">#</span></tt> 开头，​​一直运行到行尾。 行尾字符属于该片段。 如果下一行只包含一个注释片段，而它与前一个片段之间没有其他符号，则它不会启动新注释：</p>
<pre class="listing"><span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">0</span>     <span class="Comment"># 这是跨行的单个注释。</span>
  <span class="Comment"># 扫描器合并这个块。</span>
  <span class="Comment"># 注释从这里继续。</span></pre><p><span id="文档注释_1">文档注释</span> 由两个开始 <tt class="docutils literal"><span class="pre">##</span></tt> 。 文档注释是符号；它们仅允许出现在输入文件的某个地方，因为它们属于语法树。</p>

<h2><a class="toc-backref" id="词法分析-多行注释" href="#词法分析-多行注释">多行注释</a></h2><p>从版本0.13.0开始，Nim支持多行注释。</p>
<pre class="listing"><span class="LongComment">#[注释这里.
多行
不是问题。]#</span></pre><p>多行注释支持嵌套：</p>
<pre class="listing"><span class="LongComment">#[  #[ 在已经注释代码中的多行注释]#
proc p[T](x: T) = discard
]#</span></pre><p>多行文档注释并支持嵌套：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">foo</span> <span class="Operator">=</span>
  <span class="LongComment">##[长文档注释。
  ]##</span></pre>
<h2><a class="toc-backref" id="词法分析-标识符-amp-关键字" href="#词法分析-标识符-amp-关键字">标识符 &amp; 关键字</a></h2><p>Nim中的标识符可以是任何以字母开头的数字、字母和下划线。不允许两个连续的下划线 <tt class="docutils literal"><span class="pre">__</span></tt> :<pre>
letter ::= 'A'..'Z' | 'a'..'z' | '\x80'..'\xff'
digit ::= '0'..'9'
IDENTIFIER ::= letter ( ['_'] (letter | digit) )*</pre>
</p>
<p>目前，序数值&gt; 127（非ASCII）的任何Unicode字符都被归类为 <tt class="docutils literal"><span class="pre">字母</span></tt> ，因此可能是标识符的一部分，但该语言的后续版本可能会指定某些Unicode字符来代替运算符字符。</p>
<p>下面预留的关键字不能用作标识符：</p>
<pre class="listing"><span class="Keyword">addr</span> <span class="Keyword">and</span> <span class="Keyword">as</span> <span class="Keyword">asm</span>
<span class="Keyword">bind</span> <span class="Keyword">block</span> <span class="Keyword">break</span>
<span class="Keyword">case</span> <span class="Keyword">cast</span> <span class="Keyword">concept</span> <span class="Keyword">const</span> <span class="Keyword">continue</span> <span class="Keyword">converter</span>
<span class="Keyword">defer</span> <span class="Keyword">discard</span> <span class="Keyword">distinct</span> <span class="Keyword">div</span> <span class="Keyword">do</span>
<span class="Keyword">elif</span> <span class="Keyword">else</span> <span class="Keyword">end</span> <span class="Keyword">enum</span> <span class="Keyword">except</span> <span class="Keyword">export</span>
<span class="Keyword">finally</span> <span class="Keyword">for</span> <span class="Keyword">from</span> <span class="Keyword">func</span>
<span class="Keyword">if</span> <span class="Keyword">import</span> <span class="Keyword">in</span> <span class="Keyword">include</span> <span class="Keyword">interface</span> <span class="Keyword">is</span> <span class="Keyword">isnot</span> <span class="Keyword">iterator</span>
<span class="Keyword">let</span>
<span class="Keyword">macro</span> <span class="Keyword">method</span> <span class="Keyword">mixin</span> <span class="Keyword">mod</span>
<span class="Keyword">nil</span> <span class="Keyword">not</span> <span class="Keyword">notin</span>
<span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Keyword">or</span> <span class="Keyword">out</span>
<span class="Keyword">proc</span> <span class="Keyword">ptr</span>
<span class="Keyword">raise</span> <span class="Keyword">ref</span> <span class="Keyword">return</span>
<span class="Keyword">shl</span> <span class="Keyword">shr</span> <span class="Keyword">static</span>
<span class="Keyword">template</span> <span class="Keyword">try</span> <span class="Keyword">tuple</span> <span class="Keyword">type</span>
<span class="Keyword">using</span>
<span class="Keyword">var</span>
<span class="Keyword">when</span> <span class="Keyword">while</span>
<span class="Keyword">xor</span>
<span class="Keyword">yield</span></pre><p>有些关键字未使用;它们是为语言的未来发展而保留的。</p>

<h2><a class="toc-backref" id="词法分析-标识符相等性" href="#词法分析-标识符相等性">标识符相等性</a></h2><p>两个标识符被认为是相等的如果下列算法返回真：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">sameIdentifier</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Keyword">and</span>
    <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">replace</span><span class="Punctuation">(</span><span class="StringLit">&quot;_&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">toLowerAscii</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">replace</span><span class="Punctuation">(</span><span class="StringLit">&quot;_&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">toLowerAscii</span></pre><p>这意味着只有首字母大小写敏感。 其他字母在ASCII范围内不区分大小写，并且忽略下划线。</p>
<p>这种相当不正统的标识符比较方法称为 <span id="部分不区分大小写_1">部分不区分大小写</span> 并且具有优于传统区分大小写的一些优点:</p>
<p>它允许程序员大多使用他们自己喜欢的拼写样式，无论是humpStyle还是snake_style，不同程序员编写的库不能使用不兼容的约定。 Nim感知编辑器或IDE可以将标识符显示为首选。 另一个优点是它使程序员不必记住标识符的确切拼写。关于第一个字母的例外允许明确地解析像 <tt class="docutils literal"><span class="pre">var foo：Foo</span></tt> 这样的公共代码。</p>
<p>请注意，此规则也适用于关键字，这意味着 <tt class="docutils literal"><span class="pre">notin</span></tt> 和 <tt class="docutils literal"><span class="pre">notIn</span></tt> 以及 <tt class="docutils literal"><span class="pre">not_in</span></tt> 是相同的， (全小写版本 (<tt class="docutils literal"><span class="pre">notin</span></tt>, <tt class="docutils literal"><span class="pre">isnot</span></tt>) 是写关键字的首选方式)。</p>
<p>从历史上看，Nim是一种完全 <span id="风格不敏感_1">风格不敏感</span> 语言。 这意味着它不区分大小写并且忽略了下划线，并且 <tt class="docutils literal"><span class="pre">foo</span></tt> 和 <tt class="docutils literal"><span class="pre">Foo</span></tt> 之间甚至没有区别。</p>

<h2><a class="toc-backref" id="词法分析-字符串字面值" href="#词法分析-字符串字面值">字符串字面值</a></h2><p>语法中的终端符号: <tt class="docutils literal"><span class="pre">STR_LIT</span></tt> 。</p>
<p>字符串字面值可以通过匹配双引号来分隔，并且可以包含以下 <span id="转义序列_1">转义序列</span> :</p>
<table border="1" class="docutils"><tr><th>转义序列</th><th>含义</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">\p</span></tt></td><td>平台特定的换行: CRLF on Windows, LF on Unix</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\r</span></tt>, <tt class="docutils literal"><span class="pre">\c</span></tt></td><td><span id="回车_1">回车</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\n</span></tt>, <tt class="docutils literal"><span class="pre">\l</span></tt></td><td><span id="换行_1">换行</span> (通常叫做 <span id="新行_1">新行</span>)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\f</span></tt></td><td><span id="换页_1">换页</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\t</span></tt></td><td><span id="制表符_1">制表符</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\v</span></tt></td><td><span id="垂直制表符_1">垂直制表符</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\\</span></tt></td><td><span id="反斜线_1">反斜线</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\&quot;</span></tt></td><td><span id="双引号_1">双引号</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\'</span></tt></td><td><span id="单引号_1">单引号</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\</span></tt> '0'..'9'+</td><td><span id="十进制值的字符d_1">十进制值的字符d</span>; 后跟的所有十进制数字都用于该字符</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\a</span></tt></td><td><span id="告警_1">告警</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\b</span></tt></td><td><span id="退格_1">退格</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\e</span></tt></td><td><span id="退出_1">退出</span> <span id="esc_1">[ESC]</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\x</span></tt> HH</td><td><span id="带十六进制值的字符hh_1">带十六进制值的字符HH</span>; 只允许两位十六进制数字</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\u</span></tt> HHHH</td><td><span id="具有十六进制值的unicode代码点hhhh_1">具有十六进制值的unicode代码点HHHH</span> ; 只允许四位十六进制数字</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\u</span></tt> {H+}</td><td><span id="unicode代码点_1">unicode代码点</span>; 用 <tt class="docutils literal"><span class="pre">{}</span></tt> 括起来的所有十六进制数字都用于代码点</td></tr>
</table><p>Nim中的字符串可以包含任何8位值，甚至是嵌入的零。 但是，某些操作可能会将第一个二进制零解释为终止符。</p>

<h2><a class="toc-backref" id="词法分析-三引用字符串字面值" href="#词法分析-三引用字符串字面值">三引用字符串字面值</a></h2><p>语法中的终端符号: <tt class="docutils literal"><span class="pre">TRIPLESTR_LIT</span></tt>.</p>
<p>字符串字面值也可以用三个双引号分隔 <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> ... <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> 。 这种形式的字面值可能会持续几行，可能包含 <tt class="docutils literal"><span class="pre">&quot;</span></tt> 并且不解释任何转义序列。 为方便起见，当开头的 <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> 后面跟一个换行符 (开头 <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> 和换行符之间可能有空格）时,换行符（和前面的空格）不包含在字符串。 字符串字面值的结尾由模式定义 <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;[^&quot;]</span></tt>, 所以:</p>
<pre class="listing"><span class="LongStringLit">&quot;&quot;&quot;&quot;long string within quotes&quot;&quot;&quot;&quot;</span></pre><p>生成:<pre>
&quot;long string within quotes&quot;</pre>
</p>

<h2><a class="toc-backref" id="词法分析-原始字符串字面值" href="#词法分析-原始字符串字面值">原始字符串字面值</a></h2><p>语法中的终端符号: <tt class="docutils literal"><span class="pre">RSTR_LIT</span></tt>.</p>
<p>还有原始字符串字面值，前面带有字母 <tt class="docutils literal"><span class="pre">r</span></tt> (or <tt class="docutils literal"><span class="pre">R</span></tt>) 并通过匹配双引号（就像普通的字符串字面值一样）分隔并且不解释转义序列。 这对于正则表达式或Windows路径特别方便：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">openFile</span><span class="Punctuation">(</span><span class="RawData">r&quot;C:\texts\text.txt&quot;</span><span class="Punctuation">)</span> <span class="Comment"># 原始字符串, 所以 ``\t`` 不是制表符。</span></pre><p>为了在原始字符串中生成一个单独的 <tt class="docutils literal"><span class="pre">&quot;</span></tt> , 必须使用两个:</p>
<pre class="listing"><span class="RawData">r&quot;a&quot;&quot;</span><span class="RawData">b&quot;</span></pre><p>Produces:<pre>
a&quot;b</pre>
</p>
<p><tt class="docutils literal"><span class="pre">r&quot;&quot;&quot;&quot;</span></tt> 这个符号是不可能的，因为三个引号引用了三引号字符串字面值。 <tt class="docutils literal"><span class="pre">r&quot;&quot;&quot;</span></tt> 与 <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> 相同，因为三重引用的字符串字面值也不解释转义序列。</p>

<h2><a class="toc-backref" id="词法分析-广义原始字符串字面值" href="#词法分析-广义原始字符串字面值">广义原始字符串字面值</a></h2><p>语法中的终端符号: <tt class="docutils literal"><span class="pre">GENERALIZED_STR_LIT</span></tt>, <tt class="docutils literal"><span class="pre">GENERALIZED_TRIPLESTR_LIT</span></tt> 。</p>
<p><tt class="docutils literal"><span class="pre">标识符&quot;字符串字面值&quot;</span></tt> 这种构造(标识符和开始引号之间没有空格)是广义原始字符串。 这是 <tt class="docutils literal"><span class="pre">identifier(r&quot;string literal&quot;)</span></tt> 的缩写， 所以它表示一个过程调用原始字符串字面值作为唯一的参数。</p>
<p>广义原始字符串字面值特别便于将小型语言直接嵌入到Nim中（例如正则表达式）。</p>
<p><tt class="docutils literal"><span class="pre">标识符&quot;&quot;&quot;字符串字面值&quot;&quot;&quot;</span></tt> 也存在。它是 <tt class="docutils literal"><span class="pre">标识符(&quot;&quot;&quot;字符串字面值&quot;&quot;&quot;)</span></tt> 的缩写。</p>

<h2><a class="toc-backref" id="词法分析-字符字面值" href="#词法分析-字符字面值">字符字面值</a></h2><p>字符字面值用单引号 <tt class="docutils literal"><span class="pre">''</span></tt> 括起来，并且可以包含与字符串相同的转义序列 - 有一个例外：平台依赖的 <span id="newline_1">newline</span> (<tt class="docutils literal"><span class="pre">\p</span></tt>) 是不允许的，因为它可能比一个字符宽（通常是CR / LF对）。 以下是对字符字面值有效的 <span id="转义序列_2">转义序列</span> :</p>
<table border="1" class="docutils"><tr><th>转义序列</th><th>含义</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">\r</span></tt>, <tt class="docutils literal"><span class="pre">\c</span></tt></td><td><span id="回车_2">回车</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\n</span></tt>, <tt class="docutils literal"><span class="pre">\l</span></tt></td><td><span id="换行_2">换行</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\f</span></tt></td><td><span id="换页_2">换页</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\t</span></tt></td><td><span id="制表符_2">制表符</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\v</span></tt></td><td><span id="垂直制表符_2">垂直制表符</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\\</span></tt></td><td><span id="反斜杠_1">反斜杠</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\&quot;</span></tt></td><td><span id="双引号_2">双引号</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\'</span></tt></td><td><span id="单引号_2">单引号</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\</span></tt> '0'..'9'+</td><td><span id="十进制值的字符d_2">十进制值的字符d</span>; 后跟的所有十进制数字都用于该字符</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\a</span></tt></td><td><span id="告警_2">告警</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\b</span></tt></td><td><span id="退格_2">退格</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\e</span></tt></td><td><span id="退出_2">退出</span> <span id="esc_2">[ESC]</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\x</span></tt> HH</td><td><span id="十六进制字符hh_1">十六进制字符HH</span>; 只允许两位数字</td></tr>
</table><p>字符不是Unicode字符，而是单个字节。</p>
<p>这样做的原因是效率：对于绝大多数用例，由于UTF-8是专门为此设计的，所得到的程序仍然可以正确处理UTF-8。 另一个原因是Nim因此可以依靠这个特性像其它算法一样有效地支持 <tt class="docutils literal"><span class="pre">array[char, int]</span></tt> 或 <tt class="docutils literal"><span class="pre">set[char]</span></tt> 。 <tt class="docutils literal"><span class="pre">Rune</span></tt> 类型用于Unicode字符，它可以表示任何Unicode字符。 <tt class="docutils literal"><span class="pre">Rune</span></tt> 在 <a class="reference external" href="unicode.html">unicode module</a> 声明。</p>

<h2><a class="toc-backref" id="词法分析-数值常量" href="#词法分析-数值常量">数值常量</a></h2><p>数值常量是单一类型，并具有以下形式:<pre>
hexdigit = digit | 'A'..'F' | 'a'..'f'
octdigit = '0'..'7'
bindigit = '0'..'1'
HEX_LIT = '0' ('x' | 'X' ) hexdigit ( ['_'] hexdigit )*
DEC_LIT = digit ( ['_'] digit )*
OCT_LIT = '0' 'o' octdigit ( ['_'] octdigit )*
BIN_LIT = '0' ('b' | 'B' ) bindigit ( ['_'] bindigit )*

INT_LIT = HEX_LIT
        | DEC_LIT
        | OCT_LIT
        | BIN_LIT

INT8_LIT = INT_LIT ['\''] ('i' | 'I') '8'
INT16_LIT = INT_LIT ['\''] ('i' | 'I') '16'
INT32_LIT = INT_LIT ['\''] ('i' | 'I') '32'
INT64_LIT = INT_LIT ['\''] ('i' | 'I') '64'

UINT_LIT = INT_LIT ['\''] ('u' | 'U')
UINT8_LIT = INT_LIT ['\''] ('u' | 'U') '8'
UINT16_LIT = INT_LIT ['\''] ('u' | 'U') '16'
UINT32_LIT = INT_LIT ['\''] ('u' | 'U') '32'
UINT64_LIT = INT_LIT ['\''] ('u' | 'U') '64'

exponent = ('e' | 'E' ) ['+' | '-'] digit ( ['_'] digit )*
FLOAT_LIT = digit (['_'] digit)* (('.' digit (['_'] digit)* [exponent]) |exponent)
FLOAT32_SUFFIX = ('f' | 'F') ['32']
FLOAT32_LIT = HEX_LIT '\'' FLOAT32_SUFFIX
            | (FLOAT_LIT | DEC_LIT | OCT_LIT | BIN_LIT) ['\''] FLOAT32_SUFFIX
FLOAT64_SUFFIX = ( ('f' | 'F') '64' ) | 'd' | 'D'
FLOAT64_LIT = HEX_LIT '\'' FLOAT64_SUFFIX
            | (FLOAT_LIT | DEC_LIT | OCT_LIT | BIN_LIT) ['\''] FLOAT64_SUFFIX</pre>
</p>
<p>从结果中可以看出，数值常数可以包含下划线以便于阅读。</p>
<p>整数和浮点字面值可以用十进制（无前缀），二进制（前缀 <tt class="docutils literal"><span class="pre">0b</span></tt> ），八进制（前缀 <tt class="docutils literal"><span class="pre">0o</span></tt> ）和十六进制（前缀 <tt class="docutils literal"><span class="pre">0x</span></tt> ）表示法给出。</p>
<p>每个定义的数字类型都有一个字面值。 以一撇开始的后缀 (''') 叫 <span id="类型后缀_1">类型后缀</span> 。</p>
<p>没有类型后缀的字面值是整数类型，除非字面值包含点或 <tt class="docutils literal"><span class="pre">E|e</span></tt> ，在这种情况下它是 <tt class="docutils literal"><span class="pre">浮点</span></tt> 类型。 整数类型是 <tt class="docutils literal"><span class="pre">int</span></tt> 如果字面值在 <tt class="docutils literal"><span class="pre">low(i32)..high(i32)</span></tt> 范围，否则是 <tt class="docutils literal"><span class="pre">int64</span></tt> 。 为了符号方便，类型后缀的撇号是可选的，如果它没有歧义（只有具有类型后缀的十六进制浮点字面值可能是不明确的）。</p>
<p>类型后缀是:</p>
<table border="1" class="docutils"><tr><th>类型后缀</th><th>字面值类型</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">'i8</span></tt></td><td>int8</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'i16</span></tt></td><td>int16</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'i32</span></tt></td><td>int32</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'i64</span></tt></td><td>int64</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u</span></tt></td><td>uint</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u8</span></tt></td><td>uint8</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u16</span></tt></td><td>uint16</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u32</span></tt></td><td>uint32</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u64</span></tt></td><td>uint64</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'f</span></tt></td><td>float32</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'d</span></tt></td><td>float64</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'f32</span></tt></td><td>float32</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'f64</span></tt></td><td>float64</td></tr>
</table><p>浮点字面值也可以是二进制，八进制或十六进制表示法： 根据IEEE浮点标准， <tt class="docutils literal"><span class="pre">0B0_10001110100_0000101001000111101011101111111011000101001101001001'f64</span></tt> 约为 1.72826e35。</p>
<p>对字面值进行边界检查，以使它们适合数据类型。 非基数10字面值主要用于标志和位模式表示，因此边界检查是在位宽而非值范围上完成的。 如果字面值符合数据类型的位宽，则接受它。 因此：0b10000000'u8 == 0x80'u8 == 128，但是，0b10000000'i8 == 0x80'i8 == -1而不是导致溢出错误。</p>

<h2><a class="toc-backref" id="词法分析-操作符" href="#词法分析-操作符">操作符</a></h2><p>Nim允许用户定义的运算符。运算符是以下字符的任意组合</p>
<blockquote><p>=     +     -     *     /     &lt;     &gt; @     $     ~     &amp;     %     | !     ?     ^     .     :     
</p></blockquote>
<p>这些关键字也是操作符: <tt class="docutils literal"><span class="pre">and or not xor shl shr div mod in notin is isnot of</span></tt>.</p>
<p><span class="tok">.</span> <span class="tok">=</span>, <span class="tok">:</span>, <span class="tok">::</span> 不作为一般操作符；它们用于其他符号用途。</p>
<p><tt class="docutils literal"><span class="pre">*:</span></tt> 是一个特殊情况，被看作是 <span class="tok">*</span> 和 <span class="tok">:</span> 两个标记(为了支持 <tt class="docutils literal"><span class="pre">var v*: T</span></tt>)。</p>
<p><tt class="docutils literal"><span class="pre">not</span></tt> 关键字是一元操作符， <tt class="docutils literal"><span class="pre">a not b</span></tt> 解析成 <tt class="docutils literal"><span class="pre">a(not b)</span></tt>, 不是 <tt class="docutils literal"><span class="pre">(a) not (b)</span></tt> 。</p>

<h2><a class="toc-backref" id="词法分析-其它标记" href="#词法分析-其它标记">其它标记</a></h2><p>以下字符串表示其他标记:<pre>
`   (    )     {    }     [    ]    ,  ;   [.    .]  {.   .}  (.  .)  [:</pre>
</p>
<p><span id="切片_1">切片</span> 运算符 <span class="tok">..</span> 优先于包含点的其它标记: <span class="tok">{..}</span> 是三个标记 <span class="tok">{</span>, <span class="tok">..</span>, <span class="tok">}</span> 而不是两个标记 <span class="tok">{.</span>, <span class="tok">.}</span> 。</p>

<h1><a class="toc-backref" id="句法" href="#句法">句法</a></h1><p>本节列出了Nim的标准语法。解析器如何处理缩进已在 <a class="reference external" href="#词法分析">词法分析</a> 部分中描述。</p>
<p>Nim允许用户可定义的运算符。二元运算符具有11个不同的优先级。</p>

<h2><a class="toc-backref" id="句法-结合律" href="#句法-结合律">结合律</a></h2><p>第一个字符是 <tt class="docutils literal"><span class="pre">^</span></tt> 的二元运算符是右结合，所有其他二元运算符都是左结合。</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">^/</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">float</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span>
  <span class="Comment"># 右关联除法运算符</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">/</span> <span class="Identifier">y</span>
<span class="Identifier">echo</span> <span class="DecNumber">12</span> <span class="Operator">^/</span> <span class="DecNumber">4</span> <span class="Operator">^/</span> <span class="DecNumber">8</span> <span class="Comment"># 24.0 (4 / 8 = 0.5, then 12 / 0.5 = 24.0)</span>
<span class="Identifier">echo</span> <span class="DecNumber">12</span>  <span class="Operator">/</span> <span class="DecNumber">4</span>  <span class="Operator">/</span> <span class="DecNumber">8</span> <span class="Comment"># 0.375 (12 / 4 = 3.0, then 3 / 8 = 0.375)</span></pre><hr />
<p>一元运算符总是比任何二元运算符优先: <tt class="docutils literal"><span class="pre">$a + b</span></tt> is <tt class="docutils literal"><span class="pre">($a) + b</span></tt> 而不是 <tt class="docutils literal"><span class="pre">$(a + b)</span></tt> 。</p>
<p>如果一元运算符的第一个字符是 <tt class="docutils literal"><span class="pre">@</span></tt> 它是 <span id="符印样_1">符印样</span> 运算符，比 <tt class="docutils literal"><span class="pre">主后缀</span></tt> 优先: <tt class="docutils literal"><span class="pre">@x.abc</span></tt> 解析成 <tt class="docutils literal"><span class="pre">(@x).abc</span></tt> 而 <tt class="docutils literal"><span class="pre">$x.abc</span></tt> 解析成 <tt class="docutils literal"><span class="pre">$(x.abc)</span></tt> 。</p>
<p>对于非关键字的二元运算符，优先级由以下规则确定：</p>
<p>以 <tt class="docutils literal"><span class="pre">-&gt;</span></tt>, <tt class="docutils literal"><span class="pre">~&gt;</span></tt> or <tt class="docutils literal"><span class="pre">=&gt;</span></tt> 结尾的运算符称为 <span id="箭头形_1">箭头形</span>, 优先级最低。</p>
<p>如果操作符以 <tt class="docutils literal"><span class="pre">=</span></tt> 结尾，并且它的第一个字符不是 <tt class="docutils literal"><span class="pre">&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">!</span></tt>, <tt class="docutils literal"><span class="pre">=</span></tt>, <tt class="docutils literal"><span class="pre">~</span></tt>, <tt class="docutils literal"><span class="pre">?</span></tt>, 它是一个 <em>赋值运算符</em> 具有第二低的优先级。</p>
<p>否则优先级由第一个字符决定。</p>
<table border="1" class="docutils"><tr><th>优先级</th><th>运算符</th><th>首字符</th><th>终端符号</th></tr>
<tr><td>10 (highest)</td><td></td><td><tt class="docutils literal"><span class="pre">$ ^</span></tt></td><td>OP10</td></tr>
<tr><td>9</td><td><tt class="docutils literal"><span class="pre">* / div mod shl shr %</span></tt></td><td><tt class="docutils literal"><span class="pre">* % \ /</span></tt></td><td>OP9</td></tr>
<tr><td>8</td><td><tt class="docutils literal"><span class="pre">+ -</span></tt></td><td><tt class="docutils literal"><span class="pre">+ - ~ |</span></tt></td><td>OP8</td></tr>
<tr><td>7</td><td><tt class="docutils literal"><span class="pre">&amp;</span></tt></td><td><tt class="docutils literal"><span class="pre">&amp;</span></tt></td><td>OP7</td></tr>
<tr><td>6</td><td><tt class="docutils literal"><span class="pre">..</span></tt></td><td><tt class="docutils literal"><span class="pre">.</span></tt></td><td>OP6</td></tr>
<tr><td>5</td><td><tt class="docutils literal"><span class="pre">== &lt;= &lt; &gt;= &gt; != in notin is isnot not of</span></tt></td><td><tt class="docutils literal"><span class="pre">= &lt; &gt; !</span></tt></td><td>OP5</td></tr>
<tr><td>4</td><td><tt class="docutils literal"><span class="pre">and</span></tt></td><td></td><td>OP4</td></tr>
<tr><td>3</td><td><tt class="docutils literal"><span class="pre">or xor</span></tt></td><td></td><td>OP3</td></tr>
<tr><td>2</td><td></td><td><tt class="docutils literal"><span class="pre">@ : ?</span></tt></td><td>OP2</td></tr>
<tr><td>1</td><td><em>赋值运算符</em> (like <tt class="docutils literal"><span class="pre">+=</span></tt>, <tt class="docutils literal"><span class="pre">*=</span></tt>)</td><td></td><td>OP1</td></tr>
<tr><td>0 (lowest)</td><td><em>箭头形操作符</em> (like <tt class="docutils literal"><span class="pre">-&gt;</span></tt>, <tt class="docutils literal"><span class="pre">=&gt;</span></tt>)</td><td></td><td>OP0</td></tr>
</table><p>运算符是否使用前缀运算符也受前面的空格影响（此版本的修改随版本0.13.0引入）：</p>
<pre class="listing"><span class="Identifier">echo</span> <span class="Operator">$</span><span class="Identifier">foo</span>
<span class="Comment"># 解析成</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">foo</span><span class="Punctuation">)</span></pre><p>间距还决定了 <tt class="docutils literal"><span class="pre">(a, b)</span></tt> 是否被解析为调用的参数列表，或者它是否被解析为元组构造函数：</p>
<pre class="listing"><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">)</span> <span class="Comment"># 传1和2给echo</span></pre><pre class="listing"><span class="Identifier">echo</span> <span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">)</span> <span class="Comment"># 传元组(1, 2)给echo</span></pre>
<h2><a class="toc-backref" id="句法-语法" href="#句法-语法">语法</a></h2><p>语法的起始符号是 <tt class="docutils literal"><span class="pre">module</span></tt>.</p>
<pre># This file is generated by compiler/parser.nim.
module = stmt ^* (';' / IND{=})
comma = ',' COMMENT?
semicolon = ';' COMMENT?
colon = ':' COMMENT?
colcom = ':' COMMENT?
operator =  OP0 | OP1 | OP2 | OP3 | OP4 | OP5 | OP6 | OP7 | OP8 | OP9
         | 'or' | 'xor' | 'and'
         | 'is' | 'isnot' | 'in' | 'notin' | 'of'
         | 'div' | 'mod' | 'shl' | 'shr' | 'not' | 'static' | '..'
prefixOperator = operator
optInd = COMMENT? IND?
optPar = (IND{&gt;} | IND{=})?
simpleExpr = arrowExpr (OP0 optInd arrowExpr)* pragma?
arrowExpr = assignExpr (OP1 optInd assignExpr)*
assignExpr = orExpr (OP2 optInd orExpr)*
orExpr = andExpr (OP3 optInd andExpr)*
andExpr = cmpExpr (OP4 optInd cmpExpr)*
cmpExpr = sliceExpr (OP5 optInd sliceExpr)*
sliceExpr = ampExpr (OP6 optInd ampExpr)*
ampExpr = plusExpr (OP7 optInd plusExpr)*
plusExpr = mulExpr (OP8 optInd mulExpr)*
mulExpr = dollarExpr (OP9 optInd dollarExpr)*
dollarExpr = primary (OP10 optInd primary)*
symbol = '`' (KEYW|IDENT|literal|(operator|'('|')'|'['|']'|'{'|'}'|'=')+)+ '`'
       | IDENT | KEYW
exprColonEqExpr = expr (':'|'=' expr)?
exprList = expr ^+ comma
exprColonEqExprList = exprColonEqExpr (comma exprColonEqExpr)* (comma)?
dotExpr = expr '.' optInd (symbol | '[:' exprList ']')
explicitGenericInstantiation = '[:' exprList ']' ( '(' exprColonEqExpr ')' )?
qualifiedIdent = symbol ('.' optInd symbol)?
setOrTableConstr = '{' ((exprColonEqExpr comma)* | ':' ) '}'
castExpr = 'cast' '[' optInd typeDesc optPar ']' '(' optInd expr optPar ')'
parKeyw = 'discard' | 'include' | 'if' | 'while' | 'case' | 'try'
        | 'finally' | 'except' | 'for' | 'block' | 'const' | 'let'
        | 'when' | 'var' | 'mixin'
par = '(' optInd
          ( &amp;parKeyw complexOrSimpleStmt ^+ ';'
          | ';' complexOrSimpleStmt ^+ ';'
          | pragmaStmt
          | simpleExpr ( ('=' expr (';' complexOrSimpleStmt ^+ ';' )? )
                       | (':' expr (',' exprColonEqExpr     ^+ ',' )? ) ) )
          optPar ')'
literal = | INT_LIT | INT8_LIT | INT16_LIT | INT32_LIT | INT64_LIT
          | UINT_LIT | UINT8_LIT | UINT16_LIT | UINT32_LIT | UINT64_LIT
          | FLOAT_LIT | FLOAT32_LIT | FLOAT64_LIT
          | STR_LIT | RSTR_LIT | TRIPLESTR_LIT
          | CHAR_LIT
          | NIL
generalizedLit = GENERALIZED_STR_LIT | GENERALIZED_TRIPLESTR_LIT
identOrLiteral = generalizedLit | symbol | literal
               | par | arrayConstr | setOrTableConstr
               | castExpr
tupleConstr = '(' optInd (exprColonEqExpr comma?)* optPar ')'
arrayConstr = '[' optInd (exprColonEqExpr comma?)* optPar ']'
primarySuffix = '(' (exprColonEqExpr comma?)* ')' doBlocks?
      | doBlocks
      | '.' optInd symbol generalizedLit?
      | '[' optInd indexExprList optPar ']'
      | '{' optInd indexExprList optPar '}'
      | &amp;( '`'|IDENT|literal|'cast'|'addr'|'type') expr # command syntax
condExpr = expr colcom expr optInd
        ('elif' expr colcom expr optInd)*
         'else' colcom expr
ifExpr = 'if' condExpr
whenExpr = 'when' condExpr
pragma = '{.' optInd (exprColonExpr comma?)* optPar ('.}' | '}')
identVis = symbol opr?  # postfix position
identVisDot = symbol '.' optInd symbol opr?
identWithPragma = identVis pragma?
identWithPragmaDot = identVisDot pragma?
declColonEquals = identWithPragma (comma identWithPragma)* comma?
                  (':' optInd typeDesc)? ('=' optInd expr)?
identColonEquals = ident (comma ident)* comma?
     (':' optInd typeDesc)? ('=' optInd expr)?)
inlTupleDecl = 'tuple'
    [' optInd  (identColonEquals (comma/semicolon)?)*  optPar ']'
extTupleDecl = 'tuple'
    COMMENT? (IND{&gt;} identColonEquals (IND{=} identColonEquals)*)?
tupleClass = 'tuple'
paramList = '(' declColonEquals ^* (comma/semicolon) ')'
paramListArrow = paramList? ('-&gt;' optInd typeDesc)?
paramListColon = paramList? (':' optInd typeDesc)?
doBlock = 'do' paramListArrow pragmas? colcom stmt
procExpr = 'proc' paramListColon pragmas? ('=' COMMENT? stmt)?
distinct = 'distinct' optInd typeDesc
forStmt = 'for' (identWithPragma ^+ comma) 'in' expr colcom stmt
forExpr = forStmt
expr = (blockExpr
      | ifExpr
      | whenExpr
      | caseExpr
      | forExpr
      | tryExpr)
      / simpleExpr
typeKeyw = 'var' | 'out' | 'ref' | 'ptr' | 'shared' | 'tuple'
         | 'proc' | 'iterator' | 'distinct' | 'object' | 'enum'
primary = typeKeyw typeDescK
        /  prefixOperator* identOrLiteral primarySuffix*
        / 'bind' primary
typeDesc = simpleExpr
typeDefAux = simpleExpr
           | 'concept' typeClass
postExprBlocks = ':' stmt? ( IND{=} doBlock
                           | IND{=} 'of' exprList ':' stmt
                           | IND{=} 'elif' expr ':' stmt
                           | IND{=} 'except' exprList ':' stmt
                           | IND{=} 'else' ':' stmt )*
exprStmt = simpleExpr
         (( '=' optInd expr colonBody? )
         / ( expr ^+ comma
             doBlocks
              / macroColon
           ))?
importStmt = 'import' optInd expr
              ((comma expr)*
              / 'except' optInd (expr ^+ comma))
includeStmt = 'include' optInd expr ^+ comma
fromStmt = 'from' moduleName 'import' optInd expr (comma expr)*
returnStmt = 'return' optInd expr?
raiseStmt = 'raise' optInd expr?
yieldStmt = 'yield' optInd expr?
discardStmt = 'discard' optInd expr?
breakStmt = 'break' optInd expr?
continueStmt = 'break' optInd expr?
condStmt = expr colcom stmt COMMENT?
           (IND{=} 'elif' expr colcom stmt)*
           (IND{=} 'else' colcom stmt)?
ifStmt = 'if' condStmt
whenStmt = 'when' condStmt
whileStmt = 'while' expr colcom stmt
ofBranch = 'of' exprList colcom stmt
ofBranches = ofBranch (IND{=} ofBranch)*
                      (IND{=} 'elif' expr colcom stmt)*
                      (IND{=} 'else' colcom stmt)?
caseStmt = 'case' expr ':'? COMMENT?
            (IND{&gt;} ofBranches DED
            | IND{=} ofBranches)
tryStmt = 'try' colcom stmt &amp;(IND{=}? 'except'|'finally')
           (IND{=}? 'except' exprList colcom stmt)*
           (IND{=}? 'finally' colcom stmt)?
tryExpr = 'try' colcom stmt &amp;(optInd 'except'|'finally')
           (optInd 'except' exprList colcom stmt)*
           (optInd 'finally' colcom stmt)?
exceptBlock = 'except' colcom stmt
blockStmt = 'block' symbol? colcom stmt
blockExpr = 'block' symbol? colcom stmt
staticStmt = 'static' colcom stmt
deferStmt = 'defer' colcom stmt
asmStmt = 'asm' pragma? (STR_LIT | RSTR_LIT | TRIPLESTR_LIT)
genericParam = symbol (comma symbol)* (colon expr)? ('=' optInd expr)?
genericParamList = '[' optInd
  genericParam ^* (comma/semicolon) optPar ']'
pattern = '{' stmt '}'
indAndComment = (IND{&gt;} COMMENT)? | COMMENT?
routine = optInd identVis pattern? genericParamList?
  paramListColon pragma? ('=' COMMENT? stmt)? indAndComment
commentStmt = COMMENT
section(p) = COMMENT? p / (IND{&gt;} (p / COMMENT)^+IND{=} DED)
constant = identWithPragma (colon typeDesc)? '=' optInd expr indAndComment
enum = 'enum' optInd (symbol optInd ('=' optInd expr COMMENT?)? comma?)+
objectWhen = 'when' expr colcom objectPart COMMENT?
            ('elif' expr colcom objectPart COMMENT?)*
            ('else' colcom objectPart COMMENT?)?
objectBranch = 'of' exprList colcom objectPart
objectBranches = objectBranch (IND{=} objectBranch)*
                      (IND{=} 'elif' expr colcom objectPart)*
                      (IND{=} 'else' colcom objectPart)?
objectCase = 'case' identWithPragma ':' typeDesc ':'? COMMENT?
            (IND{&gt;} objectBranches DED
            | IND{=} objectBranches)
objectPart = IND{&gt;} objectPart^+IND{=} DED
           / objectWhen / objectCase / 'nil' / 'discard' / declColonEquals
object = 'object' pragma? ('of' typeDesc)? COMMENT? objectPart
typeClassParam = ('var' | 'out')? symbol
typeClass = typeClassParam ^* ',' (pragma)? ('of' typeDesc ^* ',')?
              &amp;IND{&gt;} stmt
typeDef = identWithPragmaDot genericParamList? '=' optInd typeDefAux
            indAndComment?
varTuple = '(' optInd identWithPragma ^+ comma optPar ')' '=' optInd expr
colonBody = colcom stmt doBlocks?
variable = (varTuple / identColonEquals) colonBody? indAndComment
bindStmt = 'bind' optInd qualifiedIdent ^+ comma
mixinStmt = 'mixin' optInd qualifiedIdent ^+ comma
pragmaStmt = pragma (':' COMMENT? stmt)?
simpleStmt = ((returnStmt | raiseStmt | yieldStmt | discardStmt | breakStmt
           | continueStmt | pragmaStmt | importStmt | exportStmt | fromStmt
           | includeStmt | commentStmt) / exprStmt) COMMENT?
complexOrSimpleStmt = (ifStmt | whenStmt | whileStmt
                    | tryStmt | forStmt
                    | blockStmt | staticStmt | deferStmt | asmStmt
                    | 'proc' routine
                    | 'method' routine
                    | 'iterator' routine
                    | 'macro' routine
                    | 'template' routine
                    | 'converter' routine
                    | 'type' section(typeDef)
                    | 'const' section(constant)
                    | ('let' | 'var' | 'using') section(variable)
                    | bindStmt | mixinStmt)
                    / simpleStmt
stmt = (IND{&gt;} complexOrSimpleStmt^+(IND{=} / ';') DED)
     / simpleStmt ^+ ';'
</pre>

<h1><a class="toc-backref" id="求值顺序" href="#求值顺序">求值顺序</a></h1><p>求值顺序是从左到右、从内到外，和大多数其他典型的命令式编程语言一样：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Operator">$</span><span class="Identifier">arg</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">arg</span>

<span class="Keyword">discard</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Identifier">doAssert</span> <span class="Identifier">s</span> <span class="Operator">==</span> <span class="StringLit">&quot;123&quot;</span></pre><p>赋值也不例外，左侧表达式在右侧之前进行求值：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">v</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Keyword">proc</span> <span class="Identifier">getI</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">v</span>
  <span class="Identifier">inc</span> <span class="Identifier">v</span>

<span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">someCopy</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">b</span>

<span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">getI</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">getI</span><span class="Punctuation">(</span><span class="Punctuation">)</span>

<span class="Identifier">doAssert</span> <span class="Identifier">a</span> <span class="Operator">==</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">]</span>

<span class="Identifier">v</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Identifier">someCopy</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">[</span><span class="Identifier">getI</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">getI</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Identifier">doAssert</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">]</span></pre><p>基本原理：与重载赋值或赋值类操作的一致性 <tt class="docutils literal"><span class="pre">a = b</span></tt> 可以读作 <tt class="docutils literal"><span class="pre">performSomeCopy(a, b)</span></tt>.</p>

<h1><a class="toc-backref" id="常量和常量表达式" href="#常量和常量表达式">常量和常量表达式</a></h1><p><span id="常量_1">常量</span> 是一个与常量表达式值绑定的符号。 常量表达式仅限于依赖于以下类别的值和操作，因为它们要么构建在语言中，要么在对常量表达式进行语义分析之前进行声明和求值：</p>
<ul class="simple"><li>字面值</li>
<li>内置运算符</li>
<li>之前声明的常量和编译时变量</li>
<li>之前声明过的宏和模板</li>
<li>之前声明的过程除了可能修改编译时变量之外没有任何副作用</li>
</ul>
<p>常量表达式可以包含可以在内部使用编译时支持的所有Nim功能的代码块（详见下一节）。 在这样的代码块中，可以声明变量然后稍后读取和更新它们，或者声明变量并将它们传递给修改它们的过程。 但是，此类块中的代码仍必须遵循上面列出的用于引用块外部的值和操作的限制。</p>
<p>访问和修改编译时变量的能力增加了常量表达式的灵活性。 例如，下面的代码在 <strong>编译时</strong> 打印Fibonacci数列的开头。 （这是对定义常量的灵活性的证明，而不是解决此问题的推荐样式。）</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">strformat</span>

<span class="Keyword">var</span> <span class="Identifier">fib_n</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compileTime</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Keyword">var</span> <span class="Identifier">fib_prev</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compileTime</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Keyword">var</span> <span class="Identifier">fib_prev_prev</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compileTime</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Identifier">next_fib</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">fib_n</span> <span class="Operator">&lt;</span> <span class="DecNumber">2</span><span class="Punctuation">:</span>
    <span class="Identifier">fib_n</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">fib_prev_prev</span> <span class="Operator">+</span> <span class="Identifier">fib_prev</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">fib_n</span><span class="Punctuation">)</span>
  <span class="Identifier">fib_prev_prev</span> <span class="Operator">=</span> <span class="Identifier">fib_prev</span>
  <span class="Identifier">fib_prev</span> <span class="Operator">=</span> <span class="Identifier">result</span>

<span class="Keyword">const</span> <span class="Identifier">f0</span> <span class="Operator">=</span> <span class="Identifier">next_fib</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">const</span> <span class="Identifier">f1</span> <span class="Operator">=</span> <span class="Identifier">next_fib</span><span class="Punctuation">(</span><span class="Punctuation">)</span>

<span class="Keyword">const</span> <span class="Identifier">display_fib</span> <span class="Operator">=</span> <span class="Keyword">block</span><span class="Punctuation">:</span>
  <span class="Keyword">const</span> <span class="Identifier">f2</span> <span class="Operator">=</span> <span class="Identifier">next_fib</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="RawData">fmt&quot;Fibonacci sequence: {f0}, {f1}, {f2}&quot;</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">3.</span><span class="Operator">.</span><span class="DecNumber">12</span><span class="Punctuation">:</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="RawData">fmt&quot;, {next_fib()}&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span>

<span class="Keyword">static</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">display_fib</span></pre>
<h1><a class="toc-backref" id="编译期执行限制" href="#编译期执行限制">编译期执行限制</a></h1><p>将在编译时执行的Nim代码不能使用以下语言功能：</p>
<ul class="simple"><li>方法</li>
<li>闭包迭代器</li>
<li><tt class="docutils literal"><span class="pre">cast</span></tt> 运算符</li>
<li>引用(指针)类型</li>
<li>外部函数接口（FFI）</li>
</ul>
<p>随着时间的推移，部分或全部这些限制可能会被取消。</p>

<h1><a class="toc-backref" id="类型" href="#类型">类型</a></h1><p>所有表达式都具有在语义分析期间已知的类型。 Nim是静态类型的。可以声明新类型，这实际上定义了可用于表示此自定义类型的标识符。</p>
<p>这些是主要的类型：</p>
<ul class="simple"><li>序数类型（由整数，bool，字符，枚举（及其子范围）类型组成）</li>
<li>浮点类型</li>
<li>字符串类型</li>
<li>结构化类型</li>
<li>引用 (指针)类型</li>
<li>过程类型</li>
<li>泛型类型</li>
</ul>

<h2><a class="toc-backref" id="类型-序数类型" href="#类型-序数类型">序数类型</a></h2><p>序数类型有以下特征：</p>
<ul class="simple"><li>序数类型是可数和有序的。该属性允许定义函数的操作 <tt class="docutils literal"><span class="pre">inc</span></tt>, <tt class="docutils literal"><span class="pre">ord</span></tt>, <tt class="docutils literal"><span class="pre">dec</span></tt> 。</li>
<li>序数值具有最小可能值。尝试进一步向下计数低于最小值会产生已检查的运行时或静态错误。</li>
<li>序数值具有最大可能值。尝试计数超过最大值会产生已检查的运行时或静态错误。</li>
</ul>
<p>整数，bool，字符和枚举类型（以及这些类型的子范围）属于序数类型。 出于简化实现的原因，类型 <tt class="docutils literal"><span class="pre">uint</span></tt> 和 <tt class="docutils literal"><span class="pre">uint64</span></tt> 不是序数类型。 （这将在该语言的更高版本中更改。）</p>
<p>如果基类型是序数类型，则不同类型是序数类型。</p>

<h2><a class="toc-backref" id="类型-预定义整数类型" href="#类型-预定义整数类型">预定义整数类型</a></h2><p>这些整数类型是预定义的：</p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">int</span></tt></dt>
<dd>通用有符号整数类型;它的大小取决于平台，并且与指针大小相同。 一般应该使用这种类型。 没有类型后缀的整数字面值是这种类型，如果它在 <tt class="docutils literal"><span class="pre">low(int32)... high(int32)</span></tt> 范围内，否则字面值的类型是 <tt class="docutils literal"><span class="pre">int64</span></tt> 。</dd>
<dt>intXX</dt>
<dd>附加的有符号整数类型的XX位使用此命名方案（例如：int16是16位宽整数）。 当前的实现支持 <tt class="docutils literal"><span class="pre">int8</span></tt>, <tt class="docutils literal"><span class="pre">int16</span></tt>, <tt class="docutils literal"><span class="pre">int32</span></tt>, <tt class="docutils literal"><span class="pre">int64</span></tt> 。 这些类型的字面值后缀为'iXX。</dd>
<dt><tt class="docutils literal"><span class="pre">uint</span></tt></dt>
<dd>通用的 <span id="无符号整型_1">无符号整型</span> ; 它的大小取决于平台，并且与指针大小相同。 类型后缀为 <tt class="docutils literal"><span class="pre">'u</span></tt> 的整数字面值就是这种类型。</dd>
<dt>uintXX</dt>
<dd>附加的无符号整数类型的XX位使用此命名方案（例如：uint16是16位宽的无符号整数）。 当前的实现支持 <tt class="docutils literal"><span class="pre">uint8</span></tt>, <tt class="docutils literal"><span class="pre">uint16</span></tt>, <tt class="docutils literal"><span class="pre">uint32</span></tt>, <tt class="docutils literal"><span class="pre">uint64</span></tt> 。 这些类型的字面值具有后缀 'uXX 。 无符号操作被全面封装; 不会导致上溢或下溢。</dd>
</dl>
<p>除了有符号和无符号整数的常用算术运算符 (<tt class="docutils literal"><span class="pre">+ - *</span></tt> etc.) 之外，还有一些运算符正式处理 <em>整型</em> 整数但将它们的参数视为 <em>无符号</em>: 它们主要用于向后与缺少无符号整数类型的旧版本语言的兼容性。 有符号整数的这些无符号运算使用 <tt class="docutils literal"><span class="pre">%</span></tt> 后缀作为约定：</p>
<table border="1" class="docutils"><tr><th>操作符</th><th>含义</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">a +% b</span></tt></td><td>无符号整型加法</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a -% b</span></tt></td><td>无符号整型减法</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a *% b</span></tt></td><td>无符号整型乘法</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a /% b</span></tt></td><td>无符号整型除法</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a %% b</span></tt></td><td>无符号整型取模</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a &lt;% b</span></tt></td><td>无符号比较 <tt class="docutils literal"><span class="pre">a</span></tt> 和 <tt class="docutils literal"><span class="pre">b</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a &lt;=% b</span></tt></td><td>无符号比较 <tt class="docutils literal"><span class="pre">a</span></tt> 和 <tt class="docutils literal"><span class="pre">b</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">ze(a)</span></tt></td><td>用零填充 <tt class="docutils literal"><span class="pre">a</span></tt> 的位，直到它具有 <tt class="docutils literal"><span class="pre">int</span></tt> 类型的宽度</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">toU8(a)</span></tt></td><td>8位无符号转换 <tt class="docutils literal"><span class="pre">a</span></tt>  (仍然是 <tt class="docutils literal"><span class="pre">int8</span></tt> 类型)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">toU16(a)</span></tt></td><td>16位无符号转换 <tt class="docutils literal"><span class="pre">a</span></tt>  (仍然是 <tt class="docutils literal"><span class="pre">int16</span></tt> 类型)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">toU32(a)</span></tt></td><td>32位无符号转换 <tt class="docutils literal"><span class="pre">a</span></tt>  (仍然是 <tt class="docutils literal"><span class="pre">int32</span></tt> 类型)</td></tr>
</table><p><span id="自动类型转换_1">自动类型转换</span> 在使用不同类型的整数类型的表达式中执行：较小的类型转换为较大的类型。</p>
<p><span id="缩小类型转换_1">缩小类型转换</span> 将较大的类型转换为较小的类型（例如 <tt class="docutils literal"><span class="pre">int32 - &gt; int16</span></tt> 。 <span id="扩展类型转换_1">扩展类型转换</span> 将较小的类型转换为较大的类型（例如 <tt class="docutils literal"><span class="pre">int16 - &gt; int32</span></tt> ）。 Nim中只有扩展类型转型是 <em>隐式的</em>:</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">myInt16</span> <span class="Operator">=</span> <span class="DecNumber">5</span><span class="Identifier">i16</span>
<span class="Keyword">var</span> <span class="Identifier">myInt</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Identifier">myInt16</span> <span class="Operator">+</span> <span class="DecNumber">34</span>     <span class="Comment"># of type ``int16``</span>
<span class="Identifier">myInt16</span> <span class="Operator">+</span> <span class="Identifier">myInt</span>  <span class="Comment"># of type ``int``</span>
<span class="Identifier">myInt16</span> <span class="Operator">+</span> <span class="DecNumber">2</span><span class="Identifier">i32</span>   <span class="Comment"># of type ``int32``</span></pre><p>但是，如果字面值适合这个较小的类型并且这样的转换比其他隐式转换便宜，则 <tt class="docutils literal"><span class="pre">int</span></tt> 字面值可以隐式转换为较小的整数类型，因此 <tt class="docutils literal"><span class="pre">myInt16 + 34</span></tt> 产生 <tt class="docutils literal"><span class="pre">int16</span></tt> 结果。</p>
<p>有关详细信息，请参阅 <a class="reference external" href="#type-relations-convertible-relation">可转换关系</a> 。</p>

<h2><a class="toc-backref" id="类型-子范围类型" href="#类型-子范围类型">子范围类型</a></h2><p>子范围类型是序数或浮点类型（基本类型）的值范围。</p>
<p>要定义子范围类型，必须指定其限制值 - 类型的最低值和最高值。例如：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Subrange</span> <span class="Operator">=</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">]</span>
  <span class="Identifier">PositiveFloat</span> <span class="Operator">=</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.0</span><span class="Operator">..</span><span class="Identifier">Inf</span><span class="Punctuation">]</span></pre><p><tt class="docutils literal"><span class="pre">Subrange</span></tt> 是整数的子范围，只能保存0到5的值。 <tt class="docutils literal"><span class="pre">PositiveFloat</span></tt> 定义所有正浮点值的子范围。 NaN不属于任何浮点类型的子范围。 将任何其他值分配给类型为 <tt class="docutils literal"><span class="pre">Subrange</span></tt> 的变量是检查的运行时错误（如果可以在语义分析期间确定，则为静态错误）。 允许从基本类型到其子类型之一（反之亦然）的分配。</p>
<p>子范围类型与其基类型具有相同的大小（子范围示例中的 <tt class="docutils literal"><span class="pre">int</span></tt> ）。</p>

<h2><a class="toc-backref" id="类型-预定义浮点类型" href="#类型-预定义浮点类型">预定义浮点类型</a></h2><p>以下浮点类型是预定义的：</p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">float</span></tt></dt>
<dd>通用浮点类型;它的大小曾经是平台相关的，但现在它总是映射到 <tt class="docutils literal"><span class="pre">float64</span></tt> 。一般应该使用这种类型。</dd>
<dt>floatXX</dt>
<dd>实现可以使用此命名方案定义XX位的其他浮点类型（例如：float64是64位宽的浮点数）。 当前的实现支持 <tt class="docutils literal"><span class="pre">float32</span></tt> 和 <tt class="docutils literal"><span class="pre">float64</span></tt> 。 这些类型的字面值具有后缀 'fXX 。</dd>
</dl>
<p>执行具有不同类型浮点类型的表达式中的自动类型转换：有关更多详细信息，请参阅 <tt class="docutils literal"><span class="pre">可转换关系</span></tt> 。 在浮点类型上执行的算术遵循IEEE标准。 整数类型不会自动转换为浮点类型，反之亦然。</p>
<p>IEEE标准定义了五种类型的浮点异常：</p>
<ul class="simple"><li>无效: 使用数学上无效的操作数的操作, 例如 0.0/0.0, sqrt(-1.0), 和log(-37.8).</li>
<li>除以零：除数为零，且除数是有限的非零数，例如1.0 / 0.0。</li>
<li>溢出：操作产生的结果超出指数范围，例如MAXDOUBLE + 0.0000000000001e308。</li>
<li>下溢：操作产生的结果太小而无法表示为正常数字，例如，MINDOUBLE * MINDOUBLE。</li>
<li>不精确：操作产生的结果无法用无限精度表示，例如，输入中的2.0 / 3.0，log（1.1）和0.1。</li>
</ul>
<p>IEEE异常在执行期间被忽略或映射到Nim异常: <span id="floatinvalidoperror_1">FloatInvalidOpError</span>, <span id="floatdivbyzeroerror_1">FloatDivByZeroError</span>, <span id="floatoverflowerror_1">FloatOverflowError</span>, <span id="floatunderflowerror_1">FloatUnderflowError</span>, 和 <span id="floatinexacterror_1">FloatInexactError</span> 。 这些异常继承自 <span id="floatingpointerror_1">FloatingPointError</span> 基类。</p>
<p>Nim提供了编译指示 <span id="nanchecks_1">nanChecks</span> 和 <span id="infchecks_1">infChecks</span> 控制是否忽略IEEE异常或捕获Nim异常：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">nanChecks</span><span class="Punctuation">:</span> <span class="Identifier">on</span><span class="Punctuation">,</span> <span class="Identifier">infChecks</span><span class="Punctuation">:</span> <span class="Identifier">on</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="FloatNumber">1.0</span>
<span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="FloatNumber">0.0</span>
<span class="Identifier">echo</span> <span class="Identifier">b</span> <span class="Operator">/</span> <span class="Identifier">b</span> <span class="Comment"># raises FloatInvalidOpError</span>
<span class="Identifier">echo</span> <span class="Identifier">a</span> <span class="Operator">/</span> <span class="Identifier">b</span> <span class="Comment"># raises FloatOverflowError</span></pre><p>在当前的实现中， <tt class="docutils literal"><span class="pre">FloatDivByZeroError</span></tt> 和 <tt class="docutils literal"><span class="pre">FloatInexactError</span></tt> 永远不会被引发。 <tt class="docutils literal"><span class="pre">FloatOverflowError</span></tt> 取代了 <tt class="docutils literal"><span class="pre">FloatDivByZeroError</span></tt> 。 还有一个 <span id="floatchecks_1">floatChecks</span> 编译指示用作 <tt class="docutils literal"><span class="pre">nanChecks</span></tt> 和 <tt class="docutils literal"><span class="pre">infChecks</span></tt> 的快捷方式。 <tt class="docutils literal"><span class="pre">floatChecks</span></tt> 默认关闭。</p>
<p>受 <tt class="docutils literal"><span class="pre">floatChecks</span></tt> 编译指示影响的唯一操作是浮点类型的 <tt class="docutils literal"><span class="pre">+</span></tt> ， <tt class="docutils literal"><span class="pre">-</span></tt> ， <tt class="docutils literal"><span class="pre">*</span></tt> ， <tt class="docutils literal"><span class="pre">/</span></tt> 运算符。</p>
<p>在语义分析期间，实现应始终使用最大精度来评估浮点指针值; 这表示在常量展开期间，表达式 <tt class="docutils literal"><span class="pre">0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64</span></tt> 求值为真。</p>

<h2><a class="toc-backref" id="类型-布尔类型" href="#类型-布尔类型">布尔类型</a></h2><p>布尔类型在Nim中命名为 <span id="bool_1">bool</span> 并且可以是两个预定义值之一 <tt class="docutils literal"><span class="pre">true</span></tt> 和 <tt class="docutils literal"><span class="pre">false</span></tt> 。 <tt class="docutils literal"><span class="pre">while</span></tt>, <tt class="docutils literal"><span class="pre">if</span></tt>, <tt class="docutils literal"><span class="pre">elif</span></tt>, <tt class="docutils literal"><span class="pre">when</span></tt> 中的语句需要是 <tt class="docutils literal"><span class="pre">bool</span></tt> 类型。</p>
<p>这种情况成立:<pre>
ord(false) == 0 and ord(true) == 1</pre>
</p>
<p>布尔类型定义了运算符 <tt class="docutils literal"><span class="pre">not, and, or, xor, &lt;, &lt;=, &gt;, &gt;=, !=, ==</span></tt> 。 <tt class="docutils literal"><span class="pre">and</span></tt> 和 <tt class="docutils literal"><span class="pre">or</span></tt> 运算符执行短路求值。示例:</p>
<pre class="listing"><span class="Keyword">while</span> <span class="Identifier">p</span> <span class="Operator">!=</span> <span class="Keyword">nil</span> <span class="Keyword">and</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Operator">!=</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">:</span>
  <span class="Comment"># 如果 p == nil， p.name不被求值。</span>
  <span class="Identifier">p</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">next</span></pre><p>bool类型的大小是一个字节。</p>

<h2><a class="toc-backref" id="类型-字符类型" href="#类型-字符类型">字符类型</a></h2><p>字符类型在Nim中被命名为 <tt class="docutils literal"><span class="pre">char</span></tt> 。它的大小是一字节。 因此，它不能代表UTF-8字符，而是它的一部分。 这样做是出于效率：对于绝大多数用例，由于UTF-8是专门为此设计的，所得到的程序仍然可以正确处理UTF-8。 另一个原因是Nim可以有效地支持 <tt class="docutils literal"><span class="pre">array[char,int]</span></tt> 或 <tt class="docutils literal"><span class="pre">set[char]</span></tt> ，因为许多算法依赖于这个特性。 <tt class="docutils literal"><span class="pre">Rune</span></tt> 类型用于Unicode字符，它可以表示任何Unicode字符。 <tt class="docutils literal"><span class="pre">Rune</span></tt> 在 <a class="reference external" href="unicode.html">unicode module</a> 中声明。</p>

<h2><a class="toc-backref" id="类型-枚举类型" href="#类型-枚举类型">枚举类型</a></h2><p>枚举类型定义一个新类型，其值由指定的值组成。这些值是有序的。例：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Direction</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">north</span><span class="Punctuation">,</span> <span class="Identifier">east</span><span class="Punctuation">,</span> <span class="Identifier">south</span><span class="Punctuation">,</span> <span class="Identifier">west</span></pre><p>现在以下内容成立:<pre>
ord(north) == 0
ord(east) == 1
ord(south) == 2
ord(west) == 3

# 也允许:
ord(Direction.west) == 3</pre>
</p>
<p>因此, north &lt; east &lt; south &lt; west 。 比较运算符可以与枚举类型一起使用。 枚举值也可以使用它所在的枚举类型 <tt class="docutils literal"><span class="pre">Direction.nort</span></tt> 来限定，而不是 <tt class="docutils literal"><span class="pre">north</span></tt> 等。</p>
<p>为了更好地与其他编程语言连接，可以为枚举类型的字段分配显式序数值。 但是，序数值必须按升序排列。 未明确给出序数值的字段被赋予前一个字段+ 1的值。</p>
<p>显式有序枚举可以有 <em>洞</em> ：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">TokenType</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="DecNumber">89</span> <span class="Comment"># 洞是合法的</span></pre><p>但是，它不再是序数，因此不可能将这些枚举用作数组的索引类型。 过程 <tt class="docutils literal"><span class="pre">inc</span></tt>, <tt class="docutils literal"><span class="pre">dec</span></tt>, <tt class="docutils literal"><span class="pre">succ</span></tt> 和 <tt class="docutils literal"><span class="pre">pred</span></tt> 对于它们不可用。</p>
<p>编译器支持枚举的内置字符串化运算符 <tt class="docutils literal"><span class="pre">$</span></tt> 。 字符串化的结果可以通过显式给出要使用的字符串值来控制：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valueA</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="StringLit">&quot;my value A&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
    <span class="Identifier">valueB</span> <span class="Operator">=</span> <span class="StringLit">&quot;value B&quot;</span><span class="Punctuation">,</span>
    <span class="Identifier">valueC</span> <span class="Operator">=</span> <span class="DecNumber">2</span><span class="Punctuation">,</span>
    <span class="Identifier">valueD</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">)</span></pre><p>从示例中可以看出，可以通过使用元组指定字段的序数值及其字符串值。 也可以只指定其中一个。</p>
<p>枚举可以使用 <tt class="docutils literal"><span class="pre">pure</span></tt> 编译指示进行标记，以便将其字段添加到特定模块特定的隐藏作用域，该作用域仅作为最后一次尝试进行查询。 只有没有歧义的符号才会添加到此范围。 但总是可以通过写为 <tt class="docutils literal"><span class="pre">MyEnum.value</span></tt> 的类型限定来访问:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valueA</span><span class="Punctuation">,</span> <span class="Identifier">valueB</span><span class="Punctuation">,</span> <span class="Identifier">valueC</span><span class="Punctuation">,</span> <span class="Identifier">valueD</span><span class="Punctuation">,</span> <span class="Identifier">amb</span>
  
  <span class="Identifier">OtherEnum</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valueX</span><span class="Punctuation">,</span> <span class="Identifier">valueY</span><span class="Punctuation">,</span> <span class="Identifier">valueZ</span><span class="Punctuation">,</span> <span class="Identifier">amb</span>


<span class="Identifier">echo</span> <span class="Identifier">valueA</span> <span class="Comment"># MyEnum.valueA</span>
<span class="Identifier">echo</span> <span class="Identifier">amb</span>    <span class="Comment"># 错误：不清楚它是MyEnum.amb还是OtherEnum.amb</span>
<span class="Identifier">echo</span> <span class="Identifier">MyEnum</span><span class="Operator">.</span><span class="Identifier">amb</span> <span class="Comment"># OK.</span></pre><p>要使用枚举实现位字段，请参阅 <a class="reference external" href="#set-type-bit-fields">Bit fields</a></p>

<h2><a class="toc-backref" id="类型-字符串类型" href="#类型-字符串类型">字符串类型</a></h2><p>所有字符串字面值都是 <tt class="docutils literal"><span class="pre">string</span></tt> 类型。 Nim中的字符串与字符序列非常相似。 但是，Nim中的字符串都是以零结尾的并且具有长度字段。 可以用内置的 <tt class="docutils literal"><span class="pre">len</span></tt> 过程检索长度;长度永远不会计算终止零。</p>
<p>除非首先将字符串转换为 <tt class="docutils literal"><span class="pre">cstring</span></tt> 类型，否则无法访问终止零。 终止零确保可以在O(1)中完成此转换，无需任何分配。</p>
<p>字符串的赋值运算符始终复制字符串。 <tt class="docutils literal"><span class="pre">&amp;</span></tt> 运算符拼接字符串。</p>
<p>大多数原生Nim类型支持使用特殊的 <tt class="docutils literal"><span class="pre">$</span></tt> proc转换为字符串。</p>
<p>例如，当调用 <tt class="docutils literal"><span class="pre">echo</span></tt> proc时，会调用参数的内置字符串化操作：</p>
<pre class="listing"><span class="Identifier">echo</span> <span class="DecNumber">3</span> <span class="Comment"># 为 `int` 调用 `$`</span></pre><p>每当用户创建一个专门的对象时，该过程的实现提供了 <tt class="docutils literal"><span class="pre">string</span></tt> 表示。</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">:</span> <span class="Identifier">Person</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Comment"># `$` 始终返回字符串</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot; is &quot;</span> <span class="Operator">&amp;</span>
          <span class="Operator">$</span><span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">age</span> <span class="Operator">&amp;</span> <span class="Comment"># we *need* the `$` in front of p.age which</span>
                   <span class="Comment"># is natively an integer to convert it to</span>
                   <span class="Comment"># a string</span>
          <span class="StringLit">&quot; years old.&quot;</span></pre><p>虽然也可以使用 <tt class="docutils literal"><span class="pre">$ p.name</span></tt> ，但字符串上的 <tt class="docutils literal"><span class="pre">$</span></tt> 操作什么都不做。 请注意，我们不能依赖于从 <tt class="docutils literal"><span class="pre">int</span></tt> 到 <tt class="docutils literal"><span class="pre">string</span></tt> 的自动转换，就像 <tt class="docutils literal"><span class="pre">echo</span></tt> 过程一样。</p>
<p>字符串按字典顺序进行比较。 所有比较运算符都可用。 字符串可以像数组一样索引（下限为0）。 与数组不同，它们可用于case语句：</p>
<pre class="listing"><span class="Keyword">case</span> <span class="Identifier">paramStr</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;-v&quot;</span><span class="Punctuation">:</span> <span class="Identifier">incl</span><span class="Punctuation">(</span><span class="Identifier">options</span><span class="Punctuation">,</span> <span class="Identifier">optVerbose</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;-h&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;-?&quot;</span><span class="Punctuation">:</span> <span class="Identifier">incl</span><span class="Punctuation">(</span><span class="Identifier">options</span><span class="Punctuation">,</span> <span class="Identifier">optHelp</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;invalid command line option!</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span></pre><p>按照惯例，所有字符串都是UTF-8字符串，但不强制执行。 例如，从二进制文件读取字符串时，它们只是一个字节序列。 索引操作 <tt class="docutils literal"><span class="pre">s[i]</span></tt> 表示 <tt class="docutils literal"><span class="pre">s</span></tt> 的第i个 <em>char</em> ，而不是第i个 <em>unichar</em> 。 来自 <a class="reference external" href="unicode.html">unicode module</a> 的迭代器 <tt class="docutils literal"><span class="pre">runes</span></tt> 可用于迭代所有Unicode字符。</p>

<h2><a class="toc-backref" id="类型-cstring类型" href="#类型-cstring类型">cstring类型</a></h2><p><tt class="docutils literal"><span class="pre">cstring</span></tt> 类型意味着 <tt class="docutils literal"><span class="pre">compatible string</span></tt> 是编译后端的字符串的原生表示。 对于C后端，``cstring`` 类型表示一个指向零终止char数组的指针，该数组与Ansi C中的 <tt class="docutils literal"><span class="pre">char*</span></tt> 类型兼容。 其主要目的在于与C轻松互通。 索引操作 <tt class="docutils literal"><span class="pre">s [i]</span></tt> 表示 <tt class="docutils literal"><span class="pre">s</span></tt> 的第i个 <em>char</em>;但是没有执行检查 <tt class="docutils literal"><span class="pre">cstring</span></tt> 的边界，使索引操作不安全。</p>
<p>为方便起见，Nim中的 <tt class="docutils literal"><span class="pre">string</span></tt> 可以隐式转换为 <tt class="docutils literal"><span class="pre">cstring</span></tt> 。 如果将Nim字符串传递给C风格的可变参数proc，它也会隐式转换为 <tt class="docutils literal"><span class="pre">cstring</span></tt> ：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">printf</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;printf&quot;</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Punctuation">,</span>
                                  <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;stdio.h&gt;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Identifier">printf</span><span class="Punctuation">(</span><span class="StringLit">&quot;This works %s&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;as expected&quot;</span><span class="Punctuation">)</span></pre><p>即使转换是隐式的，它也不是 <em>安全的</em> ：垃圾收集器不认为 <tt class="docutils literal"><span class="pre">cstring</span></tt> 是根，并且可能收集底层内存。 然而在实践中，这几乎从未发生过，因为GC保守地估计堆栈根。 可以使用内置过程 <tt class="docutils literal"><span class="pre">GC_ref</span></tt> 和 <tt class="docutils literal"><span class="pre">GC_unref</span></tt> 来保持字符串数据在少数情况下保持活动状态。</p>
<p>为返回字符串的cstrings定义了 <tt class="docutils literal"><span class="pre">$</span></tt> proc。因此，从cstring获取一个nim字符串：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">str</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;Hello!&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">cstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span> <span class="Operator">=</span> <span class="Identifier">str</span>
<span class="Keyword">var</span> <span class="Identifier">newstr</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">cstr</span></pre>
<h2><a class="toc-backref" id="类型-结构化类型" href="#类型-结构化类型">结构化类型</a></h2><p>结构化类型的变量可以同时保存多个值。 结构化类型可以嵌套到无限级别。 数组、序列、元组、对象和集合属于结构化类型。</p>

<h2><a class="toc-backref" id="类型-数组和序列类型" href="#类型-数组和序列类型">数组和序列类型</a></h2><p>数组是同类型的，这意味着数组中的每个元素都具有相同的类型。 数组总是具有指定为常量表达式的固定长度（开放数组除外）。 它们可以按任何序数类型索引。 参数 <tt class="docutils literal"><span class="pre">A</span></tt> 可以是 <em>开放数组</em> ，在这种情况下，它由0到 <tt class="docutils literal"><span class="pre">len（A）- 1</span></tt> 的整数索引。 数组表达式可以由数组构造函数 <tt class="docutils literal"><span class="pre">[]</span></tt> 构造。 数组表达式的元素类型是从第一个元素的类型推断出来的。 所有其他元素都需要隐式转换为此类型。</p>
<p>序列类似于数组，但动态长度可能在运行时期间发生变化（如字符串）。 序列实现为可增长的数组，在添加项目时分配内存块。 序列 <tt class="docutils literal"><span class="pre">S</span></tt> 始终用从0到 <tt class="docutils literal"><span class="pre">len(S)-1</span></tt> 的整数索引，并检查其边界。 序列可以由数组构造函数 <tt class="docutils literal"><span class="pre">[]</span></tt> 和数组一起构造，以序列运算符 <tt class="docutils literal"><span class="pre">@</span></tt> 。 为序列分配空间的另一种方法是调用内置的 <tt class="docutils literal"><span class="pre">newSeq</span></tt> 过程。</p>
<p>序列可以传递给 <em>开放数组</em> 类型的参数。</p>
<p>示例：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">IntArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># an array that is indexed with 0..5</span>
  <span class="Identifier">IntSeq</span> <span class="Operator">=</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># a sequence of integers</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">IntArray</span>
  <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">IntSeq</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span>  <span class="Comment"># [] is the array constructor</span>
<span class="Identifier">y</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Comment"># the @ turns the array into a sequence</span>

<span class="Keyword">let</span> <span class="Identifier">z</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="FloatNumber">1.0</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">]</span> <span class="Comment"># the type of z is array[0..3, float]</span></pre><p>数组或序列的下限可以由内置的proc <tt class="docutils literal"><span class="pre">low()</span></tt> 接收，上限由 <tt class="docutils literal"><span class="pre">high()</span></tt> 接收。 长度可以由 <tt class="docutils literal"><span class="pre">len()</span></tt> 接收。序列或开放数组的 <tt class="docutils literal"><span class="pre">low()</span></tt> 总是返回0，因为这是第一个有效索引。 可以使用 <tt class="docutils literal"><span class="pre">add()</span></tt> proc或 <tt class="docutils literal"><span class="pre">&amp;</span></tt> 运算符将元素追加到序列中，并使用 <tt class="docutils literal"><span class="pre">pop()</span></tt> proc删除（并获取）序列的最后一个元素。</p>
<p>符号 <tt class="docutils literal"><span class="pre">x [i]</span></tt> 可用于访问 <tt class="docutils literal"><span class="pre">x</span></tt> 的第i个元素。</p>
<p>数组始终是边界检查（静态或运行时）。可以通过编译指示禁用这些检查，或使用 <tt class="docutils literal"><span class="pre">--boundChecks：off</span></tt> 命令行开关调用编译器。</p>
<p>数组构造函数可以具有可读的显式索引：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Values</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valA</span><span class="Punctuation">,</span> <span class="Identifier">valB</span><span class="Punctuation">,</span> <span class="Identifier">valC</span>

<span class="Keyword">const</span>
  <span class="Identifier">lookupTable</span> <span class="Operator">=</span> <span class="Punctuation">[</span>
    <span class="Identifier">valA</span><span class="Punctuation">:</span> <span class="StringLit">&quot;A&quot;</span><span class="Punctuation">,</span>
    <span class="Identifier">valB</span><span class="Punctuation">:</span> <span class="StringLit">&quot;B&quot;</span><span class="Punctuation">,</span>
    <span class="Identifier">valC</span><span class="Punctuation">:</span> <span class="StringLit">&quot;C&quot;</span>
  <span class="Punctuation">]</span></pre><p>如果省略索引，则使用 <tt class="docutils literal"><span class="pre">succ(lastIndex)</span></tt> 作为索引值：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Values</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valA</span><span class="Punctuation">,</span> <span class="Identifier">valB</span><span class="Punctuation">,</span> <span class="Identifier">valC</span><span class="Punctuation">,</span> <span class="Identifier">valD</span><span class="Punctuation">,</span> <span class="Identifier">valE</span>

<span class="Keyword">const</span>
  <span class="Identifier">lookupTable</span> <span class="Operator">=</span> <span class="Punctuation">[</span>
    <span class="Identifier">valA</span><span class="Punctuation">:</span> <span class="StringLit">&quot;A&quot;</span><span class="Punctuation">,</span>
    <span class="StringLit">&quot;B&quot;</span><span class="Punctuation">,</span>
    <span class="Identifier">valC</span><span class="Punctuation">:</span> <span class="StringLit">&quot;C&quot;</span><span class="Punctuation">,</span>
    <span class="StringLit">&quot;D&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;e&quot;</span>
  <span class="Punctuation">]</span></pre>
<h2><a class="toc-backref" id="类型-开放数组（openarray）" href="#类型-开放数组（openarray）">开放数组（openarray）</a></h2><p>通常，固定大小的数组太不灵活了;程序应该能够处理不同大小的数组。 <span id="开放数组_1">开放数组</span> 类型只能用于参数。 开放数组总是从位置0开始用 <tt class="docutils literal"><span class="pre">int</span></tt> 索引。 <tt class="docutils literal"><span class="pre">len</span></tt> ， <tt class="docutils literal"><span class="pre">low</span></tt> 和 <tt class="docutils literal"><span class="pre">high</span></tt> 操作也可用于开放数组。 具有兼容基类型的任何数组都可以传递给开放数组形参，无关索引类型。 除了数组序列之外，还可以将序列传递给开放数组参数。</p>
<p>开放数组类型不能嵌套： 不支持多维开放数组，因为这种需求很少并且不能有效地完成。</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">testOpenArray</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Identifier">testOpenArray</span><span class="Punctuation">(</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">,</span><span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">)</span>  <span class="Comment"># array[]</span>
<span class="Identifier">testOpenArray</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">,</span><span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Comment"># seq[]</span></pre>
<h2><a class="toc-backref" id="类型-可变参数" href="#类型-可变参数">可变参数</a></h2><p><tt class="docutils literal"><span class="pre">varargs</span></tt> 参数是一个开放数组参数，它还允许将可变数量的参数传递给过程。 编译器隐式地将参数列表转换为数组：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">)</span>
<span class="Comment"># 转换成:</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>仅当varargs参数是过程头中的最后一个参数时，才会执行此转换。 也可以在此上下文中执行类型转换：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="FloatNumber">4.0</span><span class="Punctuation">)</span>
<span class="Comment"># 转换成:</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="Operator">$</span><span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="FloatNumber">4.0</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>在这个例子中， <tt class="docutils literal"><span class="pre">$</span></tt> 应用于传递给参数 <tt class="docutils literal"><span class="pre">a</span></tt> 的任何参数。 （注意 <tt class="docutils literal"><span class="pre">$</span></tt> 对字符串是一个空操作。）</p>
<p>请注意，传递给 <tt class="docutils literal"><span class="pre">varargs</span></tt> 形参的显式数组构造函数不会隐式地构造另一个隐式数组：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">takeV</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">takeV</span><span class="Punctuation">(</span><span class="Punctuation">[</span><span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Comment"># takeV的T是&quot;int&quot;, 不是&quot;int数组&quot;</span></pre><p><tt class="docutils literal"><span class="pre">varargs[typed]</span></tt> 被特别对待：它匹配任意类型的参数的变量列表，但 <em>始终</em> 构造一个隐式数组。</p>
<p>这是必需的，以便内置的 <tt class="docutils literal"><span class="pre">echo</span></tt> proc执行预期的操作：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">echo</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">typed</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">...</span><span class="Punctuation">}</span>

<span class="Identifier">echo</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span>
<span class="Comment"># 打印 &quot;@[1, 2, 3]&quot; 而不是 &quot;123&quot;</span></pre>
<h2><a class="toc-backref" id="类型-未检查数组" href="#类型-未检查数组">未检查数组</a></h2><p><tt class="docutils literal"><span class="pre">UncheckedArray[T]</span></tt> 类型是一种特殊的 <tt class="docutils literal"><span class="pre">数组</span></tt> ，编译器不检查它的边界。 这对于实现定制灵活大小的数组通常很有用。 另外，未检查数组转换为不确定大小的C数组：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MySeq</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">len</span><span class="Punctuation">,</span> <span class="Identifier">cap</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">UncheckedArray</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span></pre><p>大致生成C代码:</p>
<pre class="listing"><span class="Keyword">typedef</span> <span class="Keyword">struct</span> <span class="Punctuation">{</span>
  <span class="Identifier">NI</span> <span class="Identifier">len</span><span class="Punctuation">;</span>
  <span class="Identifier">NI</span> <span class="Identifier">cap</span><span class="Punctuation">;</span>
  <span class="Identifier">NI</span> <span class="Identifier">data</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span> <span class="Identifier">MySeq</span><span class="Punctuation">;</span></pre><p>未检查数组的基本类型可能不包含任何GC内存，但目前尚未检查。</p>
<p><strong>未来方向</strong>: 应该在未经检查的数组中允许GC内存，并且应该有一个关于GC如何确定数组的运行时大小的显式注释。</p>

<h2><a class="toc-backref" id="类型-元组和对象类型" href="#类型-元组和对象类型">元组和对象类型</a></h2><p>元组或对象类型的变量是异构存储容器。 元组或对象定义类型的各种命名 <em>字段</em> 。 元组还定义了字段的 <em>顺序</em> 。 元组用于异构存储类型，没有开销和很少的抽象可能性。 构造函数 <tt class="docutils literal"><span class="pre">()</span></tt> 可用于构造元组。 构造函数中字段的顺序必须与元组定义的顺序相匹配。 如果它们以相同的顺序指定相同类型的相同字段，则不同的元组类型 <em>等效</em> 。字段的 <em>名称</em> 也必须相同。</p>
<p>元组的赋值运算符复制每个组件。 对象的默认赋值运算符复制每个组件。 在 <a class="reference external" href="#typeminusboundminusoperationsminusoperator">type-bound-operations-operator</a> 中描述了赋值运算符的重载。</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># 代表人的类型：人由名字和年龄组成</span>
<span class="Keyword">var</span>
  <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>
<span class="Comment"># 一样，但不太可读：</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">30</span><span class="Punctuation">)</span></pre><p>可以使用括号和尾随逗号构造具有一个未命名字段的元组：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">echoUnaryTuple</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">,</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>

<span class="Identifier">echoUnaryTuple</span> <span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="Punctuation">)</span></pre><p>事实上，每个元组结构都允许使用尾随逗号。</p>
<p>实现将字段对齐以获得最佳访问性能。 对齐与C编译器的方式兼容。</p>
<p>为了与 <tt class="docutils literal"><span class="pre">object</span></tt> 声明保持一致， <tt class="docutils literal"><span class="pre">type</span></tt> 部分中的元组也可以用缩进而不是 <tt class="docutils literal"><span class="pre">[]</span></tt> 来定义：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">tuple</span>   <span class="Comment"># 代表人的类型</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>   <span class="Comment"># 人由名字</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">natural</span>   <span class="Comment"># 和年龄组成</span></pre><p>对象提供了元组不具备的许多功能。 对象提供继承和信息隐藏。 对象在运行时可以访问它们的类型，因此 <tt class="docutils literal"><span class="pre">of</span></tt> 运算符可用于确定对象的类型。 <tt class="docutils literal"><span class="pre">of</span></tt> 运算符类似于Java中的 <tt class="docutils literal"><span class="pre">instanceof</span></tt> 运算符。</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
    <span class="Identifier">name</span><span class="Operator">*:</span> <span class="Identifier">string</span>   <span class="Comment"># *表示可以从其他模块访问`name`</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>        <span class="Comment"># 没有*表示该字段已隐藏</span>
  
  <span class="Identifier">Student</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Person</span> <span class="Comment"># 学生是人</span>
    <span class="Identifier">id</span><span class="Punctuation">:</span> <span class="Identifier">int</span>                      <span class="Comment"># 有个id字段</span>

<span class="Keyword">var</span>
  <span class="Identifier">student</span><span class="Punctuation">:</span> <span class="Identifier">Student</span>
  <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">student</span> <span class="Keyword">of</span> <span class="Identifier">Student</span><span class="Punctuation">)</span> <span class="Comment"># is true</span>
<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">student</span> <span class="Keyword">of</span> <span class="Identifier">Person</span><span class="Punctuation">)</span> <span class="Comment"># also true</span></pre><p>应该从定义模块外部可见的对象字段必须用 <tt class="docutils literal"><span class="pre">*</span></tt> 标记。 与元组相反，不同的对象类型永远不会 <em>等价</em> 。 没有祖先的对象是隐式的 <tt class="docutils literal"><span class="pre">final</span></tt> ，因此没有隐藏的类型字段。 可以使用 <tt class="docutils literal"><span class="pre">inheritable</span></tt> pragma来引入除 <tt class="docutils literal"><span class="pre">system.RootObj</span></tt> 之外的新根对象。</p>

<h2><a class="toc-backref" id="类型-对象构造" href="#类型-对象构造">对象构造</a></h2><p>对象也可以使用 <span id="对象构造表达式_1">对象构造表达式</span> 创建, 具有语法 <tt class="docutils literal"><span class="pre">T（fieldA：valueA，fieldB：valueB，...）</span></tt> 其中 <tt class="docutils literal"><span class="pre">T</span></tt> 是 <tt class="docutils literal"><span class="pre">object</span></tt> 类型或 <tt class="docutils literal"><span class="pre">ref object</span></tt> 类型：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">student</span> <span class="Operator">=</span> <span class="Identifier">Student</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Anton&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">id</span><span class="Punctuation">:</span> <span class="DecNumber">3</span><span class="Punctuation">)</span></pre><p>请注意，与元组不同，对象需要字段名称及其值。 对于 <tt class="docutils literal"><span class="pre">ref object</span></tt> 类型， <tt class="docutils literal"><span class="pre">system.new</span></tt> 是隐式调用的。</p>

<h2><a class="toc-backref" id="类型-对象变体" href="#类型-对象变体">对象变体</a></h2><p>在需要简单变体类型的某些情况下，对象层次结构通常有点过了。 对象变体是通过用于运行时类型灵活性的枚举类型区分的标记联合，对照如在其他语言中找到的 <em>sum类型</em> 和 <em>代数数据类型(ADT)</em> 的概念。</p>
<p>一个示例：</p>
<pre class="listing"><span class="Comment"># 这是一个如何在Nim中建模抽象语法树的示例</span>
<span class="Keyword">type</span>
  <span class="Identifier">NodeKind</span> <span class="Operator">=</span> <span class="Keyword">enum</span>  <span class="Comment"># 不同的节点类型</span>
    <span class="Identifier">nkInt</span><span class="Punctuation">,</span>          <span class="Comment"># 带有整数值的叶节点</span>
    <span class="Identifier">nkFloat</span><span class="Punctuation">,</span>        <span class="Comment"># 带有浮点值的叶节点</span>
    <span class="Identifier">nkString</span><span class="Punctuation">,</span>       <span class="Comment"># 带有字符串值的叶节点</span>
    <span class="Identifier">nkAdd</span><span class="Punctuation">,</span>          <span class="Comment"># 加法</span>
    <span class="Identifier">nkSub</span><span class="Punctuation">,</span>          <span class="Comment"># 减法</span>
    <span class="Identifier">nkIf</span>            <span class="Comment"># if语句</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">NodeKind</span>  <span class="Comment"># ``kind`` 字段是鉴别字段</span>
    <span class="Keyword">of</span> <span class="Identifier">nkInt</span><span class="Punctuation">:</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Keyword">of</span> <span class="Identifier">nkFloat</span><span class="Punctuation">:</span> <span class="Identifier">floatVal</span><span class="Punctuation">:</span> <span class="Identifier">float</span>
    <span class="Keyword">of</span> <span class="Identifier">nkString</span><span class="Punctuation">:</span> <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Keyword">of</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">nkSub</span><span class="Punctuation">:</span>
      <span class="Identifier">leftOp</span><span class="Punctuation">,</span> <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Keyword">of</span> <span class="Identifier">nkIf</span><span class="Punctuation">:</span>
      <span class="Identifier">condition</span><span class="Punctuation">,</span> <span class="Identifier">thenPart</span><span class="Punctuation">,</span> <span class="Identifier">elsePart</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>

<span class="Comment"># 创建一个新case对象:</span>
<span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkIf</span><span class="Punctuation">,</span> <span class="Identifier">condition</span><span class="Punctuation">:</span> <span class="Keyword">nil</span><span class="Punctuation">)</span>
<span class="Comment"># 访问n.thenPart是有效的，因为 ``nkIf`` 分支是活动的</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">thenPart</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkFloat</span><span class="Punctuation">,</span> <span class="Identifier">floatVal</span><span class="Punctuation">:</span> <span class="FloatNumber">2.0</span><span class="Punctuation">)</span>

<span class="Comment"># 以下语句引发了一个 `FieldError` 异常，因为n.kind的值不合适且 ``nkString`` 分支未激活：</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">strVal</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span>

<span class="Comment"># 无效：会更改活动对象分支：</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">=</span> <span class="Identifier">nkInt</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">leftOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkInt</span><span class="Punctuation">,</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
                          <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkInt</span><span class="Punctuation">,</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># valid：不更改活动对象分支：</span>
<span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">=</span> <span class="Identifier">nkSub</span></pre><p>从示例中可以看出，对象层次结构的优点是不需要在不同对象类型之间进行转换。 但是，访问无效对象字段会引发异常。</p>
<p>对象声明中 <tt class="docutils literal"><span class="pre">case</span></tt> 的语法紧跟着 <tt class="docutils literal"><span class="pre">case</span></tt> 语句的语法： <tt class="docutils literal"><span class="pre">case</span></tt> 部分中的分支也可以缩进。</p>
<p>在示例中， <tt class="docutils literal"><span class="pre">kind</span></tt> 字段称为 <span id="鉴别字段_1">鉴别字段</span> : 为安全起见，不能对其进行地址限制，并且对其赋值受到限制：新值不得导致活动对象分支发生变化。 此外，在对象构造期间指定特定分支的字段时，必须将相应的鉴别字段值指定为常量表达式。</p>
<p>而不是更改活动对象分支，将内存中的旧对象完全替换为新对象：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">leftOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkInt</span><span class="Punctuation">,</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
                          <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkInt</span><span class="Punctuation">,</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># 更改节点的内容：</span>
<span class="Identifier">x</span><span class="Punctuation">[</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">NodeObj</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkString</span><span class="Punctuation">,</span> <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">)</span></pre><p>从版本0.20开始 <tt class="docutils literal"><span class="pre">system.reset</span></tt> 不能再用于支持对象分支的更改，因为这从来就不是完全内存安全的。</p>
<p>作为一项特殊规则，鉴别字段类型也可以使用 <tt class="docutils literal"><span class="pre">case</span></tt> 语句来限制。 如果 <tt class="docutils literal"><span class="pre">case</span></tt> 语句分支中的鉴别字段变量的可能值是所选对象分支的鉴别字段值的子集，则初始化被认为是有效的。 此分析仅适用于序数类型的不可变判别符，并忽略 <tt class="docutils literal"><span class="pre">elif</span></tt> 分支。</p>
<p>A small 示例：</p>
<pre class="listing"><span class="Keyword">let</span> <span class="Identifier">unknownKind</span> <span class="Operator">=</span> <span class="Identifier">nkSub</span>

<span class="Comment"># 无效：不安全的初始化，因为类型字段不是静态已知的：</span>
<span class="Keyword">var</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">unknownKind</span><span class="Punctuation">,</span> <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="StringLit">&quot;y&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">z</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">case</span> <span class="Identifier">unknownKind</span>
<span class="Keyword">of</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">nkSub</span><span class="Punctuation">:</span>
  <span class="Comment"># valid：此分支的可能值是nkAdd / nkSub对象分支的子集：</span>
  <span class="Identifier">z</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">unknownKind</span><span class="Punctuation">,</span> <span class="Identifier">leftOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;ignoring: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">unknownKind</span></pre>
<h2><a class="toc-backref" id="类型-集合类型" href="#类型-集合类型">集合类型</a></h2>集合模拟了数学集合的概念。 集合的基类型只能是固定大小的序数类型，它们是:<ul class="simple"><li><tt class="docutils literal"><span class="pre">int8</span></tt>-<tt class="docutils literal"><span class="pre">int16</span></tt></li>
<li><tt class="docutils literal"><span class="pre">uint8</span></tt>/<tt class="docutils literal"><span class="pre">byte</span></tt>-<tt class="docutils literal"><span class="pre">uint16</span></tt></li>
<li><tt class="docutils literal"><span class="pre">char</span></tt></li>
<li><tt class="docutils literal"><span class="pre">enum</span></tt></li>
</ul>
<p>或等价类型。对有符号整数集合的基类型被定义为在 <tt class="docutils literal"><span class="pre">0 .. MaxSetElements-1</span></tt> 的范围内， 其中 <tt class="docutils literal"><span class="pre">MaxSetElements</span></tt> 目前是2^16。</p>
<p>原因是集合被实现为高性能位向量。尝试声明具有更大类型的集将导致错误：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">int64</span><span class="Punctuation">]</span> <span class="Comment"># 错误: 集合太大</span></pre><p>集合可以通过集合构造器来构造： <tt class="docutils literal"><span class="pre">{}</span></tt> 是空集合。 空集合与其它具体的集合类型兼容。构造器也可以用来包含元素（和元素范围）：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">CharSet</span> <span class="Operator">=</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">CharSet</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">}</span> <span class="Comment"># 构造一个包含'a'到'z'和'0'到'9'的集合</span></pre><p>集合支持的操作符：</p>
<table border="1" class="docutils"><tr><th>操作符</th><th>含义</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">A + B</span></tt></td><td>并集</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A * B</span></tt></td><td>交集</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A - B</span></tt></td><td>差集</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A == B</span></tt></td><td>相等</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A &lt;= B</span></tt></td><td>子集</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A &lt; B</span></tt></td><td>真子集</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">e in A</span></tt></td><td>元素</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">e notin A</span></tt></td><td>A不包含元素e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">contains(A, e)</span></tt></td><td>包含元素e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">card(A)</span></tt></td><td>A的基 (集合A中的元素数量)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">incl(A, elem)</span></tt></td><td>同 <tt class="docutils literal"><span class="pre">A = A + {elem}</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">excl(A, elem)</span></tt></td><td>同 <tt class="docutils literal"><span class="pre">A = A - {elem}</span></tt></td></tr>
</table>
<h3><a class="toc-backref" id="集合类型-位字段" href="#集合类型-位字段">位字段</a></h3><p>集合经常用来定义过程的 <em>标示</em> 。这比定义必须或在一起的整数常量清晰并且类型安全。</p>
<p>枚举、集合和强转可以一起用：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MyFlag</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">size</span><span class="Punctuation">:</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">cint</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">A</span>
    <span class="Identifier">B</span>
    <span class="Identifier">C</span>
    <span class="Identifier">D</span>
  <span class="Identifier">MyFlags</span> <span class="Operator">=</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">MyFlag</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">MyFlags</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">cint</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
<span class="Keyword">proc</span> <span class="Identifier">toFlags</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">MyFlags</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">MyFlags</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">0</span>
<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Identifier">A</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Identifier">D</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">8</span>
<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">C</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">5</span>
<span class="Identifier">assert</span> <span class="Identifier">toFlags</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Punctuation">{</span><span class="Punctuation">}</span>
<span class="Identifier">assert</span> <span class="Identifier">toFlags</span><span class="Punctuation">(</span><span class="DecNumber">7</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Punctuation">{</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span><span class="Punctuation">,</span> <span class="Identifier">C</span><span class="Punctuation">}</span></pre><p>注意集合如何把枚举变成2的指数。</p>
<p>如果和C一起使用枚举和集合，使用distinct cint。</p>
<p>为了和C互通见 <a class="reference external" href="#implementation-specific-pragmas-bitsize-pragma">bitsize pragma</a> 。</p>

<h2><a class="toc-backref" id="类型-引用和指针类型" href="#类型-引用和指针类型">引用和指针类型</a></h2><p>引用（类似于其他编程语言中的指针）是引入多对一关系的一种方式。 这意味着不同的引用可以指向并修改内存中的相同位置（也称为 <span id="别名_1">别名</span> )。</p>
<p>Nim区分 <span id="追踪_1">追踪</span>和 <span id="未追踪_1">未追踪</span> 引用。 未追踪引用也叫 <em>指针</em> 。 追踪引用指向垃圾回收堆中的对象，未追踪引用指向手动分配对象或内存中其它位置的对象。 因此，未追踪引用是 <em>不安全</em> 的。 然而对于某些访问硬件的低级操作，未追踪引用是不可避免的。</p>
<p>使用 <strong>ref</strong> 关键字声明追踪引用，使用 <strong>ptr</strong> 关键字声明未追踪引用。 通常， <tt class="docutils literal"><span class="pre">ptr T</span></tt> 可以隐式转换为 <tt class="docutils literal"><span class="pre">pointer</span></tt> 类型。</p>
<p>空的下标 <tt class="docutils literal"><span class="pre">[]</span></tt> 表示法可以用来取代引用， <tt class="docutils literal"><span class="pre">addr</span></tt> 程序返回一个对象的地址。 地址始终是未经过引用的参考。 因此， <tt class="docutils literal"><span class="pre">addr</span></tt> 的使用是 <em>不安全的</em> 功能。</p>
<p><tt class="docutils literal"><span class="pre">.</span></tt> （访问元组和对象字段运算符）和 <tt class="docutils literal"><span class="pre">[]</span></tt> （数组/字符串/序列索引运算符）运算符对引用类型执行隐式解引用操作：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">var</span>
  <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="DecNumber">9</span>
<span class="Comment"># 不必写n[].data; 实际上 n[].data是不鼓励的。</span></pre><p>还对过程调用的第一个参数执行自动解引用。 但是目前这个功能只能通过 <tt class="docutils literal"><span class="pre">{.experimental：&quot;implicitDeref&quot;.}</span></tt> 来启用：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;implicitDeref&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">depth</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">NodeObj</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">var</span>
  <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">depth</span>
<span class="Comment"># 也不必写n[].depth</span></pre><p>为了简化结构类型检查，递归元组无效：</p>
<pre class="listing"><span class="Comment"># 无效递归</span>
<span class="Keyword">type</span> <span class="Identifier">MyTuple</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">MyTuple</span><span class="Punctuation">]</span></pre><p>同样， <tt class="docutils literal"><span class="pre">T = ref T</span></tt> 是无效类型。</p>
<p>作为语法扩展 <tt class="docutils literal"><span class="pre">object</span></tt> 类型，如果在类型部分中通过 <tt class="docutils literal"><span class="pre">ref object</span></tt> 或 <tt class="docutils literal"><span class="pre">ptr object</span></tt> 符号声明，则可以是匿名的。 如果对象只应获取引用语义，则此功能非常有用：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre><p>要分配新的追踪对象，必须使用内置过程 <tt class="docutils literal"><span class="pre">new</span></tt> 。 为了处理未追踪的内存，可以使用过程 <tt class="docutils literal"><span class="pre">alloc</span></tt> ， <tt class="docutils literal"><span class="pre">dealloc</span></tt> 和 <tt class="docutils literal"><span class="pre">realloc</span></tt> 。 系统模块的文档包含更多信息。</p>
<p>Nil ---</p>
<p>如果引用指向 <em>nothing</em> ，则它具有值 <tt class="docutils literal"><span class="pre">nil</span></tt> 。 <tt class="docutils literal"><span class="pre">nil</span></tt> 也是所有 <tt class="docutils literal"><span class="pre">ref</span></tt> 和 <tt class="docutils literal"><span class="pre">ptr</span></tt> 类型的默认值。 解除引用 <tt class="docutils literal"><span class="pre">nil</span></tt> 是一个不可恢复的致命运行时错误。 解除引用操作 <tt class="docutils literal"><span class="pre">p []</span></tt> 意味着 <tt class="docutils literal"><span class="pre">p</span></tt> 不是nil。 这可以通过实现来利用，以优化代码，如：</p>
<pre class="listing"><span class="Identifier">p</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">field</span> <span class="Operator">=</span> <span class="DecNumber">3</span>
<span class="Keyword">if</span> <span class="Identifier">p</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
  <span class="Comment"># 如果p为nil，``p []`` 会导致崩溃，</span>
  <span class="Comment"># 所以我们知道 ``p`` 总不是nil。</span>
  <span class="Identifier">action</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>Into:</p>
<pre class="listing"><span class="Identifier">p</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">field</span> <span class="Operator">=</span> <span class="DecNumber">3</span>
<span class="Identifier">action</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p><em>注意</em> ：这与用于解引用NULL指针的C的“未定义行为”不具有可比性。</p>

<h2><a class="toc-backref" id="类型-将gc内存和-ptr-混用" href="#类型-将gc内存和-ptr-混用">将GC内存和 <tt class="docutils literal"><span class="pre">ptr</span></tt> 混用</a></h2><p>如果未追踪对象包含追踪对象（如追踪引用，字符串或序列），则需要特别小心：为了正确释放所有内容，必须在手动释放未追踪内存之前调用内置过程 <tt class="docutils literal"><span class="pre">GCunref</span></tt> ：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Data</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">]</span>

<span class="Comment"># 为堆上的Data分配内存：</span>
<span class="Keyword">var</span> <span class="Identifier">d</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Keyword">ptr</span> <span class="Identifier">Data</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">alloc0</span><span class="Punctuation">(</span><span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">Data</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Comment"># 在垃圾收集堆上创建一个新字符串：</span>
<span class="Identifier">d</span><span class="Operator">.</span><span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span>

<span class="Comment"># 告诉GC不再需要该字符串：</span>
<span class="Identifier">GCunref</span><span class="Punctuation">(</span><span class="Identifier">d</span><span class="Operator">.</span><span class="Identifier">s</span><span class="Punctuation">)</span>

<span class="Comment"># 释放内存:</span>
<span class="Identifier">dealloc</span><span class="Punctuation">(</span><span class="Identifier">d</span><span class="Punctuation">)</span></pre><p>没有 <tt class="docutils literal"><span class="pre">GCunref</span></tt> 调用，为 <tt class="docutils literal"><span class="pre">d.s</span></tt> 字符串分配的内存永远不会被释放。 该示例还演示了低级编程的两个重要特性： <tt class="docutils literal"><span class="pre">sizeof</span></tt> proc以字节为单位返回类型或值的大小。 <tt class="docutils literal"><span class="pre">cast</span></tt> 运算符可以绕过类型系统：编译器被强制处理 <tt class="docutils literal"><span class="pre">alloc0</span></tt> 调用的结果（返回一个无类型的指针），就好像它是 <tt class="docutils literal"><span class="pre">ptr Data</span></tt> 类型。 只有在不可避免的情况下才能进行强转：它会破坏类型安全性并且错误可能导致隐蔽的崩溃。</p>
<p><strong>注意</strong>: 该示例仅起作用，因为内存初始化为零（ <tt class="docutils literal"><span class="pre">alloc0</span></tt> 而不是 <tt class="docutils literal"><span class="pre">alloc</span></tt> 执行此操作）： <tt class="docutils literal"><span class="pre">d.s</span></tt> 因此初始化为二进制零，字符串赋值可以处理。 在将垃圾收集数据与非托管内存混合时，需要知道这样的低级细节。</p>

<h2><a class="toc-backref" id="类型-not-nil注解" href="#类型-not-nil注解">Not nil注解</a></h2><p><tt class="docutils literal"><span class="pre">nil</span></tt> 是有效值的所有类型都可以注释为使用 <tt class="docutils literal"><span class="pre">not nil</span></tt> 注释将 <tt class="docutils literal"><span class="pre">nil</span></tt> 排除：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">PObject</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">TObj</span> <span class="Keyword">not</span> <span class="Keyword">nil</span>
  <span class="Identifier">TProc</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Keyword">not</span> <span class="Keyword">nil</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">PObject</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;not nil&quot;</span>

<span class="Comment"># 编译器捕获:</span>
<span class="Identifier">p</span><span class="Punctuation">(</span><span class="Keyword">nil</span><span class="Punctuation">)</span>

<span class="Comment"># 和这个:</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">PObject</span>
<span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>编译器确保每个代码路径初始化包含非空指针的变量。此分析的细节仍在此处指定。</p>

<h2><a class="toc-backref" id="类型-过程类型" href="#类型-过程类型">过程类型</a></h2><p>过程类型在内部是指向过程的指针。 <tt class="docutils literal"><span class="pre">nil</span></tt> 是过程类型变量的允许值。 Nim使用过程类型来实现 <span id="函数式_1">函数式</span> 编程技术。</p>
<p>Examples:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">printItem</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">proc</span> <span class="Identifier">forEach</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Operator">...</span>

<span class="Identifier">forEach</span><span class="Punctuation">(</span><span class="Identifier">printItem</span><span class="Punctuation">)</span>  <span class="Comment"># 无法编译，因为调用约定不同</span></pre><pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">OnMouseMove</span> <span class="Operator">=</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">onMouseMove</span><span class="Punctuation">(</span><span class="Identifier">mouseX</span><span class="Punctuation">,</span> <span class="Identifier">mouseY</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 有默认的调用约定</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;x: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">mouseX</span><span class="Punctuation">,</span> <span class="StringLit">&quot; y: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">mouseY</span>

<span class="Keyword">proc</span> <span class="Identifier">setOnMouseMove</span><span class="Punctuation">(</span><span class="Identifier">mouseMoveEvent</span><span class="Punctuation">:</span> <span class="Identifier">OnMouseMove</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Comment"># 可以, 'onMouseMove'有默认的调用约定，它是兼容的</span>
<span class="Comment"># 到 'closure':</span>
<span class="Identifier">setOnMouseMove</span><span class="Punctuation">(</span><span class="Identifier">onMouseMove</span><span class="Punctuation">)</span></pre><p>过程类型的一个微妙问题是过程的调用约定会影响类型兼容性：过程类型只有在具有相同的调用约定时才是兼容的。 作为一个特殊的扩展，调用约定 <tt class="docutils literal"><span class="pre">nimcall</span></tt> 的过程可以传递给一个参数，该参数需要调用约定 <tt class="docutils literal"><span class="pre">closure</span></tt> 的proc。</p>
<p>Nim支持这些 <span id="调用约定_1">调用约定</span>：</p>
<p><span id="nimcall_1">nimcall</span> 是用于Nim <strong>proc</strong> 的默认约定。它与 <tt class="docutils literal"><span class="pre">fastcall</span></tt> 相同，但仅适用于支持 <tt class="docutils literal"><span class="pre">fastcall</span></tt> 的C编译器。</p>
<dl class="docutils"><dt><span id="closure_1">closure</span></dt>
<dd>是缺少任何pragma注释的 <strong>过程类型</strong> 的默认调用约定。 它表示该过程具有隐藏的隐式形参（*环境*）。 具有调用约定 <tt class="docutils literal"><span class="pre">closure</span></tt> 的过程变量占用两个机器字：一个用于proc指针，另一个用于指向隐式传递环境的指针。</dd>
<dt><span id="stdcall_1">stdcall</span></dt>
<dd>这是微软指定的stdcall约定。生成的C过程使用 <tt class="docutils literal"><span class="pre">__stdcall</span></tt> 关键字声明。</dd>
<dt><span id="cdecl_1">cdecl</span></dt>
<dd>cdecl约定意味着过程应使用与C编译器相同的约定。 在Windows下，生成的C过程使用 <tt class="docutils literal"><span class="pre">__cdecl</span></tt> 关键字声明。</dd>
<dt><span id="safecall_1">safecall</span></dt>
<dd>这是微软指定的safecall约定。 生成的C过程使用 <tt class="docutils literal"><span class="pre">__safecall</span></tt> 关键字声明。 <em>安全</em> 一词指的是所有硬件寄存器都应被推送到硬件堆栈。</dd>
<dt><span id="inline_1">inline</span></dt>
<dd>内联约定意味着调用者不应该调用该过程，而是直接内联其代码。 请注意，Nim不是内联的，而是将其留给C编译器;它生成 <tt class="docutils literal"><span class="pre">__inline</span></tt> 程序。 这只是编译器的一个提示：编译器可能完全忽略它，它可能内联没有标记为 <tt class="docutils literal"><span class="pre">inline</span></tt> 的过程。</dd>
<dt><span id="fastcall_1">fastcall</span></dt>
<dd>Fastcall对不同的C编译器意味着不同的东西，不论C的 <tt class="docutils literal"><span class="pre">__fastcall</span></tt> 意义是什么。</dd>
<dt><span id="syscall_1">syscall</span></dt>
<dd>系统调用约定与C中的 <tt class="docutils literal"><span class="pre">__syscall</span></tt> 相同，用于中断。</dd>
<dt><span id="noconv_1">noconv</span></dt>
<dd>生成的C代码将没有任何显式调用约定，因此使用C编译器的默认调用约定。 这是必需的，因为Nim对程序的默认调用约定是 <tt class="docutils literal"><span class="pre">fastcall</span></tt> 来提高速度。</dd>
</dl>
<p>大多数调用约定仅适用于Windows 32位平台。</p>
<p>默认调用约定是 <tt class="docutils literal"><span class="pre">nimcall</span></tt> ，除非它是内部proc（proc中的proc）。 对于内部过程，无论是否访问其环境，都会执行分析。 如果它这样做，它有调用约定 <tt class="docutils literal"><span class="pre">closure</span></tt> ，否则它有调用约定 <tt class="docutils literal"><span class="pre">nimcall</span></tt> 。</p>

<h2><a class="toc-backref" id="类型-distinct类型" href="#类型-distinct类型">Distinct类型</a></h2><p><tt class="docutils literal"><span class="pre">distinct</span></tt> 类型是从 <span id="基类型_1">基类型</span>  派生的新类型与它的基类型不兼容。 特别是，它是一种不同类型的基本属性，它 <em>并不</em> 意味着它和基本类型之间的子类型关系。 允许从不同类型到其基本类型的显式类型转换，反之亦然。另请参阅 <tt class="docutils literal"><span class="pre">distinctBase</span></tt> 以获得逆操作。</p>
<p>如果基类型是序数类型，则不同类型是序数类型。</p>

<h3><a class="toc-backref" id="distinct类型-模拟货币" href="#distinct类型-模拟货币">模拟货币</a></h3><p>可以使用不同的类型来模拟不同的物理 <span id="单位_1">单位</span> 比如具有数字基类型。 以下示例模拟货币。</p>
<p>货币计算中不应混合不同的货币。 不同类型是模拟不同货币的完美工具：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Dollar</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>
  <span class="Identifier">Euro</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>

<span class="Keyword">var</span>
  <span class="Identifier">d</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span>
  <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">Euro</span>

<span class="Identifier">echo</span> <span class="Identifier">d</span> <span class="Operator">+</span> <span class="DecNumber">12</span>
<span class="Comment"># 错误：无法添加没有单位的数字和 ``美元``</span></pre><p><tt class="docutils literal"><span class="pre">d + 12.Dollar</span></tt> 也不允许，因为 <tt class="docutils literal"><span class="pre">+</span></tt> 为 <tt class="docutils literal"><span class="pre">int</span></tt> (在其它类型之中)定义, 而没有为 <tt class="docutils literal"><span class="pre">Dollar</span></tt> 定义。 因此需要定义美元的 <tt class="docutils literal"><span class="pre">+</span></tt> ：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">Dollar</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre><p>将一美元乘以一美元是没有意义的，但可以不带单位相乘；对除法同样成立：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">Dollar</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">*</span> <span class="Identifier">y</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">Dollar</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Operator">*</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">div</span><span class="Punctuation">`</span> <span class="Operator">...</span></pre><p>这很快变得乏味。 实现是琐碎的，编译器不应该生成所有这些代码只是为了以后优化它 - 毕竟美元 <tt class="docutils literal"><span class="pre">+</span></tt> 应该生成与整型 <tt class="docutils literal"><span class="pre">+</span></tt> 相同的二进制代码。 编译指示 <span id="borrow_1">borrow</span> 旨在解决这个问题；原则上它会生成以上的琐碎实现：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">div</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p><tt class="docutils literal"><span class="pre">borrow</span></tt> 编译指示使编译器使用与处理distinct类型的基类型的proc相同的实现，因此不会生成任何代码。</p>
<p>但似乎所有这些样板代码都需要为 <tt class="docutils literal"><span class="pre">欧元</span></tt> 货币重复。这可以通过 <a class="reference external" href="#模板">模板</a> 解决。</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">additive</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  
  <span class="Comment"># 一元运算符:</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">multiplicative</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">base</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">div</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">mod</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">comparable</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&lt;</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&lt;=</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">defineCurrency</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">base</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">type</span>
    <span class="Identifier">typ</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">base</span>
  <span class="Identifier">additive</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">)</span>
  <span class="Identifier">multiplicative</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">base</span><span class="Punctuation">)</span>
  <span class="Identifier">comparable</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">)</span>

<span class="Identifier">defineCurrency</span><span class="Punctuation">(</span><span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Identifier">defineCurrency</span><span class="Punctuation">(</span><span class="Identifier">Euro</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span></pre><p>借用编译指示还可用于注释不同类型以允许某些内置操作被提升：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Foo</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
  
  <span class="Identifier">Bar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Punctuation">:</span> <span class="Punctuation">`</span><span class="Operator">.</span><span class="Punctuation">`</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">Foo</span>

<span class="Keyword">var</span> <span class="Identifier">bb</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Bar</span>
<span class="Identifier">new</span> <span class="Identifier">bb</span>
<span class="Comment"># 字段访问有效</span>
<span class="Identifier">bb</span><span class="Operator">.</span><span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">90</span>
<span class="Identifier">bb</span><span class="Operator">.</span><span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span></pre><p>目前只有点访问符可以用这种方式借用。</p>

<h3><a class="toc-backref" id="distinct类型-避免sql注入攻击" href="#distinct类型-避免sql注入攻击">避免SQL注入攻击</a></h3><p>从Nim传递到SQL数据库的SQL语句可能被模拟为字符串。 但是，使用字符串模板并填充值很容易受到 <span id="sql注入攻击_1">SQL注入攻击</span>:</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">strutils</span>

<span class="Keyword">proc</span> <span class="Identifier">query</span><span class="Punctuation">(</span><span class="Identifier">db</span><span class="Punctuation">:</span> <span class="Identifier">DbHandle</span><span class="Punctuation">,</span> <span class="Identifier">statement</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">var</span>
  <span class="Identifier">username</span><span class="Punctuation">:</span> <span class="Identifier">string</span>

<span class="Identifier">db</span><span class="Operator">.</span><span class="Identifier">query</span><span class="Punctuation">(</span><span class="StringLit">&quot;SELECT FROM users WHERE name = '$1'&quot;</span> <span class="Operator">%</span> <span class="Identifier">username</span><span class="Punctuation">)</span>
<span class="Comment"># 可怕的安全漏洞，但编译没有问题</span></pre><p>通过将包含SQL的字符串与不包含SQL的字符串区分开来可以避免这种情况。 不同类型提供了一种引入与 <tt class="docutils literal"><span class="pre">string</span></tt> 不兼容的新字符串类型 <tt class="docutils literal"><span class="pre">SQL</span></tt> 的方法：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">SQL</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">string</span>

<span class="Keyword">proc</span> <span class="Identifier">query</span><span class="Punctuation">(</span><span class="Identifier">db</span><span class="Punctuation">:</span> <span class="Identifier">DbHandle</span><span class="Punctuation">,</span> <span class="Identifier">statement</span><span class="Punctuation">:</span> <span class="Identifier">SQL</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">var</span>
  <span class="Identifier">username</span><span class="Punctuation">:</span> <span class="Identifier">string</span>

<span class="Identifier">db</span><span class="Operator">.</span><span class="Identifier">query</span><span class="Punctuation">(</span><span class="StringLit">&quot;SELECT FROM users WHERE name = '$1'&quot;</span> <span class="Operator">%</span> <span class="Identifier">username</span><span class="Punctuation">)</span>
<span class="Comment"># 静态错误：`query` 需要一个SQL字符串。</span></pre><p>它是抽象类型的基本属性，它们 <em>并不</em> 意味着抽象类型与其基类型之间的子类型关系。 允许从 <tt class="docutils literal"><span class="pre">string</span></tt> 到 <tt class="docutils literal"><span class="pre">SQL</span></tt> 的显式类型转换：</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">strutils</span><span class="Punctuation">,</span> <span class="Identifier">sequtils</span>

<span class="Keyword">proc</span> <span class="Identifier">properQuote</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">SQL</span> <span class="Operator">=</span>
  <span class="Comment"># 为SQL语句正确引用字符串</span>
  <span class="Keyword">return</span> <span class="Identifier">SQL</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">%</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">frmt</span><span class="Punctuation">:</span> <span class="Identifier">SQL</span><span class="Punctuation">,</span> <span class="Identifier">values</span><span class="Punctuation">:</span> <span class="Identifier">openarray</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">SQL</span> <span class="Operator">=</span>
  <span class="Comment"># 引用每个论点：</span>
  <span class="Keyword">let</span> <span class="Identifier">v</span> <span class="Operator">=</span> <span class="Identifier">values</span><span class="Operator">.</span><span class="Identifier">mapIt</span><span class="Punctuation">(</span><span class="Identifier">SQL</span><span class="Punctuation">,</span> <span class="Identifier">properQuote</span><span class="Punctuation">(</span><span class="Identifier">it</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Comment"># we need a temporary type for the type conversion :-(</span>
  <span class="Keyword">type</span> <span class="Identifier">StrSeq</span> <span class="Operator">=</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span>
  <span class="Comment"># 调用 strutils.`%`:</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">SQL</span><span class="Punctuation">(</span><span class="Identifier">string</span><span class="Punctuation">(</span><span class="Identifier">frmt</span><span class="Punctuation">)</span> <span class="Operator">%</span> <span class="Identifier">StrSeq</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Identifier">db</span><span class="Operator">.</span><span class="Identifier">query</span><span class="Punctuation">(</span><span class="StringLit">&quot;SELECT FROM users WHERE name = '$1'&quot;</span><span class="Operator">.</span><span class="Identifier">SQL</span> <span class="Operator">%</span> <span class="Punctuation">[</span><span class="Identifier">username</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>现在我们有针对SQL注入攻击的编译时检查。 因为 <tt class="docutils literal"><span class="pre">&quot;&quot;.SQL</span></tt> 转换为 <tt class="docutils literal"><span class="pre">SQL(&quot;&quot;)</span></tt> 不需要新的语法来获得漂亮的 <tt class="docutils literal"><span class="pre">SQL</span></tt> 字符串字面值。 假设的 <tt class="docutils literal"><span class="pre">SQL</span></tt> 类型实际上存在于库中，作为 <a class="reference external" href="db_sqlite.html">db_sqlite</a> 等模块的 <a class="reference external" href="db_sqlite.html＃TSqlQuery">TSqlQuery类型</a> 。</p>

<h2><a class="toc-backref" id="类型-自动类型" href="#类型-自动类型">自动类型</a></h2><p><tt class="docutils literal"><span class="pre">auto</span></tt> 类型只能用于返回类型和参数。 对于返回类型，它会使编译器从过程体中推断出类型：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">returnsInt</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">auto</span> <span class="Operator">=</span> <span class="DecNumber">1984</span></pre><p>对于形参，它现在是创建隐式的泛型例程：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">auto</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre><p>同:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">[</span><span class="Identifier">T1</span><span class="Punctuation">,</span> <span class="Identifier">T2</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">T1</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">T2</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre><p>然而，该语言的更高版本可能会将其更改为从方法体 <tt class="docutils literal"><span class="pre">推断形参类型</span></tt> 。 然后上面的 <tt class="docutils literal"><span class="pre">foo</span></tt> 将被拒绝，因为形参的类型不能从空的 <tt class="docutils literal"><span class="pre">discard</span></tt> 语句中推断出来。</p>

<h1><a class="toc-backref" id="类型关系" href="#类型关系">类型关系</a></h1><p>以下部分定义了描述编译器类型检查所需类型的几个关系。</p>

<h2><a class="toc-backref" id="类型关系-类型相等性" href="#类型关系-类型相等性">类型相等性</a></h2><p>Nim对大多数类型使用结构类型等价。 仅对于对象，枚举和不同类型使用名称等价。 <em>伪代码中</em> 的以下算法确定类型相等：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">,</span>
                   <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">HashSet</span><span class="Punctuation">[</span><span class="Punctuation">(</span><span class="Identifier">PType</span><span class="Punctuation">,</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span><span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Keyword">in</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Identifier">incl</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span><span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">kind</span><span class="Punctuation">:</span>
    <span class="Keyword">case</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span>
    <span class="Keyword">of</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">intXX</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">,</span> <span class="Identifier">floatXX</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">,</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">cstring</span><span class="Punctuation">,</span> <span class="Identifier">pointer</span><span class="Punctuation">,</span>
        <span class="Identifier">bool</span><span class="Punctuation">,</span> <span class="Keyword">nil</span><span class="Punctuation">,</span> <span class="Identifier">void</span><span class="Punctuation">:</span>
      <span class="Comment"># 叶类型: 类型等价; 不做更多检查</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="Keyword">ref</span><span class="Punctuation">,</span> <span class="Keyword">ptr</span><span class="Punctuation">,</span> <span class="Keyword">var</span><span class="Punctuation">,</span> <span class="Identifier">set</span><span class="Punctuation">,</span> <span class="Identifier">seq</span><span class="Punctuation">,</span> <span class="Identifier">openarray</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Identifier">range</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
        <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">rangeA</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">rangeA</span><span class="Punctuation">)</span> <span class="Keyword">and</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">rangeB</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">rangeB</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Identifier">array</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Keyword">tuple</span><span class="Punctuation">:</span>
      <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">tupleLen</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">tupleLen</span><span class="Punctuation">:</span>
        <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">tupleLen</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span>
          <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">false</span>
        <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="Keyword">object</span><span class="Punctuation">,</span> <span class="Keyword">enum</span><span class="Punctuation">,</span> <span class="Keyword">distinct</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span>
    <span class="Keyword">of</span> <span class="Keyword">proc</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">parameterTuple</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">parameterTuple</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">resultType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">resultType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">callingConvention</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">callingConvention</span>

<span class="Keyword">proc</span> <span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">HashSet</span><span class="Punctuation">[</span><span class="Punctuation">(</span><span class="Identifier">PType</span><span class="Punctuation">,</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="Punctuation">}</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span></pre><p>由于类型可以是有环图，因此上述算法需要辅助集合 <tt class="docutils literal"><span class="pre">s</span></tt> 来检测这种情况</p>

<h2><a class="toc-backref" id="类型关系-类型相等与类型区分" href="#类型关系-类型相等与类型区分">类型相等与类型区分</a></h2><p>以下算法（伪代码）确定两种类型是否相等而不是 <tt class="docutils literal"><span class="pre">不同</span></tt> 类型。 为简洁起见，省略了辅助集 <tt class="docutils literal"><span class="pre">s</span></tt> 的循环检查：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">kind</span><span class="Punctuation">:</span>
    <span class="Keyword">case</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span>
    <span class="Keyword">of</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">intXX</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">,</span> <span class="Identifier">floatXX</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">,</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">cstring</span><span class="Punctuation">,</span> <span class="Identifier">pointer</span><span class="Punctuation">,</span>
        <span class="Identifier">bool</span><span class="Punctuation">,</span> <span class="Keyword">nil</span><span class="Punctuation">,</span> <span class="Identifier">void</span><span class="Punctuation">:</span>
      <span class="Comment"># leaf type: kinds identical; nothing more to check</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="Keyword">ref</span><span class="Punctuation">,</span> <span class="Keyword">ptr</span><span class="Punctuation">,</span> <span class="Keyword">var</span><span class="Punctuation">,</span> <span class="Identifier">set</span><span class="Punctuation">,</span> <span class="Identifier">seq</span><span class="Punctuation">,</span> <span class="Identifier">openarray</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Identifier">range</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
        <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">rangeA</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">rangeA</span><span class="Punctuation">)</span> <span class="Keyword">and</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">rangeB</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">rangeB</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Identifier">array</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Keyword">tuple</span><span class="Punctuation">:</span>
      <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">tupleLen</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">tupleLen</span><span class="Punctuation">:</span>
        <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">tupleLen</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span>
          <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">false</span>
        <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="Keyword">distinct</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Keyword">object</span><span class="Punctuation">,</span> <span class="Keyword">enum</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span>
    <span class="Keyword">of</span> <span class="Keyword">proc</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">parameterTuple</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">parameterTuple</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">resultType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">resultType</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">callingConvention</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">callingConvention</span>
  <span class="Keyword">elif</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Keyword">distinct</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Keyword">elif</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Keyword">distinct</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="类型关系-子类型关系" href="#类型关系-子类型关系">子类型关系</a></h2><p>如果对象 <tt class="docutils literal"><span class="pre">a</span></tt> 继承自 <tt class="docutils literal"><span class="pre">b</span></tt>, <tt class="docutils literal"><span class="pre">a</span></tt> 是 <tt class="docutils literal"><span class="pre">b</span></tt> 的类型。 这种了类型关系扩展到 <tt class="docutils literal"><span class="pre">var</span></tt>, <tt class="docutils literal"><span class="pre">ref</span></tt>, <tt class="docutils literal"><span class="pre">ptr</span></tt> :</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">kind</span><span class="Punctuation">:</span>
    <span class="Keyword">case</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span>
    <span class="Keyword">of</span> <span class="Keyword">object</span><span class="Punctuation">:</span>
      <span class="Keyword">var</span> <span class="Identifier">aa</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span>
      <span class="Keyword">while</span> <span class="Identifier">aa</span> <span class="Operator">!=</span> <span class="Keyword">nil</span> <span class="Keyword">and</span> <span class="Identifier">aa</span> <span class="Operator">!=</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">aa</span> <span class="Operator">=</span> <span class="Identifier">aa</span><span class="Operator">.</span><span class="Identifier">baseType</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">aa</span> <span class="Operator">==</span> <span class="Identifier">b</span>
    <span class="Keyword">of</span> <span class="Keyword">var</span><span class="Punctuation">,</span> <span class="Keyword">ref</span><span class="Punctuation">,</span> <span class="Keyword">ptr</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="类型关系-可转换关系" href="#类型关系-可转换关系">可转换关系</a></h2><p>类型 <tt class="docutils literal"><span class="pre">a</span></tt> 可 <strong>隐式</strong> 转换到类型 <tt class="docutils literal"><span class="pre">b</span></tt> 如果下列算法返回真：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">isImplicitlyConvertible</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Keyword">or</span> <span class="Identifier">isCovariant</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">case</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span>
  <span class="Keyword">of</span> <span class="Identifier">int</span><span class="Punctuation">:</span>     <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int8</span><span class="Punctuation">,</span> <span class="Identifier">int16</span><span class="Punctuation">,</span> <span class="Identifier">int32</span><span class="Punctuation">,</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">uint</span><span class="Punctuation">,</span> <span class="Identifier">uint8</span><span class="Punctuation">,</span> <span class="Identifier">uint16</span><span class="Punctuation">,</span>
                             <span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">,</span> <span class="Identifier">float32</span><span class="Punctuation">,</span> <span class="Identifier">float64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">int8</span><span class="Punctuation">:</span>    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int16</span><span class="Punctuation">,</span> <span class="Identifier">int32</span><span class="Punctuation">,</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">int16</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int32</span><span class="Punctuation">,</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">int32</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint</span><span class="Punctuation">:</span>    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint8</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint16</span><span class="Punctuation">,</span> <span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint16</span><span class="Punctuation">:</span>  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint32</span><span class="Punctuation">:</span>  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">float</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float32</span><span class="Punctuation">,</span> <span class="Identifier">float64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">float32</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float64</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">float64</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float32</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">seq</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">openArray</span> <span class="Keyword">and</span> <span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span>
  <span class="Keyword">of</span> <span class="Identifier">array</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">openArray</span> <span class="Keyword">and</span> <span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span>
    <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span> <span class="Operator">==</span> <span class="Identifier">char</span> <span class="Keyword">and</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Operator">.</span><span class="Identifier">rangeA</span> <span class="Operator">==</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">cstring</span>
  <span class="Keyword">of</span> <span class="Identifier">cstring</span><span class="Punctuation">,</span> <span class="Keyword">ptr</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">pointer</span>
  <span class="Keyword">of</span> <span class="Identifier">string</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">cstring</span></pre><p>Nim为 <tt class="docutils literal"><span class="pre">范围</span></tt> 类型构造函数执行了隐式转换。</p>
<p>设 <tt class="docutils literal"><span class="pre">a0</span></tt>, <tt class="docutils literal"><span class="pre">b0</span></tt> 为类型 <tt class="docutils literal"><span class="pre">T</span></tt>.</p>
<p>设 <tt class="docutils literal"><span class="pre">A = range[a0..b0]</span></tt> 为实参类型, <tt class="docutils literal"><span class="pre">F</span></tt> 正式的形参类型。 从 <tt class="docutils literal"><span class="pre">A</span></tt> 到 <tt class="docutils literal"><span class="pre">F</span></tt> 存在隐式转换，如果 <tt class="docutils literal"><span class="pre">a0 &gt;= low(F) 且 b0 &lt;= high(F)</span></tt> 且 <tt class="docutils literal"><span class="pre">T</span></tt> 各 <tt class="docutils literal"><span class="pre">F</span></tt> 是有符号或无符号整型。</p>
<p>如果以下算法返回true，则类型 <tt class="docutils literal"><span class="pre">a</span></tt>  可 <strong>显式</strong> 转换为类型 <tt class="docutils literal"><span class="pre">b</span></tt> ：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">isIntegralType</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">isOrdinal</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">)</span> <span class="Keyword">or</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float</span><span class="Punctuation">,</span> <span class="Identifier">float32</span><span class="Punctuation">,</span> <span class="Identifier">float64</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">isExplicitlyConvertible</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">false</span>
  <span class="Keyword">if</span> <span class="Identifier">isImplicitlyConvertible</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">if</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">if</span> <span class="Identifier">isIntegralType</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Keyword">and</span> <span class="Identifier">isIntegralType</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">if</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Keyword">or</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span></pre><p>可转换关系可以通过用户定义的类型 <span id="converter_1">converter</span> 来放宽。</p>
<pre class="listing"><span class="Keyword">converter</span> <span class="Identifier">toInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">ord</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">chr</span><span class="Punctuation">:</span> <span class="Identifier">char</span> <span class="Operator">=</span> <span class="CharLit">'a'</span>

<span class="Comment"># 隐式转换发生在这里</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">chr</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Comment"># =&gt; 97</span>
<span class="Comment"># 你也可以使用显式转换</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">chr</span><span class="Operator">.</span><span class="Identifier">toInt</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Comment"># =&gt; 97</span></pre><p>如果 <tt class="docutils literal"><span class="pre">a</span></tt> 是左值并且 <tt class="docutils literal"><span class="pre">typeEqualsOrDistinct(T, type(a))</span></tt> 成立， 类型转换 <tt class="docutils literal"><span class="pre">T(a)</span></tt> 也是左值。</p>

<h2><a class="toc-backref" id="类型关系-赋值兼容性" href="#类型关系-赋值兼容性">赋值兼容性</a></h2><p>表达式 <tt class="docutils literal"><span class="pre">b</span></tt> 可以赋给表达式 <tt class="docutils literal"><span class="pre">a</span></tt> 如果 <tt class="docutils literal"><span class="pre">a</span></tt> 是 <tt class="docutils literal"><span class="pre">左值</span></tt> 并且 <tt class="docutils literal"><span class="pre">isImplicitlyConvertible(b.typ, a.typ)</span></tt> 成立。</p>

<h1><a class="toc-backref" id="重载解析" href="#重载解析">重载解析</a></h1><p>在调用 <tt class="docutils literal"><span class="pre">p(args)</span></tt> 中选择匹配最佳的例程 <tt class="docutils literal"><span class="pre">p</span></tt> 。 如果多个例程同样匹配，则在语义分析期间报告歧义。</p>
<p>args中的每个arg都需要匹配。参数可以匹配的方式有多种不同的类别。 设 <tt class="docutils literal"><span class="pre">f</span></tt> 是形式参数的类型， <tt class="docutils literal"><span class="pre">a</span></tt> 是参数的类型。</p>
<ol class="simple"><li>准确匹配: <tt class="docutils literal"><span class="pre">a</span></tt> 和 <tt class="docutils literal"><span class="pre">f</span></tt> 是相同类型。</li>
<li>字面匹配: <tt class="docutils literal"><span class="pre">a</span></tt> 是值为 <tt class="docutils literal"><span class="pre">v</span></tt> 的整型字面值， <tt class="docutils literal"><span class="pre">f</span></tt> 是有符号或无符号整型 <tt class="docutils literal"><span class="pre">v</span></tt> 在 <tt class="docutils literal"><span class="pre">f</span></tt> 的范围里. 或:  <tt class="docutils literal"><span class="pre">a</span></tt> 是值为 <tt class="docutils literal"><span class="pre">v``的浮点字面值， ``f</span></tt> 是浮点类型 <tt class="docutils literal"><span class="pre">v</span></tt> 在 <tt class="docutils literal"><span class="pre">f</span></tt> 的范围里。</li>
<li>泛型匹配: <tt class="docutils literal"><span class="pre">f</span></tt> 是泛型类型且 <tt class="docutils literal"><span class="pre">a</span></tt> 匹配, 例如 <tt class="docutils literal"><span class="pre">a</span></tt> 是 <tt class="docutils literal"><span class="pre">int</span></tt> 且 <tt class="docutils literal"><span class="pre">f</span></tt> 是泛型限制 (受限) 形参类型 (像 <tt class="docutils literal"><span class="pre">[T]</span></tt> 或 <tt class="docutils literal"><span class="pre">[T: int|char]</span></tt>.</li>
<li>子范围或子类型匹配： <tt class="docutils literal"><span class="pre">a</span></tt> is a <tt class="docutils literal"><span class="pre">range[T]</span></tt> and <tt class="docutils literal"><span class="pre">T</span></tt> matches <tt class="docutils literal"><span class="pre">f</span></tt> exactly. Or: <tt class="docutils literal"><span class="pre">a</span></tt> is a subtype of <tt class="docutils literal"><span class="pre">f</span></tt>.</li>
<li>整数转换匹配: <tt class="docutils literal"><span class="pre">a</span></tt> 可转换为 <tt class="docutils literal"><span class="pre">f</span></tt> 且 <tt class="docutils literal"><span class="pre">f</span></tt> 和 <tt class="docutils literal"><span class="pre">a</span></tt> 是同样的整数或浮点类型。</li>
<li>转换匹配: <tt class="docutils literal"><span class="pre">a</span></tt> 可能通过用户定义的转换器转换为 <tt class="docutils literal"><span class="pre">f</span></tt> 。</li>
</ol>
<p>这些匹配类别具有优先级：完全匹配优于字面值匹配，并且优于通用匹配等。 在下面的 <tt class="docutils literal"><span class="pre">count(p, m)</span></tt> 计算 <tt class="docutils literal"><span class="pre">m</span></tt> 匹配过程 <tt class="docutils literal"><span class="pre">p</span></tt> 的匹配数。</p>
<p>如果下列算法返回真，例程 <tt class="docutils literal"><span class="pre">p</span></tt> 比 <tt class="docutils literal"><span class="pre">q</span></tt> 更匹配：</p>
<blockquote><p><dl class="docutils"><dt>for each matching category m in [&quot;exact match&quot;, &quot;literal match&quot;,</dt>
<dd>&quot;generic match&quot;, &quot;subtype match&quot;, &quot;integral match&quot;, &quot;conversion match&quot;]:</dd>
<dt></dt>
<dd>if count(p, m) &gt; count(q, m): return true<dl class="docutils"><dt>elif count(p, m) == count(q, m):</dt>
<dd>discard &quot;continue with next category m&quot;</dd>
<dt>else:</dt>
<dd>return false</dd>
</dl>
</dd>
</dl>
<p>return &quot;ambiguous&quot;</p>
</p></blockquote>
<p>一些示例：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;int&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">takesInt</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;T&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int16</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;int16&quot;</span>

<span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># &quot;int&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int32</span>
<span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># &quot;T&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int16</span>
<span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Comment"># &quot;int16&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">4</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">z</span><span class="Punctuation">)</span> <span class="Comment"># &quot;T&quot;</span></pre><p>如果算法返回 &quot;歧义&quot; 则执行进一步消歧: 如果参数 <tt class="docutils literal"><span class="pre">a</span></tt> 通过子类型关系匹配 <tt class="docutils literal"><span class="pre">p</span></tt> 的参数类型 <tt class="docutils literal"><span class="pre">f</span></tt> 和 <tt class="docutils literal"><span class="pre">q</span></tt> 的 <tt class="docutils literal"><span class="pre">g</span></tt> ，则考虑继承深度：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">A</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
  <span class="Identifier">B</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">A</span>
  <span class="Identifier">C</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">B</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;A&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">:</span> <span class="Identifier">B</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;B&quot;</span>

<span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">C</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Comment"># not ambiguous, calls 'B', not 'A' since B is a subtype of A</span>
<span class="Comment"># but not vice versa:</span>
<span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">pp</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">obj2</span><span class="Punctuation">:</span> <span class="Identifier">B</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;A B&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">pp</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">:</span> <span class="Identifier">B</span><span class="Punctuation">,</span> <span class="Identifier">obj2</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;B A&quot;</span>

<span class="Comment"># but this is ambiguous:</span>
<span class="Identifier">pp</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">)</span></pre><p>同样，对于通用匹配，匹配的结果中首选最特化的泛型类型：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">gen</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Keyword">ref</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;ref ref T&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">gen</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;ref T&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">gen</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;T&quot;</span>

<span class="Keyword">var</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">int</span>
<span class="Identifier">gen</span><span class="Punctuation">(</span><span class="Identifier">ri</span><span class="Punctuation">)</span> <span class="Comment"># &quot;ref T&quot;</span></pre>
<h2><a class="toc-backref" id="重载解析-基于-var-t-的重载" href="#重载解析-基于-var-t-的重载">基于 'var T' 的重载</a></h2><p>如果形式参数 <tt class="docutils literal"><span class="pre">f</span></tt> 是除了普通类型检查外的 <tt class="docutils literal"><span class="pre">var T</span></tt> 类型， 则检查实参是否 <span id="左值_2">左值</span> 。 <tt class="docutils literal"><span class="pre">var T</span></tt> 比 <tt class="docutils literal"><span class="pre">T</span></tt> 更好地匹配。</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">sayHi</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Comment"># 匹配非var整型</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">x</span>
<span class="Keyword">proc</span> <span class="Identifier">sayHi</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Comment"># 匹配var整型</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Operator">+</span> <span class="DecNumber">10</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">sayHello</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">m</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Comment"># 可改变的x</span>
  <span class="Identifier">echo</span> <span class="Identifier">sayHi</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 匹配sayHi的非var版本</span>
  <span class="Identifier">echo</span> <span class="Identifier">sayHi</span><span class="Punctuation">(</span><span class="Identifier">m</span><span class="Punctuation">)</span> <span class="Comment"># 匹配sayHi的var版本</span>

<span class="Identifier">sayHello</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span> <span class="Comment"># 3</span>
            <span class="Comment"># 13</span></pre>
<h2><a class="toc-backref" id="重载解析-无类型的延迟类型解析" href="#重载解析-无类型的延迟类型解析">无类型的延迟类型解析</a></h2><p><strong>注意</strong>: <span id="未解析_1">未解析</span> 表达式是为没有执行符号查找和类型检查的表达式。</p>
<p>由于未声明为 <tt class="docutils literal"><span class="pre">立即</span></tt> 的模板和宏参与重载分析，因此必须有一种方法将未解析的表达式传递给模板或宏。</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">rem</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">rem</span> <span class="Identifier">unresolvedExpression</span><span class="Punctuation">(</span><span class="Identifier">undeclaredIdentifier</span><span class="Punctuation">)</span></pre><p><tt class="docutils literal"><span class="pre">untyped</span></tt> 类型的参数总是匹配任何参数（只要有任何参数传递给它）。</p>
<p>但是必须注意，因为其他重载可能触发参数的解析：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">rem</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Identifier">rem</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Comment"># 未声明的标识符：'unresolvedExpression'</span>
<span class="Identifier">rem</span> <span class="Identifier">unresolvedExpression</span><span class="Punctuation">(</span><span class="Identifier">undeclaredIdentifier</span><span class="Punctuation">)</span></pre><p><tt class="docutils literal"><span class="pre">untyped</span></tt> 和 <tt class="docutils literal"><span class="pre">varargs [untyped]</span></tt> 是这种意义上唯一的惰性元类型，其他元类型 <tt class="docutils literal"><span class="pre">typed</span></tt> 和 <tt class="docutils literal"><span class="pre">typedesc</span></tt> 并不是惰性的。</p>

<h2><a class="toc-backref" id="重载解析-可变参数匹配" href="#重载解析-可变参数匹配">可变参数匹配</a></h2><p>见 <a class="reference external" href="#types-varargs">Varargs</a>.</p>

<h1><a class="toc-backref" id="语句和表达式" href="#语句和表达式">语句和表达式</a></h1><p>Nim使用通用语句/表达式范例：与表达式相比，语句不会产生值。 但是，有些表达式是语句。</p>
<p>语句分为 <span id="简单语句_1">简单语句</span> 和 <span id="复杂语句_1">复杂语句</span> 。 简单语句是不能包含像赋值，调用或者 <tt class="docutils literal"><span class="pre">return</span></tt> 的语句； 复杂语句可以包含其它语句。 为了避免 <span id="dangling-else问题_1">dangling else问题</span>, 复杂语句必须缩进。 细节可以在语法中找到。</p>

<h2><a class="toc-backref" id="语句和表达式-语句列表表达式" href="#语句和表达式-语句列表表达式">语句列表表达式</a></h2><p>语句也可以出现在类似于 <tt class="docutils literal"><span class="pre">(stmt1; stmt2; ...; ex)</span></tt> 的表达式上下文中。 语句也可以出现在表达式上下文中。 这叫做语句列表表达式或 <tt class="docutils literal"><span class="pre">(;)</span></tt> 。 <tt class="docutils literal"><span class="pre">(stmt1; stmt2; ...; ex)</span></tt> 的类型是 <tt class="docutils literal"><span class="pre">ex</span></tt> 的类型。 所有其他语句必须是 <tt class="docutils literal"><span class="pre">void</span></tt> 类型。 (可以用 <tt class="docutils literal"><span class="pre">discard</span></tt> 生成 <tt class="docutils literal"><span class="pre">void</span></tt> 类型。) <tt class="docutils literal"><span class="pre">(;)</span></tt> 不引入新作用域。</p>

<h2><a class="toc-backref" id="语句和表达式-discard表达式" href="#语句和表达式-discard表达式">Discard表达式</a></h2><p>示例:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>

<span class="Keyword">discard</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># 丢弃 `p` 的返回值</span></pre><p><tt class="docutils literal"><span class="pre">discard</span></tt> 语句评估其副作用的表达式，并丢弃表达式的结果。</p>
<p>在不使用discard语句的情况下忽略过程的返回值是一个静态错误。</p>
<p>如果使用 <span id="discardable_1">discardable</span> 编译指示声明了被调用的proc或iterator，则可以隐式忽略返回值：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">discardable</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>

<span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># now valid</span></pre><p>空 <tt class="docutils literal"><span class="pre">discard</span></tt> 语句通常用作null语句:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">classify</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">case</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">of</span> <span class="Identifier">SymChars</span><span class="Punctuation">,</span> <span class="CharLit">'_'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;an identifier&quot;</span>
  <span class="Keyword">of</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;a number&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">discard</span></pre>
<h2><a class="toc-backref" id="语句和表达式-void上下文" href="#语句和表达式-void上下文">Void上下文</a></h2><p>在语句列表中，除最后一个表达式之外的每个表达式都需要具有类型 <tt class="docutils literal"><span class="pre">void</span></tt> 。 除了这个规则之外，对内置 <tt class="docutils literal"><span class="pre">result</span></tt> 符号的赋值也会触发后续表达式的强制 <tt class="docutils literal"><span class="pre">void</span></tt> 上下文：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">invalid</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;foo&quot;</span>
  <span class="StringLit">&quot;invalid&quot;</span>  <span class="Comment"># 错误: 'string' 类型值必须丢弃</span></pre><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">valid</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">317</span>
  <span class="StringLit">&quot;valid&quot;</span></pre>
<h2><a class="toc-backref" id="语句和表达式-var语句" href="#语句和表达式-var语句">Var语句</a></h2><p>Var语句声明新的局部变量和全局变量并初始化它们。 逗号分隔的变量列表可用于指定相同类型的变量：</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre><p>如果给出初始值设定项，则可以省略该类型：该变量的类型与初始化表达式的类型相同。 如果没有初始化表达式，变量总是使用默认值初始化。 默认值取决于类型，并且在二进制中始终为零。</p>
<table border="1" class="docutils"><tr><th>类型</th><th>默认值</th></tr>
<tr><td>any integer type</td><td>0</td></tr>
<tr><td>any float</td><td>0.0</td></tr>
<tr><td>char</td><td>'\0'</td></tr>
<tr><td>bool</td><td>false</td></tr>
<tr><td>ref or pointer type</td><td>nil</td></tr>
<tr><td>procedural type</td><td>nil</td></tr>
<tr><td>sequence</td><td><tt class="docutils literal"><span class="pre">@[]</span></tt></td></tr>
<tr><td>string</td><td><tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt></td></tr>
<tr><td>tuple[x: A, y: B, ...]</td><td>(default(A), default(B), ...) (analogous for objects)</td></tr>
<tr><td>array[0..., T]</td><td>[default(T), ...]</td></tr>
<tr><td>range[T]</td><td>default(T); this may be out of the valid range</td></tr>
<tr><td>T = enum</td><td>cast<a class="reference external" href="0">T</a>; this may be an invalid value</td></tr>
</table><p>出于优化原因，可以使用 <span id="noinit_1">noinit</span> 编译指示来避免隐式初始化:</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">a</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">noInit</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">1023</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">]</span></pre><p>如果一个proc用 <tt class="docutils literal"><span class="pre">noinit</span></tt> 编译指示注释，则指的是它隐含的 <tt class="docutils literal"><span class="pre">result</span></tt> 变量：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">returnUndefinedValue</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">noinit</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre><p>隐式初始化可以用 <span id="requiresinit_1">requiresInit</span> 类型编译指示阻止。 编译器需要对对象及其所有字段进行显式初始化。 然而它执行 <span id="控制流分析_1">控制流分析</span> 证明变量已经初始化并且不依赖于语法属性：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MyObject</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">requiresInit</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 以下内容有效：</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">MyObject</span>
  <span class="Keyword">if</span> <span class="Identifier">someCondition</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Comment"># use x</span></pre>
<h2><a class="toc-backref" id="语句和表达式-let语句" href="#语句和表达式-let语句">Let语句</a></h2><p><tt class="docutils literal"><span class="pre">let</span></tt> 语句声明了新的本地和全局 <span id="单次赋值_1">单次赋值</span> 变量并绑定值。 语法与 <tt class="docutils literal"><span class="pre">var</span></tt> 语句的语法相同，只是关键字 <tt class="docutils literal"><span class="pre">var</span></tt> 被替换为关键字 <tt class="docutils literal"><span class="pre">let</span></tt> 。 Let变量不是左值因此不能传递给 <tt class="docutils literal"><span class="pre">var</span></tt> 参数，也不能采用它们的地址。他们无法分配新值。</p>
<p>对于let变量，可以使用与普通变量相同的编译指示。</p>

<h2><a class="toc-backref" id="语句和表达式-元组解包" href="#语句和表达式-元组解包">元组解包</a></h2><p>在 <tt class="docutils literal"><span class="pre">var</span></tt> 或 <tt class="docutils literal"><span class="pre">let</span></tt> 语句中可以执行元组解包。 特殊标识符 <tt class="docutils literal"><span class="pre">_</span></tt> 可以用来忽略元组的某些部分：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">returnsTuple</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span>

<span class="Keyword">let</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">_</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">returnsTuple</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="语句和表达式-常量段" href="#语句和表达式-常量段">常量段</a></h2><p>const部分声明其值为常量表达式的常量：</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">strutils</span>
<span class="Keyword">const</span>
  <span class="Identifier">roundPi</span> <span class="Operator">=</span> <span class="FloatNumber">3.1415</span>
  <span class="Identifier">constEval</span> <span class="Operator">=</span> <span class="Identifier">contains</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'b'</span><span class="Punctuation">)</span> <span class="Comment"># computed at compile time!</span></pre><p>声明后，常量符号可用作常量表达式。</p>
<p>详见 <a class="reference external" href="#constants-and-constant-expressions">Constants and Constant Expressions</a> 。</p>

<h2><a class="toc-backref" id="语句和表达式-静态语句和表达式" href="#语句和表达式-静态语句和表达式">静态语句和表达式</a></h2><p>静态语句/表达式显式需要编译时执行。 甚至一些具有副作用的代码也允许在静态块中：</p>
<pre class="listing"><span class="Keyword">static</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;echo at compile time&quot;</span></pre><p>在编译时可以执行哪些Nim代码存在限制; 详见 <a class="reference external" href="#restrictions-on-compileminustime-execution">Restrictions on Compile-Time Execution</a> 。 如果编译器无法在编译时执行块，那么这是一个静态错误。</p>

<h2><a class="toc-backref" id="语句和表达式-if语句" href="#语句和表达式-if语句">If语句</a></h2><p>示例：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>

<span class="Keyword">if</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;Andreas&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;What a nice name!&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Don't you have a name?&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Boring name...&quot;</span></pre><p><tt class="docutils literal"><span class="pre">if</span></tt> 语句是在控制流中创建分支的简单方法：计算关键字 <tt class="docutils literal"><span class="pre">if</span></tt> 之后的表达式，如果为真，则执行 <tt class="docutils literal"><span class="pre">:</span></tt> 之后的相应语句。 这一直持续到最后一个 <tt class="docutils literal"><span class="pre">elif</span></tt> 。 如果所有条件都失败，则执行 <tt class="docutils literal"><span class="pre">else</span></tt> 部分。 如果没有 <tt class="docutils literal"><span class="pre">else</span></tt> 部分，则继续执行下一个语句。</p>
<p>在 <tt class="docutils literal"><span class="pre">if</span></tt> 语句中，新的作用域在 <tt class="docutils literal"><span class="pre">if</span></tt> 或 <tt class="docutils literal"><span class="pre">elif</span></tt> 或 <tt class="docutils literal"><span class="pre">else</span></tt> 关键字之后立即开始，并在相应的 <em>then</em> 块之后结束。</p>
<p>出于可视化目的，作用域已包含在 <tt class="docutils literal"><span class="pre">{| |}</span></tt> 在以下示例中</p>
<p>示例：</p>
<pre class="listing"><span class="Keyword">if</span> <span class="Punctuation">{</span><span class="Operator">|</span> <span class="Punctuation">(</span><span class="Keyword">let</span> <span class="Identifier">m</span> <span class="Operator">=</span> <span class="Identifier">input</span> <span class="Operator">=~</span> <span class="RawData">re&quot;(\w+)=\w+&quot;</span><span class="Punctuation">;</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">isMatch</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;key &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="StringLit">&quot; value &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span>  <span class="Operator">|</span><span class="Punctuation">}</span>
<span class="Keyword">elif</span> <span class="Punctuation">{</span><span class="Operator">|</span> <span class="Punctuation">(</span><span class="Keyword">let</span> <span class="Identifier">m</span> <span class="Operator">=</span> <span class="Identifier">input</span> <span class="Operator">=~</span> <span class="RawData">re&quot;&quot;</span><span class="Punctuation">;</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">isMatch</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;new m in this scope&quot;</span>  <span class="Operator">|</span><span class="Punctuation">}</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Punctuation">{</span><span class="Operator">|</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;m not declared here&quot;</span>  <span class="Operator">|</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="语句和表达式-case语句" href="#语句和表达式-case语句">Case语句</a></h2><p>示例:</p>
<pre class="listing"><span class="Keyword">case</span> <span class="Identifier">readline</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;delete-everything&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;restart-computer&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;permission denied&quot;</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;go-for-a-walk&quot;</span><span class="Punctuation">:</span>     <span class="Identifier">echo</span> <span class="StringLit">&quot;please yourself&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>                   <span class="Identifier">echo</span> <span class="StringLit">&quot;unknown command&quot;</span>

<span class="Comment"># 允许分支缩进; 冒号也是可选的</span>
<span class="Comment"># 在选择表达式后:</span>
<span class="Keyword">case</span> <span class="Identifier">readline</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;delete-everything&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;restart-computer&quot;</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;permission denied&quot;</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;go-for-a-walk&quot;</span><span class="Punctuation">:</span>     <span class="Identifier">echo</span> <span class="StringLit">&quot;please yourself&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>                   <span class="Identifier">echo</span> <span class="StringLit">&quot;unknown command&quot;</span></pre><p><tt class="docutils literal"><span class="pre">case</span></tt> 语句类似于if语句，但它表示多分支选择。</p>
<p>评估关键字 <tt class="docutils literal"><span class="pre">case</span></tt> 之后的表达式，如果它的值在 <em>slicelist</em> 中，则执行在 <tt class="docutils literal"><span class="pre">of</span></tt> 关键字之后的相应语句。</p>
<p>如果该值不在任何给定的 <em>slicelist</em> 中，则执行 <tt class="docutils literal"><span class="pre">else</span></tt> 部分。 如果没有 <tt class="docutils literal"><span class="pre">else</span></tt> 部分而且 <tt class="docutils literal"><span class="pre">expr</span></tt> 可以保持在 <tt class="docutils literal"><span class="pre">slicelist</span></tt> 中的所有可能值，则会发生静态错误。 这仅适用于序数类型的表达式。 <tt class="docutils literal"><span class="pre">expr</span></tt> 的“所有可能的值”由 <tt class="docutils literal"><span class="pre">expr</span></tt> 的类型决定。 为了阻止静态错误，应该使用带有空 <tt class="docutils literal"><span class="pre">discard</span></tt> 语句的 <tt class="docutils literal"><span class="pre">else</span></tt> 部分。</p>
<p>对于非序数类型，不可能列出每个可能的值，因此这些值总是需要 <tt class="docutils literal"><span class="pre">else</span></tt> 部分。</p>
<p>因为在语义分析期间检查case语句的详尽性，所以每个 <tt class="docutils literal"><span class="pre">of</span></tt> 分支中的值必须是常量表达式。 此限制还允许编译器生成更高性能的代码。</p>
<p>作为一种特殊的语义扩展，case语句的 <tt class="docutils literal"><span class="pre">of</span></tt> 分支中的表达式可以计算为集合或数组构造函数;然后将集合或数组扩展为其元素列表：</p>
<pre class="listing"><span class="Keyword">const</span>
  <span class="Identifier">SymChars</span><span class="Punctuation">:</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'A'</span><span class="Operator">..</span><span class="CharLit">'Z'</span><span class="Punctuation">,</span> <span class="CharLit">'\x80'</span><span class="Operator">..</span><span class="CharLit">'\xFF'</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">classify</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">case</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">of</span> <span class="Identifier">SymChars</span><span class="Punctuation">,</span> <span class="CharLit">'_'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;an identifier&quot;</span>
  <span class="Keyword">of</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;a number&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;other&quot;</span>

<span class="Comment"># is equivalent to:</span>
<span class="Keyword">proc</span> <span class="Identifier">classify</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">case</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">of</span> <span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'A'</span><span class="Operator">..</span><span class="CharLit">'Z'</span><span class="Punctuation">,</span> <span class="CharLit">'\x80'</span><span class="Operator">..</span><span class="CharLit">'\xFF'</span><span class="Punctuation">,</span> <span class="CharLit">'_'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;an identifier&quot;</span>
  <span class="Keyword">of</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;a number&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;other&quot;</span></pre>
<h2><a class="toc-backref" id="语句和表达式-when语句" href="#语句和表达式-when语句">When语句</a></h2><p>示例：</p>
<pre class="listing"><span class="Keyword">when</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">2</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;running on a 16 bit system!&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">4</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;running on a 32 bit system!&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">8</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;running on a 64 bit system!&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;cannot happen!&quot;</span></pre><p><tt class="docutils literal"><span class="pre">when</span></tt> 语句几乎与 <tt class="docutils literal"><span class="pre">if</span></tt> 语句完全相同，但有一些例外：</p>
<ul class="simple"><li>每个条件 (<tt class="docutils literal"><span class="pre">expr</span></tt>) 必须是一个类型为 <tt class="docutils literal"><span class="pre">bool</span></tt> 的常量表达式。</li>
<li>语句不打开新作用域。</li>
<li>属于计算结果为true的表达式的语句由编译器翻译，其他语句不检查语义。</li>
</ul>
<p><tt class="docutils literal"><span class="pre">when</span></tt> 语句启用条件编译技术。 作为一种特殊的语法扩展， <tt class="docutils literal"><span class="pre">when</span></tt> 结构也可以在 <tt class="docutils literal"><span class="pre">object</span></tt> 定义中使用。</p>

<h2><a class="toc-backref" id="语句和表达式-when-nimvm语句" href="#语句和表达式-when-nimvm语句">When nimvm语句</a></h2><p><tt class="docutils literal"><span class="pre">nimvm</span></tt> 是一个特殊的符号，可以用作 <tt class="docutils literal"><span class="pre">when nimvm</span></tt> 语句的表达式来区分编译时和可执行文件之间的执行路径。</p>
<p>示例：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">someProcThatMayRunInCompileTime</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">when</span> <span class="Identifier">nimvm</span><span class="Punctuation">:</span>
    <span class="Comment"># 编译时采用这个分支。</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Comment"># 可执行文件中采用这个分支</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">false</span>
<span class="Keyword">const</span> <span class="Identifier">ctValue</span> <span class="Operator">=</span> <span class="Identifier">someProcThatMayRunInCompileTime</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">let</span> <span class="Identifier">rtValue</span> <span class="Operator">=</span> <span class="Identifier">someProcThatMayRunInCompileTime</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">ctValue</span> <span class="Operator">==</span> <span class="Identifier">true</span><span class="Punctuation">)</span>
<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">rtValue</span> <span class="Operator">==</span> <span class="Identifier">false</span><span class="Punctuation">)</span></pre><p><tt class="docutils literal"><span class="pre">when nimvm</span></tt> 语句必须满足以下要求：</p>
<ul class="simple"><li>它的表达式必须是 <tt class="docutils literal"><span class="pre">nimvm</span></tt> 。不允许更多的复杂表达式。</li>
<li>它必须不含有 <tt class="docutils literal"><span class="pre">elif</span></tt> 分支。</li>
<li>必须含有 <tt class="docutils literal"><span class="pre">else</span></tt> 分支。</li>
<li>分支中的代码不得影响 <tt class="docutils literal"><span class="pre">when nimvm</span></tt> 语句后面的代码的语义。例如它不能定义后续代码中使用的符号。</li>
</ul>

<h2><a class="toc-backref" id="语句和表达式-return语句" href="#语句和表达式-return语句">Return语句</a></h2><p>示例：</p>
<pre class="listing"><span class="Keyword">return</span> <span class="DecNumber">40</span><span class="Operator">+</span><span class="DecNumber">2</span></pre><p><tt class="docutils literal"><span class="pre">return</span></tt> 语句结束当前过程的执行。</p>
<p>它只允许在程序中使用。如果有一个 <tt class="docutils literal"><span class="pre">expr</span></tt> ，这是一个语法糖：</p>
<pre class="listing"><span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">expr</span>
<span class="Keyword">return</span> <span class="Identifier">result</span></pre><p>如果proc有返回类型，没有表达式的 <tt class="docutils literal"><span class="pre">return</span></tt> 是 <tt class="docutils literal"><span class="pre">return result</span></tt> 的简短表示法。 <span id="result_1">result</span> 变量始终是过程的返回值。 它由编译器自动声明。 作为所有变量， <tt class="docutils literal"><span class="pre">result</span></tt> 被初始化为（二进制）零：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">returnZero</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># 隐式返回0</span></pre>
<h2><a class="toc-backref" id="语句和表达式-yield语句" href="#语句和表达式-yield语句">Yield语句</a></h2><p>示例：</p>
<pre class="listing"><span class="Keyword">yield</span> <span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span></pre><p>在迭代器中使用 <tt class="docutils literal"><span class="pre">yield</span></tt> 语句而不是 <tt class="docutils literal"><span class="pre">return</span></tt> 语句。 它仅在迭代器中有效。执行返回到调用迭代器的for循环体。 Yield不会结束迭代过程，但是如果下一次迭代开始，则执行会返回到迭代器。 有关更多信息，请参阅有关迭代器 (<a class="reference external" href="#迭代器和for语句">迭代器和for语句</a>) 的部分。</p>

<h2><a class="toc-backref" id="语句和表达式-block语句" href="#语句和表达式-block语句">Block语句</a></h2><p>示例：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">found</span> <span class="Operator">=</span> <span class="Identifier">false</span>
<span class="Keyword">block</span> <span class="Identifier">myblock</span><span class="Punctuation">:</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">3</span><span class="Punctuation">:</span>
    <span class="Keyword">for</span> <span class="Identifier">j</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">3</span><span class="Punctuation">:</span>
      <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">j</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="DecNumber">7</span><span class="Punctuation">:</span>
        <span class="Identifier">found</span> <span class="Operator">=</span> <span class="Identifier">true</span>
        <span class="Keyword">break</span> <span class="Identifier">myblock</span> <span class="Comment"># 跳出两个for循环块</span>
<span class="Identifier">echo</span> <span class="Identifier">found</span></pre><p>块语句是一种将语句分组到（命名） <tt class="docutils literal"><span class="pre">block</span></tt> 的方法。 在块内，允许 <tt class="docutils literal"><span class="pre">break</span></tt> 语句立即跳出块。 <tt class="docutils literal"><span class="pre">break</span></tt> 语句可以包含周围块的名称，以指定要跳出的块。</p>

<h2><a class="toc-backref" id="语句和表达式-break语句" href="#语句和表达式-break语句">Break语句</a></h2><p>示例：</p>
<pre class="listing"><span class="Keyword">break</span></pre><p><tt class="docutils literal"><span class="pre">break</span></tt> 语句用于立即跳出块。 如果给出 <tt class="docutils literal"><span class="pre">symbol</span></tt> ，则它是要跳出的封闭块的名称。 如果不存在，则跳出最里面的块。</p>

<h2><a class="toc-backref" id="语句和表达式-while语句" href="#语句和表达式-while语句">While语句</a></h2><p>示例：</p>
<pre class="listing"><span class="Identifier">echo</span> <span class="StringLit">&quot;Please tell me your password:&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">pw</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">while</span> <span class="Identifier">pw</span> <span class="Operator">!=</span> <span class="StringLit">&quot;12345&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Wrong password! Next try:&quot;</span>
  <span class="Identifier">pw</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span></pre><p>执行 <tt class="docutils literal"><span class="pre">while</span></tt> 语句直到 <tt class="docutils literal"><span class="pre">expr</span></tt> 计算结果为false。 无尽的循环没有错误。 <tt class="docutils literal"><span class="pre">while</span></tt> 语句打开一个 '隐式块'，这样它们就可以用 <tt class="docutils literal"><span class="pre">break</span></tt> 语句跳出。</p>

<h2><a class="toc-backref" id="语句和表达式-continue语句" href="#语句和表达式-continue语句">Continue语句</a></h2><p>一个 <tt class="docutils literal"><span class="pre">continue</span></tt> 语句导致周围循环结构的下一次迭代。 它只允许在一个循环中。 continue语句是嵌套块的语法糖：</p>
<pre class="listing"><span class="Keyword">while</span> <span class="Identifier">expr1</span><span class="Punctuation">:</span>
  <span class="Identifier">stmt1</span>
  <span class="Keyword">continue</span>
  <span class="Identifier">stmt2</span></pre><p>Is equivalent to:</p>
<pre class="listing"><span class="Keyword">while</span> <span class="Identifier">expr1</span><span class="Punctuation">:</span>
  <span class="Keyword">block</span> <span class="Identifier">myBlockName</span><span class="Punctuation">:</span>
    <span class="Identifier">stmt1</span>
    <span class="Keyword">break</span> <span class="Identifier">myBlockName</span>
    <span class="Identifier">stmt2</span></pre>
<h2><a class="toc-backref" id="语句和表达式-汇编语句" href="#语句和表达式-汇编语句">汇编语句</a></h2><p>不安全的 <tt class="docutils literal"><span class="pre">asm</span></tt> 语句支持将汇编程序代码直接嵌入到Nim代码中。</p>
<p>汇编程序代码中引用Nim标识符的标识符应包含在特殊字符中，该字符可在语句的编译指示中指定。默认的特殊字符是 <tt class="docutils literal"><span class="pre">'`'</span></tt>  ：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">stackTrace</span><span class="Punctuation">:</span><span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">addInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># a in eax, and b in edx</span>
  <span class="Keyword">asm</span> <span class="LongStringLit">&quot;&quot;&quot;
      mov eax, `a`
      add eax, `b`
      jno theEnd
      call `raiseOverflow`
    theEnd:
  &quot;&quot;&quot;</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>如果使用GNU汇编器，则会自动插入引号和换行符：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">addInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">asm</span> <span class="LongStringLit">&quot;&quot;&quot;
    addl %%ecx, %%eax
    jno 1
    call `raiseOverflow`
    1:
    :&quot;=a&quot;(`result`)
    :&quot;a&quot;(`a`), &quot;c&quot;(`b`)
  &quot;&quot;&quot;</span></pre><p>替代:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">addInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">asm</span> <span class="LongStringLit">&quot;&quot;&quot;
    &quot;addl %%ecx, %%eax\n&quot;
    &quot;jno 1\n&quot;
    &quot;call `raiseOverflow`\n&quot;
    &quot;1: \n&quot;
    :&quot;=a&quot;(`result`)
    :&quot;a&quot;(`a`), &quot;c&quot;(`b`)
  &quot;&quot;&quot;</span></pre>
<h2><a class="toc-backref" id="语句和表达式-using语句" href="#语句和表达式-using语句">Using语句</a></h2><p>using语句在模块中反复使用相同的参数名称和类型提供了语法上的便利。 Instead of:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Context</span><span class="Punctuation">;</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Keyword">proc</span> <span class="Identifier">bar</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Context</span><span class="Punctuation">;</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">,</span> <span class="Identifier">counter</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Keyword">proc</span> <span class="Identifier">baz</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Context</span><span class="Punctuation">;</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span></pre><p>可以告诉编译器关于名称 <tt class="docutils literal"><span class="pre">c</span></tt> 的参数应默认键入 <tt class="docutils literal"><span class="pre">Context</span></tt> ， <tt class="docutils literal"><span class="pre">n</span></tt> 应该默认为 <tt class="docutils literal"><span class="pre">Node</span></tt> 等的约定：</p>
<pre class="listing"><span class="Keyword">using</span>
  <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Context</span>
  <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
  <span class="Identifier">counter</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Keyword">proc</span> <span class="Identifier">bar</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">,</span> <span class="Identifier">counter</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Keyword">proc</span> <span class="Identifier">baz</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">proc</span> <span class="Identifier">mixedMode</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">;</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 'c' 被推断为 'Context' 类型</span>
  <span class="Comment"># 'n' 被推断为 'Node' 类型</span>
  <span class="Comment"># 'x' and 'y' 是 'int' 类型。</span></pre><p><tt class="docutils literal"><span class="pre">using</span></tt> 部分使用相同的基于缩进的分组语法作为 <tt class="docutils literal"><span class="pre">var</span></tt> 或 <tt class="docutils literal"><span class="pre">let</span></tt> 部分。</p>
<p>请注意， <tt class="docutils literal"><span class="pre">using</span></tt> 不适用于 <tt class="docutils literal"><span class="pre">template</span></tt> ，因为无类型模板参数默认为类型 <tt class="docutils literal"><span class="pre">system.untyped</span></tt> 。</p>
<p>应该使用 <tt class="docutils literal"><span class="pre">using</span></tt> 声明和明确键入的参数混合参数，它们之间需要分号。</p>

<h2><a class="toc-backref" id="语句和表达式-if表达式" href="#语句和表达式-if表达式">If表达式</a></h2><p><tt class="docutils literal"><span class="pre">if表达式</span></tt> 几乎就像一个if语句，但它是一个表达式。 示例：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">x</span> <span class="Operator">&gt;</span> <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="DecNumber">9</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="DecNumber">10</span></pre><p>if表达式总是会产生一个值，所以 <tt class="docutils literal"><span class="pre">else</span></tt> 部分是必需的。 <tt class="docutils literal"><span class="pre">Elif</span></tt> 部分也是允许的。</p>

<h2><a class="toc-backref" id="语句和表达式-when表达式" href="#语句和表达式-when表达式">When表达式</a></h2><p>就像 <tt class="docutils literal"><span class="pre">if表达式</span></tt> ，但对应于when语句。</p>

<h2><a class="toc-backref" id="语句和表达式-case表达式" href="#语句和表达式-case表达式">Case表达式</a></h2><p><tt class="docutils literal"><span class="pre">case表达式</span></tt> 与case语句非常相似：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">favoriteFood</span> <span class="Operator">=</span> <span class="Keyword">case</span> <span class="Identifier">animal</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;dog&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;bones&quot;</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;cat&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;mice&quot;</span>
  <span class="Keyword">elif</span> <span class="Identifier">animal</span><span class="Operator">.</span><span class="RawData">endsWith&quot;whale&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;plankton&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;I'm not sure what to serve, but everybody loves ice cream&quot;</span>
    <span class="StringLit">&quot;ice cream&quot;</span></pre><p>如上例所示，case表达式也可以引入副作用。 当为分支给出多个语句时，Nim将使用最后一个表达式作为结果值。</p>

<h2><a class="toc-backref" id="语句和表达式-block表达式" href="#语句和表达式-block表达式">Block表达式</a></h2><p><tt class="docutils literal"><span class="pre">block表达式</span></tt> 几乎就像一个块语句，但它是一个表达式，它使用块下的最后一个表达式作为值。 它类似于语句列表表达式，但语句列表表达式不会打开新的块作用域。</p>
<pre class="listing"><span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Keyword">block</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">fib</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">]</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">:</span>
    <span class="Identifier">fib</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">fib</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">+</span> <span class="Identifier">fib</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">2</span><span class="Punctuation">]</span>
  <span class="Identifier">fib</span></pre>
<h2><a class="toc-backref" id="语句和表达式-table构造函数" href="#语句和表达式-table构造函数">Table构造函数</a></h2><p>表构造函数是数组构造函数的语法糖：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="StringLit">&quot;key1&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;value1&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;key2&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;key3&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;value2&quot;</span><span class="Punctuation">}</span>

<span class="Comment"># is the same as:</span>
<span class="Punctuation">[</span><span class="Punctuation">(</span><span class="StringLit">&quot;key1&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value1&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="StringLit">&quot;key2&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value2&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="StringLit">&quot;key3&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value2&quot;</span><span class="Punctuation">)</span><span class="Punctuation">]</span></pre><p>空表可以写成 <tt class="docutils literal"><span class="pre">{:}</span></tt> （与 <tt class="docutils literal"><span class="pre">{}</span></tt> 的空集相反，这是另一种写为空数组构造函数 <tt class="docutils literal"><span class="pre">[]</span></tt> 的方法。 这种略微不同寻常的支持表的方式有很多优点：</p>
<ul class="simple"><li>保留了（键，值）对的顺序，因此很容易支持有序的字典，例如 <tt class="docutils literal"><span class="pre">{key：val}.newOrderedTable</span></tt> 。</li>
<li>表字面值可以放入 <tt class="docutils literal"><span class="pre">const</span></tt> 部分，编译器可以很容易地将它放入可执行文件的数据部分，就像数组一样，生成的数据部分需要最少的内存。</li>
<li>每个表实现在语法上都是一样的。</li>
<li>除了最小的语法糖之外，语言核心不需要了解表。</li>
</ul>

<h2><a class="toc-backref" id="语句和表达式-类型转换" href="#语句和表达式-类型转换">类型转换</a></h2><p>语法上， <tt class="docutils literal"><span class="pre">类型转换</span></tt> 类似于过程调用，但类型名称替换过程名称。</p>
<p>类型转换总是安全的，因为将类型转换为另一个类型失败会导致异常（如果无法静态确定）。</p>
<p>普通的procs通常比Nim中的类型转换更受欢迎：例如， <tt class="docutils literal"><span class="pre">$</span></tt> 是 <tt class="docutils literal"><span class="pre">toString</span></tt> 运算符，而 <tt class="docutils literal"><span class="pre">toFloat</span></tt> 和 <tt class="docutils literal"><span class="pre">toInt</span></tt> 可用于从浮点转换为整数，反之亦然。</p>
<p>类型转换也可用于消除重载例程的歧义：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;int&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;string&quot;</span>

<span class="Keyword">let</span> <span class="Identifier">procVar</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">)</span>
<span class="Identifier">procVar</span><span class="Punctuation">(</span><span class="StringLit">&quot;a&quot;</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="语句和表达式-类型强转" href="#语句和表达式-类型强转">类型强转</a></h2><p>示例：</p>
<pre class="listing"><span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>类型强转是一种粗暴的机制，用于解释表达式的位模式，就好像它将是另一种类型一样。 类型强转仅用于低级编程，并且本质上是不安全的。</p>

<h2><a class="toc-backref" id="语句和表达式-addr操作符" href="#语句和表达式-addr操作符">addr操作符</a></h2><p><tt class="docutils literal"><span class="pre">addr</span></tt> 运算符返回左值的地址。 如果位置的类型是 <tt class="docutils literal"><span class="pre">T</span></tt> ，则 <tt class="docutils literal"><span class="pre">addr</span></tt> 运算符结果的类型为 <tt class="docutils literal"><span class="pre">ptr T</span></tt> 。 地址是未追踪引用。 获取驻留在堆栈上的对象的地址是 <em>不安全的</em> ，因为指针可能比堆栈中的对象存在更久，因此可以引用不存在的对象。</p>
<p>可以获取变量的地址，但是不能在通过 <tt class="docutils literal"><span class="pre">let</span></tt> 语句声明的变量上使用它：</p>
<pre class="listing"><span class="Keyword">let</span> <span class="Identifier">t1</span> <span class="Operator">=</span> <span class="StringLit">&quot;Hello&quot;</span>
<span class="Keyword">var</span>
  <span class="Identifier">t2</span> <span class="Operator">=</span> <span class="Identifier">t1</span>
  <span class="Identifier">t3</span> <span class="Punctuation">:</span> <span class="Identifier">pointer</span> <span class="Operator">=</span> <span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">t2</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">t2</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; ref 0x7fff6b71b670 --&gt; 0x10bb81050&quot;Hello&quot;</span>
<span class="Identifier">echo</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Keyword">ptr</span> <span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">t3</span><span class="Punctuation">)</span><span class="Punctuation">[</span><span class="Punctuation">]</span>
<span class="Comment"># --&gt; Hello</span>
<span class="Comment"># 下面的行不能编译：</span>
<span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">t1</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># 错误: 表达式没有地址</span></pre>
<h2><a class="toc-backref" id="语句和表达式-unsafeaddr操作符" href="#语句和表达式-unsafeaddr操作符">unsafeAddr操作符</a></h2><p>为了更容易与其他编译语言（如C）的互操作性，检索 <tt class="docutils literal"><span class="pre">let</span></tt> 变量的地址，参数或 <tt class="docutils literal"><span class="pre">for</span></tt> 循环变量，可以使用 <tt class="docutils literal"><span class="pre">unsafeAddr</span></tt> 操作：</p>
<pre class="listing"><span class="Keyword">let</span> <span class="Identifier">myArray</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span>
<span class="Identifier">foreignProcThatTakesAnAddr</span><span class="Punctuation">(</span><span class="Identifier">unsafeAddr</span> <span class="Identifier">myArray</span><span class="Punctuation">)</span></pre>
<h1><a class="toc-backref" id="过程" href="#过程">过程</a></h1><p>大多数编程语言称之为 <span id="方法_1">方法</span> 或 <span id="函数_1">函数</span> 在Nim中称为 <span id="过程_1">过程</span> 。 过程声明由标识符，零个或多个形式参数，返回值类型和代码块组成。</p>
<p>正式参数声明为由逗号或分号分隔的标识符列表。 形参由 <tt class="docutils literal"><span class="pre">: 类型名称</span></tt> 给出一个类型。</p>
<p>该类型适用于紧接其之前的所有参数，直到达到参数列表的开头，分号分隔符或已经键入的参数。</p>
<p>分号可用于使类型和后续标识符的分隔更加清晰。</p>
<pre class="listing"><span class="Comment"># 只使用逗号</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">d</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Comment"># 使用分号进行视觉区分</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">d</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Comment"># 会失败：a是无类型的，因为 ';' 停止类型传播。</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">;</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">d</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre><p>可以使用默认值声明参数，如果调用者没有为参数提供值，则使用该默认值。</p>
<pre class="listing"><span class="Comment"># b is optional with 47 as its default value</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">47</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre><p>参数可以声明为可变的，因此允许proc通过使用类型修饰符 <tt class="docutils literal"><span class="pre">var</span></tt> 来修改这些参数。</p>
<pre class="listing"><span class="Comment"># 通过第二个参数 ``返回`` 一个值给调用者</span>
<span class="Comment"># 请注意，该函数根本不使用实际返回值（即void）</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">inp</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">outp</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">outp</span> <span class="Operator">=</span> <span class="Identifier">inp</span> <span class="Operator">+</span> <span class="DecNumber">47</span></pre><p>如果proc声明没有正文，则它是一个 <span id="前向_1">前向</span> 声明。 如果proc返回一个值，那么过程体可以访问一个名为 <tt class="docutils literal"><span class="pre">result</span></tt> 的隐式声明的变量。</p>
<p>过程可能会重载。 重载解析算法确定哪个proc是参数的最佳匹配。</p>
<p>示例：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">toLower</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">char</span> <span class="Operator">=</span> <span class="Comment"># toLower for characters</span>
  <span class="Keyword">if</span> <span class="Identifier">c</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="CharLit">'A'</span><span class="Operator">..</span><span class="CharLit">'Z'</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">chr</span><span class="Punctuation">(</span><span class="Identifier">ord</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Punctuation">(</span><span class="Identifier">ord</span><span class="Punctuation">(</span><span class="CharLit">'a'</span><span class="Punctuation">)</span> <span class="Operator">-</span> <span class="Identifier">ord</span><span class="Punctuation">(</span><span class="CharLit">'A'</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">c</span>

<span class="Keyword">proc</span> <span class="Identifier">toLower</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Comment"># 字符串toLower</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newString</span><span class="Punctuation">(</span><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Operator">-</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">toLower</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Comment"># calls toLower for characters; no recursion!</span></pre><p>调用过程可以通过多种方式完成：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span> <span class="Identifier">false</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Comment"># call with positional arguments      # parameter bindings:</span>
<span class="Identifier">callme</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'\t'</span><span class="Punctuation">,</span> <span class="Identifier">true</span><span class="Punctuation">)</span>       <span class="Comment"># (x=0, y=1, s=&quot;abc&quot;, c='\t', b=true)</span>
<span class="Comment"># call with named and positional arguments:</span>
<span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Operator">=</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Operator">=</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abd&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'\t'</span><span class="Punctuation">)</span>         <span class="Comment"># (x=0, y=1, s=&quot;abd&quot;, c='\t', b=false)</span>
<span class="Comment"># call with named arguments (order is not relevant):</span>
<span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Operator">=</span><span class="CharLit">'\t'</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Operator">=</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Operator">=</span><span class="DecNumber">0</span><span class="Punctuation">)</span>              <span class="Comment"># (x=0, y=1, s=&quot;&quot;, c='\t', b=false)</span>
<span class="Comment"># call as a command statement: no () needed:</span>
<span class="Identifier">callme</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'\t'</span>              <span class="Comment"># (x=0, y=1, s=&quot;abc&quot;, c='\t', b=false)</span></pre><p>过程可以递归地调用自身。</p>
<p><span id="运算符_1">运算符</span> 是具有特殊运算符符号作为标识符的过程：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Comment"># 将整数转换为字符串;这是一个前缀运算符。</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">intToStr</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>具有一个参数的运算符是前缀运算符，具有两个参数的运算符是中缀运算符。 （但是，解析器将这些与运算符在表达式中的位置区分开来。） 没有办法声明后缀运算符：所有后缀运算符都是内置的，并由语法显式处理。</p>
<p>任何运算符都可以像普通的proc一样用 '<tt class="docutils literal"><span class="pre">opr</span></tt>' 表示法调用。（因此运算符可以有两个以上的参数）：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*+</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># Multiply and add</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Operator">*</span> <span class="Identifier">b</span> <span class="Operator">+</span> <span class="Identifier">c</span>

<span class="Identifier">assert</span> <span class="Punctuation">`</span><span class="Operator">*+</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="过程-导出标记" href="#过程-导出标记">导出标记</a></h2><p>如果声明的符号标有 <span id="asterisk_1">asterisk</span> 它从当前模块导出：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">exportedEcho</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="Identifier">s</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">;</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newStringOfCap</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">*</span> <span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">a</span>

<span class="Keyword">var</span> <span class="Identifier">exportedVar</span><span class="Operator">*:</span> <span class="Identifier">int</span>
<span class="Keyword">const</span> <span class="Identifier">exportedConst</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="DecNumber">78</span>
<span class="Keyword">type</span>
  <span class="Identifier">ExportedType</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">exportedField</span><span class="Operator">*:</span> <span class="Identifier">int</span></pre>
<h2><a class="toc-backref" id="过程-方法调用语法" href="#过程-方法调用语法">方法调用语法</a></h2><p>对于面向对象的编程，可以使用语法 <tt class="docutils literal"><span class="pre">obj.method(args)</span></tt> 而不是 <tt class="docutils literal"><span class="pre">method(obj, args)</span></tt> 。</p>
<p>如果没有剩余的参数，则可以省略括号： <tt class="docutils literal"><span class="pre">obj.len</span></tt> (而不是 <tt class="docutils literal"><span class="pre">len(obj)</span></tt> )。</p>
<p>此方法调用语法不限于对象，它可用于为过程提供任何类型的第一个参数：</p>
<pre class="listing"><span class="Identifier">echo</span> <span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Comment"># 与echo len&quot;abc&quot;相同</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">toUpper</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Punctuation">,</span> <span class="CharLit">'b'</span><span class="Punctuation">,</span> <span class="CharLit">'c'</span><span class="Punctuation">}</span><span class="Operator">.</span><span class="Identifier">card</span>
<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hallo&quot;</span><span class="Punctuation">)</span> <span class="Comment"># 与相同writeLine(stdout，&quot;Hallo&quot;)</span></pre><p>查看方法调用语法的另一种方法是它提供了缺少的后缀表示法。</p>
<p>方法调用语法与显式泛型实例化冲突： <tt class="docutils literal"><span class="pre">p[T](x)</span></tt> 不能写为 <tt class="docutils literal"><span class="pre">x.p[T]</span></tt> 因为 <tt class="docutils literal"><span class="pre">x.p[T]</span></tt> 总是被解析为 <tt class="docutils literal"><span class="pre">(x.p)[T]</span></tt> 。</p>
<p>见: <a class="reference external" href="#templates-limitations-of-the-method-call-syntax">Limitations of the method call syntax</a> 。</p>
<p><tt class="docutils literal"><span class="pre">[:]</span></tt> 符号旨在缓解这个问题： <tt class="docutils literal"><span class="pre">xp[:T]</span></tt> 由解析器重写为 <tt class="docutils literal"><span class="pre">p[T](x)</span></tt> ， <tt class="docutils literal"><span class="pre">xp[:T](y)</span></tt> 被重写为 <tt class="docutils literal"><span class="pre">p[T](x,y)</span></tt> 。 注意 <tt class="docutils literal"><span class="pre">[:]</span></tt> 没有AST表示，重写直接在解析步骤中执行。</p>

<h2><a class="toc-backref" id="过程-属性" href="#过程-属性">属性</a></h2><p>Nim不需要 <em>get-properties</em> ：使用 <em>方法调用语法</em> 调用的普通get-procedure达到相同目的。 但设定值是不同的;为此需要一个特殊的setter语法：</p>
<pre class="listing"><span class="Comment"># 模块asocket</span>
<span class="Keyword">type</span>
  <span class="Identifier">Socket</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
    <span class="Identifier">host</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># 无法从模块外部访问</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Identifier">host</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Socket</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment">## hostAddr的setter.</span>
  <span class="Comment">##它访问'host'字段并且不是对 ``host =`` 的递归调用，如果内置的点访问方法可用，则首选点访问：</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">host</span> <span class="Operator">=</span> <span class="Identifier">value</span>

<span class="Keyword">proc</span> <span class="Identifier">host</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">Socket</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment">## hostAddr的getter</span>
  <span class="Comment">##它访问'host'字段并且不是对 ``host`` 的递归调用，如果内置的点访问方法可用，则首选点访问：</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">host</span></pre><pre class="listing"><span class="Comment"># 模块 B</span>
<span class="Keyword">import</span> <span class="Identifier">asocket</span>
<span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">Socket</span>
<span class="Identifier">new</span> <span class="Identifier">s</span>
<span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">host</span> <span class="Operator">=</span> <span class="DecNumber">34</span>  <span class="Comment"># 同`host=`(s, 34)</span></pre><p>定义为 <tt class="docutils literal"><span class="pre">f=</span></tt> 的proc（尾随 <tt class="docutils literal"><span class="pre">=</span></tt> ）被称为 <span id="setter_1">setter</span> 。</p>
<p>可以通过常见的反引号表示法显式调用setter：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Identifier">f</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">MyObject</span><span class="Punctuation">;</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">discard</span>

<span class="Punctuation">`</span><span class="Identifier">f</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">myObject</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value&quot;</span><span class="Punctuation">)</span></pre><p><tt class="docutils literal"><span class="pre">f=</span></tt> 可以在模式 <tt class="docutils literal"><span class="pre">xf = value</span></tt> 中隐式调用，当且仅当 <tt class="docutils literal"><span class="pre">x</span></tt> 的类型没有名为 <tt class="docutils literal"><span class="pre">f</span></tt> 的字段或者 <tt class="docutils literal"><span class="pre">f</span></tt> 时在当前模块中不可见。 这些规则确保对象字段和访问者可以具有相同的名称。 在模块 <tt class="docutils literal"><span class="pre">x.f</span></tt> 中总是被解释为字段访问，在模块外部它被解释为访问器proc调用。</p>

<h2><a class="toc-backref" id="过程-命令调用语法" href="#过程-命令调用语法">命令调用语法</a></h2><p>如果调用在语法上是一个语句，则可以在没有 <tt class="docutils literal"><span class="pre">()</span></tt> 的情况下调用例程。 这种限制意味着 <tt class="docutils literal"><span class="pre">echo f 1, f 2</span></tt> 被解析为 <tt class="docutils literal"><span class="pre">echo(f(1), f(2))</span></tt> 而不是 <tt class="docutils literal"><span class="pre">echo(f(1, f(2)))</span></tt> 。</p>
<p>在这种情况下，方法调用语法可用于提供一个或多个参数：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">optarg</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>
<span class="Keyword">proc</span> <span class="Identifier">singlearg</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">20</span><span class="Operator">*</span><span class="Identifier">x</span>

<span class="Identifier">echo</span> <span class="Identifier">optarg</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">singlearg</span> <span class="DecNumber">2</span>  <span class="Comment"># 打印 &quot;1 40&quot;</span>

<span class="Keyword">let</span> <span class="Identifier">fail</span> <span class="Operator">=</span> <span class="Identifier">optarg</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">optarg</span> <span class="DecNumber">8</span>   <span class="Comment"># 错误。命令调用的参数太多</span>
<span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">optarg</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">optarg</span> <span class="DecNumber">8</span><span class="Punctuation">)</span>  <span class="Comment"># 传统过程调用2个参数</span>
<span class="Keyword">let</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="FloatNumber">1.</span><span class="Identifier">optarg</span> <span class="Identifier">optarg</span> <span class="DecNumber">8</span>    <span class="Comment"># 与上面相同，没有括号</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="Identifier">y</span></pre><p>命令调用语法也不能将复杂表达式作为参数。 例如： (<a class="reference external" href="#匿名过程">匿名过程</a>), <tt class="docutils literal"><span class="pre">if</span></tt>, <tt class="docutils literal"><span class="pre">case</span></tt> 或 <tt class="docutils literal"><span class="pre">try</span></tt> 。 没有参数的函数调用仍需要()来区分调用和函数本身作为第一类值。</p>

<h2><a class="toc-backref" id="过程-闭包" href="#过程-闭包">闭包</a></h2><p>过程可以出现在模块的顶层以及其他范围内，在这种情况下，它们称为嵌套过程。 嵌套的proc可以从其封闭的范围访问局部变量，如果它这样做，它就变成了一个闭包。 任何捕获的变量都存储在闭包（它的环境）的隐藏附加参数中，并且它们通过闭包及其封闭范围的引用来访问（即，对它们进行的任何修改在两个地方都是可见的）。</p>
<p>如果编译器确定这是安全的，则可以在堆上或堆栈上分配闭包环境。</p>

<h3><a class="toc-backref" id="闭包-在循环中创建闭包" href="#闭包-在循环中创建闭包">在循环中创建闭包</a></h3><p>由于闭包通过引用捕获局部变量，因此在循环体内通常不需要行为。 有关如何更改此行为的详细信息，请参阅 <a class="reference external" href="system.html#closureScope">closureScope</a> 。</p>

<h2><a class="toc-backref" id="过程-匿名过程" href="#过程-匿名过程">匿名过程</a></h2><p>Procs也可以被视为表达式，在这种情况下，它允许省略proc的名称。</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">cities</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="StringLit">&quot;Frankfurt&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Tokyo&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;New York&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Kyiv&quot;</span><span class="Punctuation">]</span>

<span class="Identifier">cities</span><span class="Operator">.</span><span class="Identifier">sort</span><span class="Punctuation">(</span><span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
    <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre><p>Procs as表达式既可以作为嵌套proc，也可以作为顶级可执行代码。</p>

<h2><a class="toc-backref" id="过程-函数" href="#过程-函数">函数</a></h2><p>The <tt class="docutils literal"><span class="pre">func</span></tt> 关键字为 <span id="nosideeffect_1">noSideEffect</span> 的过程引入了一个快捷方式。</p>
<pre class="listing"><span class="Keyword">func</span> <span class="Identifier">binarySearch</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">elem</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre><p>是它的简写:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">binarySearch</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">elem</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">noSideEffect</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="过程-不可重载的内置" href="#过程-不可重载的内置">不可重载的内置</a></h2><p>由于实现简单，它们不能重载以下内置过程（它们需要专门的语义检查）:</p>
<blockquote><p>declared, defined, definedInScope, compiles, sizeOf, is, shallowCopy, getAst, astToStr, spawn, procCall</p></blockquote>
<p>因此，它们更像关键词而非普通标识符;然而，与关键字不同，重新定义可能是 <span id="shadow_1">shadow</span> <tt class="docutils literal"><span class="pre">system</span></tt> 模块中的定义。 从这个列表中不应该用点符号 <tt class="docutils literal"><span class="pre">x.f</span></tt> 写，因为 <tt class="docutils literal"><span class="pre">x</span></tt> 在传递给 <tt class="docutils literal"><span class="pre">f</span></tt> 之前不能进行类型检查：</p>
<blockquote><p>declared, defined, definedInScope, compiles, getAst, astToStr</p></blockquote>

<h2><a class="toc-backref" id="过程-var形参" href="#过程-var形参">Var形参</a></h2><p>参数的类型可以使用 <tt class="docutils literal"><span class="pre">var</span></tt> 关键字作为前缀：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span>
  <span class="Identifier">remainder</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Comment"># modifies x and y</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">y</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre><p>在示例中， <tt class="docutils literal"><span class="pre">res</span></tt> 和 <tt class="docutils literal"><span class="pre">remainder</span></tt> 是 <tt class="docutils literal"><span class="pre">var parameters</span></tt> 。 可以通过过程修改Var参数，并且调用者可以看到更改。 传递给var参数的参数必须是左值。 Var参数实现为隐藏指针。 上面的例子相当于：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">res</span><span class="Punctuation">[</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span>
  <span class="Identifier">remainder</span><span class="Punctuation">[</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">y</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre><p>在示例中，var参数或指针用于提供两个返回值。 这可以通过返回元组以更干净的方式完成：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">t</span> <span class="Operator">=</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">res</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">remainder</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre><p>可以使用 <span id="元组解包_1">元组解包</span> 来访问元组的字段：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">)</span> <span class="Comment"># 元组解包</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">y</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre><p><strong>注意</strong>: <tt class="docutils literal"><span class="pre">var</span></tt> 参数对于有效的参数传递永远不是必需的。 由于无法修改非var参数，因此如果编译器认为可以加快执行速度，则编译器始终可以通过引用自由传递参数。</p>

<h2><a class="toc-backref" id="过程-var返回类型" href="#过程-var返回类型">Var返回类型</a></h2><p>proc，转换器或迭代器可能返回一个 <tt class="docutils literal"><span class="pre">var</span></tt> 类型，这意味着返回的值是一个左值，并且可以由调用者修改：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">g</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">proc</span> <span class="Identifier">writeAccessToG</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">g</span>

<span class="Identifier">writeAccessToG</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="DecNumber">6</span>
<span class="Identifier">assert</span> <span class="Identifier">g</span> <span class="Operator">==</span> <span class="DecNumber">6</span></pre><p>如果隐式引入的指针可用于访问超出其生命周期的位置，则这是一个静态错误：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">writeAccessToG</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">g</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">g</span> <span class="Comment"># 错误!</span></pre><p>For iterators, a component of a tuple return type can have a <tt class="docutils literal"><span class="pre">var</span></tt> type too:</p>
<pre class="listing"><span class="Keyword">iterator</span> <span class="Identifier">mpairs</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">key</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">val</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>在标准库中，返回 <tt class="docutils literal"><span class="pre">var</span></tt> 类型的例程的每个名称都以每个约定的前缀 <tt class="docutils literal"><span class="pre">m</span></tt> 开头。</p>
Memory safety for returning by <tt class="docutils literal"><span class="pre">var T</span></tt> is ensured by a simple borrowing rule: If <tt class="docutils literal"><span class="pre">result</span></tt> does not refer to a location pointing to the heap (that is in <tt class="docutils literal"><span class="pre">result = X</span></tt> the <tt class="docutils literal"><span class="pre">X</span></tt> involves a <tt class="docutils literal"><span class="pre">ptr</span></tt> or <tt class="docutils literal"><span class="pre">ref</span></tt> access) then it has to be deviated by the routine's first parameter:<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">forward</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Comment"># ok, deviated from the first parameter.</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">param</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Comment"># we know 'forward' provides a view into the location deviated by</span>
  <span class="Comment"># its first argument 'x'.</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">forward</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># Error: location is derived from ``x``</span>
                      <span class="Comment"># which is not p's first parameter and lives</span>
                      <span class="Comment"># on the stack.</span></pre><p>In other words, the lifetime of what <tt class="docutils literal"><span class="pre">result</span></tt> points to is attached to the lifetime of the first parameter and that is enough knowledge to verify memory safety at the callsite. </p>

<h3><a class="toc-backref" id="var返回类型-未来的方向" href="#var返回类型-未来的方向">未来的方向</a></h3><p>Nim的更高版本可以使用如下语法更准确地了解借用规则：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">other</span><span class="Punctuation">:</span> <span class="Identifier">Y</span><span class="Punctuation">;</span> <span class="Identifier">container</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">X</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">T</span> <span class="Keyword">from</span> <span class="Identifier">container</span></pre><p>这里 <tt class="docutils literal"><span class="pre">var T from container</span></tt> 明确地暴露了该位置不同于第二个形参（在本例中称为'container'）。 语法 <tt class="docutils literal"><span class="pre">var T from p</span></tt> 指定一个类型 <tt class="docutils literal"><span class="pre">varTy [T,2]</span></tt> ，它与 <tt class="docutils literal"><span class="pre">varTy [T,1]</span></tt> 不兼容。</p>

<h2><a class="toc-backref" id="过程-下标操作符重载" href="#过程-下标操作符重载">下标操作符重载</a></h2><p>数组/开放数组/序列的 <tt class="docutils literal"><span class="pre">[]</span></tt> 下标运算符可以重载。</p>

<h1><a class="toc-backref" id="多方法" href="#多方法">多方法</a></h1><p><strong>注意：</strong> 从Nim 0.20开始，要使用多方法，必须在编译时明确传递 <tt class="docutils literal"><span class="pre">--multimethods：on</span></tt> 。</p>
<p>程序总是使用静态调度。多方法使用动态调度。 要使动态分派处理对象，它应该是引用类型。</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Expression</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span> <span class="Comment">## abstract base class for an expression</span>
  <span class="Identifier">Literal</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Expression</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">PlusExpr</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Expression</span>
    <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Expression</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">Expression</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">base</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># 重写基方法</span>
  <span class="Identifier">quit</span> <span class="StringLit">&quot;to override!&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">Literal</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Keyword">return</span> <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">x</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">PlusExpr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># 当心: 依赖动态绑定</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Literal</span> <span class="Operator">=</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">x</span>

<span class="Keyword">proc</span> <span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Expression</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PlusExpr</span> <span class="Operator">=</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">b</span>

<span class="Identifier">echo</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre><p>在示例中，构造函数 <tt class="docutils literal"><span class="pre">newLit</span></tt> 和 <tt class="docutils literal"><span class="pre">newPlus</span></tt> 是procs因为它们应该使用静态绑定，但 <tt class="docutils literal"><span class="pre">eval</span></tt> 是一种方法，因为它需要动态绑定。</p>
<p>从示例中可以看出，基本方法必须使用 <span id="base_1">base</span> 编译指示进行注释。 <tt class="docutils literal"><span class="pre">base</span></tt> 编译指示还可以提醒程序员使用基本方法 <tt class="docutils literal"><span class="pre">m</span></tt> 作为基础来确定调用 <tt class="docutils literal"><span class="pre">m</span></tt> 可能导致的所有效果。</p>
<p><strong>注意</strong>: 编译期执行不支持方法。</p>
<p><strong>注意</strong>: 从Nim 0.20开始，不推荐使用泛型方法。</p>

<h2><a class="toc-backref" id="多方法-通过proccall禁止动态方法解析" href="#多方法-通过proccall禁止动态方法解析">通过procCall禁止动态方法解析</a></h2><p>可以通过内置的 <span id="systemdotproccall_1">system.procCall</span> 来禁止动态方法解析。 这有点类似于传统OOP语言提供的 <span id="super_1">super</span> 关键字。</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Thing</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
  <span class="Identifier">Unit</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Thing</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">method</span> <span class="Identifier">m</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">base</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;base&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">m</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># Call the base method:</span>
  <span class="Identifier">procCall</span> <span class="Identifier">m</span><span class="Punctuation">(</span><span class="Identifier">Thing</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;1&quot;</span></pre>
<h1><a class="toc-backref" id="迭代器和for语句" href="#迭代器和for语句">迭代器和for语句</a></h1><p><span id="for_1">for</span> 语句是一种迭代容器元素的抽象机制。 它依赖于 <span id="iterator_1">iterator</span>这样做。就像 <tt class="docutils literal"><span class="pre">while</span></tt> 语句一样， <tt class="docutils literal"><span class="pre">for</span></tt> 语句打开一个 <span id="隐式块_1">隐式块</span>，这样它们就可以留下一个 <tt class="docutils literal"><span class="pre">break</span></tt> 语句。</p>
<p><tt class="docutils literal"><span class="pre">for</span></tt> 循环声明迭代变量 - 它们的范围一直到循环体的末尾。 迭代变量的类型由迭代器的返回类型推断。</p>
<p>迭代器类似于一个过程，除了它可以在 <tt class="docutils literal"><span class="pre">for</span></tt> 循环的上下文中调用。 迭代器提供了一种指定抽象类型迭代的方法。 执行 <tt class="docutils literal"><span class="pre">for</span></tt> 循环的关键作用是在被调用的迭代器中播放 <tt class="docutils literal"><span class="pre">yield</span></tt> 语句。 每当达到 <tt class="docutils literal"><span class="pre">yield</span></tt> 语句时，数据就会被绑定到 <tt class="docutils literal"><span class="pre">for</span></tt> 循环变量，并且控制在 <tt class="docutils literal"><span class="pre">for</span></tt> 循环的主体中继续。 迭代器的局部变量和执行状态在调用之间自动保存。</p>
<p>示例：</p>
<pre class="listing"><span class="Comment"># 该定义存在于系统模块中</span>
<span class="Keyword">iterator</span> <span class="Identifier">items</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">char</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">i</span> <span class="Operator">&lt;</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span>

<span class="Keyword">for</span> <span class="Identifier">ch</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="StringLit">&quot;hello world&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Comment"># `ch` is an iteration variable</span>
  <span class="Identifier">echo</span> <span class="Identifier">ch</span></pre><p>编译器生成代码就像程序员编写的那样：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Keyword">while</span> <span class="Identifier">i</span> <span class="Operator">&lt;</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">ch</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
  <span class="Identifier">echo</span> <span class="Identifier">ch</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span></pre><p>如果迭代器产生一个元组，那么迭代变量可以与元组中的组件一样多。 第i个迭代变量的类型是第i个组件的类型。 换句话说，支持for循环上下文中的隐式元组解包。</p>

<h2><a class="toc-backref" id="迭代器和for语句-隐式items和pairs调用" href="#迭代器和for语句-隐式items和pairs调用">隐式items和pairs调用</a></h2><p>如果for循环表达式 <tt class="docutils literal"><span class="pre">e</span></tt> 不表示迭代器而for循环正好有1个变量，则for循环表达式被重写为 <tt class="docutils literal"><span class="pre">items(e)</span></tt> ;即隐式调用 <tt class="docutils literal"><span class="pre">items</span></tt> 迭代器：</p>
<pre class="listing"><span class="Keyword">for</span> <span class="Identifier">x</span> <span class="Keyword">in</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">,</span><span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="Identifier">x</span></pre><p>如果for循环恰好有2个变量，则隐式调用 <tt class="docutils literal"><span class="pre">pairs</span></tt> 迭代器。</p>
<p>在重写步骤之后执行标识符 <tt class="docutils literal"><span class="pre">items</span></tt> 或 <tt class="docutils literal"><span class="pre">pairs</span></tt> 的符号查找，以便考虑所有 <tt class="docutils literal"><span class="pre">items</span></tt> 或 <tt class="docutils literal"><span class="pre">pairs</span></tt> 的重载。</p>

<h2><a class="toc-backref" id="迭代器和for语句-第一类迭代器" href="#迭代器和for语句-第一类迭代器">第一类迭代器</a></h2><p>Nim中有两种迭代器： <em>inline</em> 和 <em>closure</em> 迭代器。 一个 <span id="内联迭代器_1">内联迭代器</span> 是一个迭代器，总是由编译器内联，导致抽象的开销为零，但可能导致代码大小的大量增加。</p>
<p>注意：内联迭代器上的for循环体被内联到迭代器代码中出现的每个 <tt class="docutils literal"><span class="pre">yield</span></tt> 语句中，因此理想情况下，代码应该被重构为包含单个yield，以避免代码膨胀。</p>
<p>内联迭代器是二等公民; 它们只能作为参数传递给其他内联代码工具，如模板、宏和其他内联迭代器。</p>
<p>与此相反， <span id="闭包迭代器_1">闭包迭代器</span> 可以更自由地传递：</p>
<pre class="listing"><span class="Keyword">iterator</span> <span class="Identifier">count0</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">yield</span> <span class="DecNumber">0</span>

<span class="Keyword">iterator</span> <span class="Identifier">count2</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Keyword">yield</span> <span class="Identifier">x</span>
  <span class="Identifier">inc</span> <span class="Identifier">x</span>
  <span class="Keyword">yield</span> <span class="Identifier">x</span>

<span class="Keyword">proc</span> <span class="Identifier">invoke</span><span class="Punctuation">(</span><span class="Identifier">iter</span><span class="Punctuation">:</span> <span class="Keyword">iterator</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">x</span> <span class="Keyword">in</span> <span class="Identifier">iter</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="Identifier">x</span>

<span class="Identifier">invoke</span><span class="Punctuation">(</span><span class="Identifier">count0</span><span class="Punctuation">)</span>
<span class="Identifier">invoke</span><span class="Punctuation">(</span><span class="Identifier">count2</span><span class="Punctuation">)</span></pre><p>闭包迭代器和内联迭代器有一些限制：</p>
<ol class="simple"><li>目前，闭包迭代器无法在编译时执行。</li>
<li>在闭包迭代器中允许 <tt class="docutils literal"><span class="pre">return</span></tt> 但在内联迭代器中不允许（但很少有用）并结束迭代。</li>
<li>内联和闭包迭代器都不能递归。</li>
<li>内联和闭包迭代器都没有特殊的 <tt class="docutils literal"><span class="pre">result</span></tt> 变量。</li>
<li>js后端不支持闭包迭代器。</li>
</ol>
<p>迭代器既没有标记为 <tt class="docutils literal"><span class="pre">{.closure.}</span></tt> 也不是 <tt class="docutils literal"><span class="pre">{.inline.}</span></tt> 则显式默认内联，但这可能会在未来版本的实现中发生变化。</p>
<p><tt class="docutils literal"><span class="pre">iterator</span></tt> 类型总是隐式调用约定 <tt class="docutils literal"><span class="pre">closure</span></tt> ;以下示例显示如何使用迭代器实现 <span id="协作任务_1">协作任务</span> 系统:</p>
<pre class="listing"><span class="Comment"># 简单任务:</span>
<span class="Keyword">type</span>
  <span class="Identifier">Task</span> <span class="Operator">=</span> <span class="Keyword">iterator</span> <span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span>

<span class="Keyword">iterator</span> <span class="Identifier">a1</span><span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: A&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: B&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: C&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: D&quot;</span>

<span class="Keyword">iterator</span> <span class="Identifier">a2</span><span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a2: A&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a2: B&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a2: C&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">runTasks</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">Task</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">ticker</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">t</span><span class="Punctuation">[</span><span class="Identifier">ticker</span> <span class="Keyword">mod</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">]</span>
    <span class="Keyword">if</span> <span class="Identifier">finished</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">break</span>
    <span class="Identifier">x</span><span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">)</span>
    <span class="Identifier">inc</span> <span class="Identifier">ticker</span>

<span class="Identifier">runTasks</span><span class="Punctuation">(</span><span class="Identifier">a1</span><span class="Punctuation">,</span> <span class="Identifier">a2</span><span class="Punctuation">)</span></pre><p>内置的 <tt class="docutils literal"><span class="pre">system.finished</span></tt> 可用于确定迭代器是否已完成其操作;尝试调用已完成其工作的迭代器时不会引发异常。</p>
<p>注意使用 <tt class="docutils literal"><span class="pre">system.finished</span></tt> 容易出错，因为它只在迭代器完成下一次迭代返回 <tt class="docutils literal"><span class="pre">true</span></tt> ：</p>
<pre class="listing"><span class="Keyword">iterator</span> <span class="Identifier">mycount</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Keyword">while</span> <span class="Identifier">x</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Identifier">x</span>
    <span class="Identifier">inc</span> <span class="Identifier">x</span>

<span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">mycount</span> <span class="Comment"># 实例化迭代器</span>
<span class="Keyword">while</span> <span class="Keyword">not</span> <span class="Identifier">finished</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">c</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span>

<span class="Comment"># 生成</span>
<span class="DecNumber">1</span>
<span class="DecNumber">2</span>
<span class="DecNumber">3</span>
<span class="DecNumber">0</span></pre><p>而是必须使用此代码：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">mycount</span> <span class="Comment"># 实例化迭代器</span>
<span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">value</span> <span class="Operator">=</span> <span class="Identifier">c</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span>
  <span class="Keyword">if</span> <span class="Identifier">finished</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">break</span> <span class="Comment"># 并且丢弃 'value'。</span>
  <span class="Identifier">echo</span> <span class="Identifier">value</span></pre><p>它用于迭代器返回一对 <tt class="docutils literal"><span class="pre">(value，done)</span></tt> 和 <tt class="docutils literal"><span class="pre">finished</span></tt> 用于访问隐藏的 <tt class="docutils literal"><span class="pre">done</span></tt> 字段。</p>
<p>闭包迭代器是 <em>可恢复函数</em> ，因此必须为每个调用提供参数。 为了解决这个限制，可以捕获外部工厂proc的参数：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">mycount</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">iterator</span> <span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Keyword">iterator</span> <span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
    <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span>
    <span class="Keyword">while</span> <span class="Identifier">x</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
      <span class="Keyword">yield</span> <span class="Identifier">x</span>
      <span class="Identifier">inc</span> <span class="Identifier">x</span>

<span class="Keyword">let</span> <span class="Identifier">foo</span> <span class="Operator">=</span> <span class="Identifier">mycount</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span>

<span class="Keyword">for</span> <span class="Identifier">f</span> <span class="Keyword">in</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">f</span></pre>
<h1><a class="toc-backref" id="转换器" href="#转换器">转换器</a></h1><p>转换器就像普通的过程，除了它增强了 <tt class="docutils literal"><span class="pre">隐式可转换</span></tt> 类型关系（参见 <a class="reference external" href="#type-relations-convertible-relation">可转换关系</a> ）：</p>
<pre class="listing"><span class="Comment"># 不好的风格：Nim不是C。</span>
<span class="Keyword">converter</span> <span class="Identifier">toBool</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">!=</span> <span class="DecNumber">0</span>

<span class="Keyword">if</span> <span class="DecNumber">4</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;compiles&quot;</span></pre><p>还可以显式调用转换器以提高可读性。 请注意，不支持隐式转换器链接：如果存在从类型A到类型B的转换器以及从类型B到类型C的转换器，则不提供从A到C的隐式转换。</p>

<h1><a class="toc-backref" id="type段" href="#type段">Type段</a></h1><p>示例：</p>
<pre class="listing"><span class="Keyword">type</span> <span class="Comment"># 演示相互递归类型的示例</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>  <span class="Comment"># 垃圾收集器管理的对象（r​​ef）</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>     <span class="Comment"># 左右子树</span>
    <span class="Identifier">sym</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Sym</span>     <span class="Comment"># 叶节点含有Sym的引用</span>
  
  <span class="Identifier">Sym</span> <span class="Operator">=</span> <span class="Keyword">object</span>       <span class="Comment"># 一个符号</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>     <span class="Comment"># 符号名</span>
    <span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">int</span>        <span class="Comment"># 声明符号的行</span>
    <span class="Identifier">code</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>       <span class="Comment"># 符号的抽象语法树</span></pre><p>类型部分以 <tt class="docutils literal"><span class="pre">type</span></tt> 关键字开头。 它包含多个类型定义。 类型定义将类型绑定到名称。 类型定义可以是递归的，甚至可以是相互递归的。 相互递归类型只能在单个 <tt class="docutils literal"><span class="pre">type</span></tt> 部分中使用。 像 <tt class="docutils literal"><span class="pre">objects</span></tt> 或 <tt class="docutils literal"><span class="pre">enums</span></tt> 这样的标称类型只能在 <tt class="docutils literal"><span class="pre">type</span></tt> 部分中定义。</p>

<h1><a class="toc-backref" id="异常处理" href="#异常处理">异常处理</a></h1>
<h2><a class="toc-backref" id="异常处理-try语句" href="#异常处理-try语句">Try语句</a></h2><p>示例：</p>
<pre class="listing"><span class="Comment"># 读取应包含数字的文本文件的前两行并尝试添加</span>
<span class="Keyword">var</span>
  <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
<span class="Keyword">if</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
    <span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;sum: &quot;</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Punctuation">(</span><span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span> <span class="Identifier">OverflowError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;overflow!&quot;</span>
  <span class="Keyword">except</span> <span class="Identifier">ValueError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;could not convert string to integer&quot;</span>
  <span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;IO error!&quot;</span>
  <span class="Keyword">except</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;Unknown exception!&quot;</span>
  <span class="Keyword">finally</span><span class="Punctuation">:</span>
    <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span></pre><p><tt class="docutils literal"><span class="pre">try</span></tt> 之后的语句按顺序执行，除非引发异常 <tt class="docutils literal"><span class="pre">e</span></tt> 。 如果 <tt class="docutils literal"><span class="pre">e</span></tt> 的异常类型匹配 <tt class="docutils literal"><span class="pre">except</span></tt> 子句中列出的任何类型，则执行相应的语句。 <tt class="docutils literal"><span class="pre">except</span></tt> 子句后面的语句称为 <span id="异常处理程序_1">异常处理程序</span> 。</p>
<p>如果存在未列出的异常，则执行空的 <span id="except_1">except</span> 子句。 它类似于 <tt class="docutils literal"><span class="pre">if</span></tt> 语句中的 <tt class="docutils literal"><span class="pre">else</span></tt> 子句。</p>
<p>如果有一个 <span id="finally_1">finally</span> 子句，它总是在异常处理程序之后执行。</p>
<p>异常处理程序中的 <em>consume</em> 异常。 但是，异常处理程序可能会引发另一个异常。 如果未处理异常，则通过调用堆栈传播该异常。 这意味着程序不在 <tt class="docutils literal"><span class="pre">finally</span></tt> 子句中的其余部分通常不会被执行（如果发生异常）。</p>

<h2><a class="toc-backref" id="异常处理-try表达式" href="#异常处理-try表达式">Try表达式</a></h2><p>尝试也可以用作表达式;然后 <tt class="docutils literal"><span class="pre">try</span></tt> 分支的类型需要适合 <tt class="docutils literal"><span class="pre">except</span></tt> 分支的类型，但 <tt class="docutils literal"><span class="pre">finally</span></tt> 分支的类型总是必须是 <tt class="docutils literal"><span class="pre">void</span></tt> ：</p>
<pre class="listing"><span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Keyword">try</span><span class="Punctuation">:</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="StringLit">&quot;133a&quot;</span><span class="Punctuation">)</span>
        <span class="Keyword">except</span><span class="Punctuation">:</span> <span class="Operator">-</span><span class="DecNumber">1</span>
        <span class="Keyword">finally</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;hi&quot;</span></pre><p>为了防止令人困惑的代码，有一个解析限制，如果 <tt class="docutils literal"><span class="pre">try</span></tt> 跟在一个 <tt class="docutils literal"><span class="pre">(</span></tt> 它必须写成一行：</p>
<pre class="listing"><span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">try</span><span class="Punctuation">:</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="StringLit">&quot;133a&quot;</span><span class="Punctuation">)</span> <span class="Keyword">except</span><span class="Punctuation">:</span> <span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="异常处理-排除从句" href="#异常处理-排除从句">排除从句</a></h2><p>在 <tt class="docutils literal"><span class="pre">except</span></tt> 子句中，可以使用以下语法访问当前异常：</p>
<pre class="listing"><span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Comment"># ...</span>
<span class="Keyword">except</span> <span class="Identifier">IOError</span> <span class="Keyword">as</span> <span class="Identifier">e</span><span class="Punctuation">:</span>
  <span class="Comment"># Now use &quot;e&quot;</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;I/O error: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">msg</span></pre><p>或者，可以使用 <tt class="docutils literal"><span class="pre">getCurrentException</span></tt> 来检索已经引发的异常：</p>
<pre class="listing"><span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Comment"># ...</span>
<span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">e</span> <span class="Operator">=</span> <span class="Identifier">getCurrentException</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Comment"># 现在使用&quot;e&quot;</span></pre><p>注意 <tt class="docutils literal"><span class="pre">getCurrentException</span></tt> 总是返回一个 <tt class="docutils literal"><span class="pre">ref Exception</span></tt> 类型。</p>
<p>如果需要一个正确类型的变量（在上面的例子中，``IOError`` ），必须明确地转换它：</p>
<pre class="listing"><span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Comment"># ...</span>
<span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">e</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">ref</span> <span class="Identifier">IOError</span><span class="Punctuation">)</span><span class="Punctuation">(</span><span class="Identifier">getCurrentException</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Comment"># &quot;e&quot;现在是合适的类型</span></pre><p>但是，这很少需要。 最常见的情况是从 <tt class="docutils literal"><span class="pre">e</span></tt> 中提取错误消息，对于这种情况，使用 <tt class="docutils literal"><span class="pre">getCurrentExceptionMsg</span></tt> 就足够了：</p>
<pre class="listing"><span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Comment"># ...</span>
<span class="Keyword">except</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">getCurrentExceptionMsg</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="异常处理-defer语句" href="#异常处理-defer语句">Defer语句</a></h2><p>可以使用 <tt class="docutils literal"><span class="pre">defer</span></tt> 语句而不是 <tt class="docutils literal"><span class="pre">try finally</span></tt> 语句。</p>
<p>当前块中 <tt class="docutils literal"><span class="pre">defer</span></tt> 之后的任何语句都将被视为隐式try块：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">main</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">defer</span><span class="Punctuation">:</span> <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
  <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;abc&quot;</span>
  <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;def&quot;</span></pre><p>被重写为：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">main</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;abc&quot;</span>
    <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;def&quot;</span>
  <span class="Keyword">finally</span><span class="Punctuation">:</span>
    <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span></pre><p>不支持顶级 <tt class="docutils literal"><span class="pre">defer</span></tt> 语句，因为不清楚这样的语句应该引用什么。</p>

<h2><a class="toc-backref" id="异常处理-raise语句" href="#异常处理-raise语句">Raise语句</a></h2><p>示例：</p>
<pre class="listing"><span class="Keyword">raise</span> <span class="Identifier">newEOS</span><span class="Punctuation">(</span><span class="StringLit">&quot;operating system failed&quot;</span><span class="Punctuation">)</span></pre><p>除了数组索引，内存分配等内置操作之外，``raise`` 语句是引发异常的唯一方法。</p>
<p>如果没有给出异常名称，则当前异常会 <span id="reminusraised_1">re-raised</span> 。 如果没有异常重新加注，则引发 <span id="reraiseerror_1">ReraiseError</span>异常。 因此， <tt class="docutils literal"><span class="pre">raise</span></tt> 语句 <em>总是</em> 引发异常。</p>

<h2><a class="toc-backref" id="异常处理-异常层级" href="#异常处理-异常层级">异常层级</a></h2><p>异常树在 <a class="reference external" href="system.html">system</a> 模块中定义。 每个异常都继承自 <tt class="docutils literal"><span class="pre">system.Exception</span></tt> 。 表示编程错误的异常继承自``system.Defect``（它是``Exception``的子类型）并严格地说是不可捕获的，因为它们也可以映射到终止整个过程的操作。 表示可以捕获的任何其他运行时错误的异常继承自 <tt class="docutils literal"><span class="pre">system.CatchableError``（这是 ``Exception</span></tt> 的子类型）。</p>

<h2><a class="toc-backref" id="异常处理-导入的异常" href="#异常处理-导入的异常">导入的异常</a></h2><p>可以引发和捕获导入的C++异常。 使用 <tt class="docutils literal"><span class="pre">importcpp</span></tt> 导入的类型可以被引发或捕获。例外是通过值引发并通过引用捕获。</p>
<p>示例：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">std_exception</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;std::exception&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;exception&gt;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>

<span class="Keyword">proc</span> <span class="Identifier">what</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">std_exception</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;((char *)#.what())&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Keyword">raise</span> <span class="Identifier">std_exception</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">except</span> <span class="Identifier">std_exception</span> <span class="Keyword">as</span> <span class="Identifier">ex</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">ex</span><span class="Operator">.</span><span class="Identifier">what</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
<h1><a class="toc-backref" id="效应系统" href="#效应系统">效应系统</a></h1>
<h2><a class="toc-backref" id="效应系统-异常跟踪" href="#效应系统-异常跟踪">异常跟踪</a></h2><p>Nim支持异常跟踪。 <span id="raises_1">raises</span> 编译器可用于显式定义允许proc/iterator/method/converter引发的异常。编译器验证这个：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">what</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="Identifier">OSError</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">what</span><span class="Punctuation">:</span> <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;IO&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;OS&quot;</span><span class="Punctuation">)</span></pre><p>一个空的 <tt class="docutils literal"><span class="pre">raises</span></tt> 列表（ <tt class="docutils literal"><span class="pre">raises：[]</span></tt> ）意味着不会引发任何异常：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Identifier">unsafeCall</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Keyword">except</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">false</span></pre><p><tt class="docutils literal"><span class="pre">raises</span></tt> 列表也可以附加到proc类型。这会影响类型兼容性：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Callback</span> <span class="Operator">=</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span>
  <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Callback</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;OS&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">p</span> <span class="Comment"># 类型错误</span></pre><p>对于例程 <tt class="docutils literal"><span class="pre">p</span></tt> ，编译器使用推理规则来确定可能引发的异常集;算法在 <tt class="docutils literal"><span class="pre">p</span></tt> 的调用图上运行：</p>
<dl class="docutils"><dt>1.通过某些proc类型 <tt class="docutils literal"><span class="pre">T</span></tt> 的每个间接调用都被假定为引发 <tt class="docutils literal"><span class="pre">system.Exception</span></tt> （异常层次结构的基本类型），因此除非 <tt class="docutils literal"><span class="pre">T</span></tt> 有明确的 <tt class="docutils literal"><span class="pre">raises</span></tt> 列表。</dt>
<dd>但是如果调用的形式是 <tt class="docutils literal"><span class="pre">f(...)</span></tt> 其中 <tt class="docutils literal"><span class="pre">f</span></tt> 是当前分析的例程的参数，则忽略它。 乐观地认为该呼叫没有效果。规则2补偿了这种情况。</dd>
</dl>
<p>2.假定在一个不是调用本身（而不是nil）的调用中的某些proc类型的每个表达式都以某种方式间接调用，因此它的引发列表被添加到 <tt class="docutils literal"><span class="pre">p</span></tt> 的引发列表中。 3.对前向声明或 <tt class="docutils literal"><span class="pre">importc</span></tt> 编译指示的未知proc <tt class="docutils literal"><span class="pre">q</span></tt> 的每次调用，假定会引发 <tt class="docutils literal"><span class="pre">system.Exception</span></tt> ，除非 <tt class="docutils literal"><span class="pre">q</span></tt> 有一个明确的 <tt class="docutils literal"><span class="pre">raises</span></tt> 列表。 4.每次对方法 <tt class="docutils literal"><span class="pre">m</span></tt> 的调用都会被假定为引发 <tt class="docutils literal"><span class="pre">system.Exception</span></tt> ，除非 <tt class="docutils literal"><span class="pre">m</span></tt> 有一个明确的 <tt class="docutils literal"><span class="pre">raises</span></tt> 列表。 5.对于每个其他调用，分析可以确定一个确切的 <tt class="docutils literal"><span class="pre">raises</span></tt> 列表。 6.为了确定 <tt class="docutils literal"><span class="pre">raises</span></tt> 列表，考虑 <tt class="docutils literal"><span class="pre">p</span></tt> 的 <tt class="docutils literal"><span class="pre">raise</span></tt> 和 <tt class="docutils literal"><span class="pre">try</span></tt> 语句。</p>
<p>规则1-2确保下面的代码正常工作：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">noRaise</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># 可能引发任何异常的未知调用, 但这是合法的:</span>
  <span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">doRaise</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;IO&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">use</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># 不能编译， 可能引发IOError。</span>
  <span class="Identifier">noRaise</span><span class="Punctuation">(</span><span class="Identifier">doRaise</span><span class="Punctuation">)</span></pre><p>因此，在许多情况下，回调不会导致编译器在其效果分析中过于保守。</p>

<h2><a class="toc-backref" id="效应系统-tag跟踪" href="#效应系统-tag跟踪">Tag跟踪</a></h2><p>异常跟踪是Nim <span id="效应系统_1">效应系统</span> 的一部分。 引发异常是 <em>效应</em> 。 其他效应也可以定义。 用户定义的效应是 <em>标记</em> 例程并对此标记执行检查的方法：</p>
<pre class="listing"><span class="Keyword">type</span> <span class="Identifier">IO</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Comment">## input/output effect</span>
<span class="Keyword">proc</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">tags</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IO</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Keyword">proc</span> <span class="Identifier">no_IO_please</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">tags</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># the compiler prevents this:</span>
  <span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>标签必须是类型名称。一个 <tt class="docutils literal"><span class="pre">tags</span></tt> 列表 - 就像一个 <tt class="docutils literal"><span class="pre">raises</span></tt> 列表 - 也可以附加到一个proc类型。 这会影响类型兼容性。</p>
<p>标签跟踪的推断类似于异常跟踪的推断。</p>

<h2><a class="toc-backref" id="效应系统-effects编译指示" href="#效应系统-effects编译指示">Effects编译指示</a></h2><p><tt class="docutils literal"><span class="pre">effects</span></tt> 编译指示旨在帮助程序员进行效果分析。 这是一个声明，使编译器将所有推断的效果输出到 <tt class="docutils literal"><span class="pre">effects</span></tt> 的位置：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">what</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">what</span><span class="Punctuation">:</span>
    <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;IO&quot;</span><span class="Punctuation">)</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">effects</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;OS&quot;</span><span class="Punctuation">)</span></pre><p>编译器生成一条提示消息，可以引发 <tt class="docutils literal"><span class="pre">IOError</span></tt> 。 未列出 <tt class="docutils literal"><span class="pre">OSError</span></tt> ，因为它不能在分支中引发 <tt class="docutils literal"><span class="pre">effects</span></tt> 编译指示。</p>

<h1><a class="toc-backref" id="泛型" href="#泛型">泛型</a></h1><p>泛型是Nim用 <span id="类型形参_1">类型形参</span> 参数化过程、迭代器或类型的方法 。 根据上下文，括号用于引入类型形参或实例化泛型过程、迭代器或类型。</p>
<p>以下示例显示了可以建模的通用二叉树：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">BinaryTree</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Comment"># 二叉树是左右子树带有泛型形参 ``T`` 的泛型类型，其值可能为nil</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span>                   <span class="Comment"># 数据存储在节点中。</span>

<span class="Keyword">proc</span> <span class="Identifier">newNode</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Comment"># 构造一个节点</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">le</span><span class="Punctuation">:</span> <span class="Keyword">nil</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Keyword">nil</span><span class="Punctuation">,</span> <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">data</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 把节点插入到一颗树</span>
  <span class="Keyword">if</span> <span class="Identifier">root</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
    <span class="Identifier">root</span> <span class="Operator">=</span> <span class="Identifier">n</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">root</span>
    <span class="Keyword">while</span> <span class="Identifier">it</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
      <span class="Comment"># 比较数据项;使用泛型 ``cmp`` proc，适用于任何具有``==``和````运算符的类型</span>
      <span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">)</span>
      <span class="Keyword">if</span> <span class="Identifier">c</span> <span class="Operator">&lt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
        <span class="Keyword">if</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
          <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">=</span> <span class="Identifier">n</span>
          <span class="Keyword">return</span>
        <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span>
      <span class="Keyword">else</span><span class="Punctuation">:</span>
        <span class="Keyword">if</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
          <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">=</span> <span class="Identifier">n</span>
          <span class="Keyword">return</span>
        <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 便利过程:</span>
  <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="Identifier">newNode</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">iterator</span> <span class="Identifier">preorder</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Comment"># 前序遍历二叉树</span>
  <span class="Comment"># 由于递归迭代器尚未实现，因此它使用显式堆栈（因为更高效）：</span>
  <span class="Keyword">var</span> <span class="Identifier">stack</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="Identifier">root</span><span class="Punctuation">]</span>
  <span class="Keyword">while</span> <span class="Identifier">stack</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&gt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">stack</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Keyword">while</span> <span class="Identifier">n</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
      <span class="Keyword">yield</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span>
      <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">stack</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">ri</span><span class="Punctuation">)</span>  <span class="Comment"># 将右子树推入堆栈</span>
      <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">le</span>          <span class="Comment"># 跟着左指针</span>

<span class="Keyword">var</span>
  <span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Comment"># 使用 ``string`` 实例化二叉树</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="Identifier">newNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;hello&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Comment"># 实例化 ``newNode`` 和 ``add``</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="StringLit">&quot;world&quot;</span><span class="Punctuation">)</span>          <span class="Comment"># 实例化第二个 ``add`` proc</span>
<span class="Keyword">for</span> <span class="Identifier">str</span> <span class="Keyword">in</span> <span class="Identifier">preorder</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">str</span><span class="Punctuation">)</span></pre><p><tt class="docutils literal"><span class="pre">T</span></tt> 被称为 <span id="泛型类型形参_1">泛型类型形参</span> 或 <span id="类型变量_1">类型变量</span> 。</p>

<h2><a class="toc-backref" id="泛型-is操作符" href="#泛型-is操作符">Is操作符</a></h2><p>在语义分析期间评估 <tt class="docutils literal"><span class="pre">is</span></tt> 运算符以检查类型等价。 因此，它对于泛型代码中的类型特化非常有用：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">Key</span><span class="Punctuation">,</span> <span class="Identifier">Value</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">keys</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Key</span><span class="Punctuation">]</span>
    <span class="Identifier">values</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Value</span><span class="Punctuation">]</span>
    <span class="Keyword">when</span> <span class="Keyword">not</span> <span class="Punctuation">(</span><span class="Identifier">Key</span> <span class="Keyword">is</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Comment"># 用于优化的字符串的空值</span>
      <span class="Identifier">deletedKeys</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">bool</span><span class="Punctuation">]</span></pre>
<h2><a class="toc-backref" id="泛型-类型类别" href="#泛型-类型类别">类型类别</a></h2><p>类型类是一种特殊的伪类型，可用于匹配重载决策或 <tt class="docutils literal"><span class="pre">is</span></tt> 运算符中的类型。 Nim支持以下内置类型类：</p>
<table border="1" class="docutils"><tr><th>类型</th><th>匹配</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">object</span></tt></td><td>任意对象类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">tuple</span></tt></td><td>任意元组类型</td></tr>
<tr><td></td><td></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">enum</span></tt></td><td>任意枚举</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">proc</span></tt></td><td>任意过程类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">ref</span></tt></td><td>任意 <tt class="docutils literal"><span class="pre">ref</span></tt> 类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">ptr</span></tt></td><td>任意 <tt class="docutils literal"><span class="pre">ptr</span></tt> 类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">var</span></tt></td><td>任意 <tt class="docutils literal"><span class="pre">var</span></tt> 类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">distinct</span></tt></td><td>任意distinct类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">array</span></tt></td><td>任意数组array类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">set</span></tt></td><td>任意set类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">seq</span></tt></td><td>任意seq类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">auto</span></tt></td><td>任意类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">any</span></tt></td><td>distinct auto (见下方)</td></tr>
</table><p>此外，每个泛型类型都会自动创建一个与通用类型的任何实例化相匹配的相同名称的类型类。</p>
<p>可以使用标准布尔运算符组合类型类，以形成更复杂的类型类：</p>
<pre class="listing"><span class="Comment"># 创建一个匹配所有元组和对象类型的类型类</span>
<span class="Keyword">type</span> <span class="Identifier">RecordType</span> <span class="Operator">=</span> <span class="Keyword">tuple</span> <span class="Keyword">or</span> <span class="Keyword">object</span>

<span class="Keyword">proc</span> <span class="Identifier">printFields</span><span class="Punctuation">(</span><span class="Identifier">rec</span><span class="Punctuation">:</span> <span class="Identifier">RecordType</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">key</span><span class="Punctuation">,</span> <span class="Identifier">value</span> <span class="Keyword">in</span> <span class="Identifier">fieldPairs</span><span class="Punctuation">(</span><span class="Identifier">rec</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Identifier">key</span><span class="Punctuation">,</span> <span class="StringLit">&quot; = &quot;</span><span class="Punctuation">,</span> <span class="Identifier">value</span></pre><p>以这种方式使用类型类的过程被认为是 <span id="隐式通用的_1">隐式通用的</span> 。 对于程序中使用的每个唯一的param类型组合，它们将被实例化一次。</p>
<p>虽然类型类的语法看起来类似于ML的语言中的ADT /代数数据类型，但应该理解类型类是类型实例化时强制执行的静态约束。 类型类不是真正的类型，而是一个提供通用“检查”的系统，最终将 <em>解析</em> 为某种单一类型。 与对象变体或方法不同，类型类不允许运行时类型动态。</p>
<p>例如，以下内容无法编译：</p>
<pre class="listing"><span class="Keyword">type</span> <span class="Identifier">TypeClass</span> <span class="Operator">=</span> <span class="Identifier">int</span> <span class="Operator">|</span> <span class="Identifier">string</span>
<span class="Keyword">var</span> <span class="Identifier">foo</span><span class="Punctuation">:</span> <span class="Identifier">TypeClass</span> <span class="Operator">=</span> <span class="DecNumber">2</span> <span class="Comment"># foo的类型在这里解析为int</span>
<span class="Identifier">foo</span> <span class="Operator">=</span> <span class="StringLit">&quot;this will fail&quot;</span> <span class="Comment"># 错误在这里，因为foo是一个int</span></pre><p>Nim允许将类型类和常规类型指定为 <span id="类型限制_1">类型限制</span> 泛型类型参数：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">onlyIntOrString</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Operator">|</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">onlyIntOrString</span><span class="Punctuation">(</span><span class="DecNumber">450</span><span class="Punctuation">,</span> <span class="DecNumber">616</span><span class="Punctuation">)</span> <span class="Comment"># 合法</span>
<span class="Identifier">onlyIntOrString</span><span class="Punctuation">(</span><span class="FloatNumber">5.0</span><span class="Punctuation">,</span> <span class="FloatNumber">0.0</span><span class="Punctuation">)</span> <span class="Comment"># 类型不匹配</span>
<span class="Identifier">onlyIntOrString</span><span class="Punctuation">(</span><span class="StringLit">&quot;xy&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">50</span><span class="Punctuation">)</span> <span class="Comment"># 不合法因为 'T' 不能同时是两种类型</span></pre><p>默认情况下，在重载解析期间，每个命名类型类将仅绑定到一个具体类型。 我们称这样的类类为 <span id="绑定一次_1">绑定一次</span> 类型。 以下是直接从系统模块中抽取的用于展示的示例：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Comment">## 要求 `x` and `y` 是同样的元组类型</span>
  <span class="Comment">## 从 `x` 和 `y` 部分中提升的元组泛型 ``==`` 操作符。</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Keyword">for</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Identifier">fields</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">if</span> <span class="Identifier">a</span> <span class="Operator">!=</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">false</span></pre><p>或者，可以将 <tt class="docutils literal"><span class="pre">distinct</span></tt> 类型修饰符应用于类型类，以允许与类型类匹配的每个参数绑定到不同的类型。 这种类型类称为 <span id="绑定多次_1">绑定多次</span> 类型</p>
<p>使用隐式通用样式编写的过程通常需要引用匹配泛型类型的类型参数。 可以使用点语法轻松访问它们：</p>
<pre class="listing"><span class="Keyword">type</span> <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">,</span> <span class="Identifier">Rows</span><span class="Punctuation">,</span> <span class="Identifier">Columns</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Operator">...</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">m</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">,</span> <span class="Identifier">row</span><span class="Punctuation">,</span> <span class="Identifier">col</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Operator">.</span><span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">[</span><span class="Identifier">col</span> <span class="Operator">*</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">Matrix</span><span class="Operator">.</span><span class="Identifier">Columns</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">row</span><span class="Punctuation">]</span></pre><p>或者，当使用匿名或不同类型类时，可以在proc参数上使用 <tt class="docutils literal"><span class="pre">type</span></tt> 运算符以获得类似的效果。</p>
<p>当使用类型类而不是具体类型实例化泛型类型时，这会产生另一个更具体的类型类：</p>
<pre class="listing"><span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Keyword">ref</span> <span class="Keyword">object</span><span class="Punctuation">]</span>  <span class="Comment"># 存储任意对象类型引用的序列</span>

<span class="Keyword">type</span> <span class="Identifier">T1</span> <span class="Operator">=</span> <span class="Identifier">auto</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T1</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">T1</span><span class="Punctuation">)</span>
  <span class="Comment"># seq[T1]与 `seq` 相同，但T1允许当签名匹配时绑定到单个类型</span>

<span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="Identifier">Ordinal</span><span class="Punctuation">]</span> <span class="Comment"># 任何使用整数值的矩阵实例化</span></pre><p>如前面的例子所示，在这样的实例化中，没有必要提供泛型类型的所有类型参数，因为任何缺失的参数都将被推断为具有 <tt class="docutils literal"><span class="pre">any</span></tt> 类型的等价物，因此它们将匹配任何类型而不受歧视。</p>

<h2><a class="toc-backref" id="泛型-泛型推导限制" href="#泛型-泛型推导限制">泛型推导限制</a></h2><p>类型 <tt class="docutils literal"><span class="pre">var T</span></tt> 和 <tt class="docutils literal"><span class="pre">typedesc [T]</span></tt> 不能在泛型实例中推断出来。以下是不允许的：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">g</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">;</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">c</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="Identifier">y</span>
<span class="Keyword">proc</span> <span class="Identifier">v</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">y</span> <span class="Operator">+=</span> <span class="DecNumber">100</span>
<span class="Keyword">var</span> <span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Comment"># 允许：推断 'T' 为 'int' 类型</span>
<span class="Identifier">g</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="DecNumber">42</span><span class="Punctuation">)</span>

<span class="Comment"># 无效：'T'不推断为'var int'类型</span>
<span class="Identifier">g</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">,</span> <span class="Identifier">i</span><span class="Punctuation">)</span>

<span class="Comment"># 也不允许：通过'var int'进行显式实例化</span>
<span class="Identifier">g</span><span class="Punctuation">[</span><span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">,</span> <span class="Identifier">i</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="泛型-泛型符号查找" href="#泛型-泛型符号查找">泛型符号查找</a></h2>
<h3><a class="toc-backref" id="泛型符号查找-开放和封闭的符号" href="#泛型符号查找-开放和封闭的符号">开放和封闭的符号</a></h3><p>泛型中的符号绑定规则比较微妙：有“开放”和“封闭”符号。 “封闭”符号不能在实例化上下文中重新绑定，“开放”符号可以。 默认重载符号是打开的，每个其他符号都是关闭的。</p>
<p>在两个不同的上下文中查找开放符号：定义上下文和实例化时的上下文都被考虑：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Index</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Index</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="FloatNumber">0.</span><span class="Identifier">Index</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="FloatNumber">0.</span><span class="Identifier">Index</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span> <span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span> <span class="Comment"># 可以了</span></pre><p>在示例中，元组的通用 <tt class="docutils literal"><span class="pre">==</span></tt> （在系统模块中定义）使用元组组件的 <tt class="docutils literal"><span class="pre">==</span></tt> 运算符。 但是， <tt class="docutils literal"><span class="pre">Index</span></tt> 类型的 <tt class="docutils literal"><span class="pre">==</span></tt> 是在元组的 <tt class="docutils literal"><span class="pre">==</span></tt>  <em>之后</em> 定义的;然而，该示例编译为实例化也将当前定义的符号考虑在内。</p>

<h2><a class="toc-backref" id="泛型-mixin语句" href="#泛型-mixin语句">Mixin语句</a></h2><p>可以通过 <span id="mixin_1">mixin</span> 强制打开符号声明:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">create</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Comment"># 这里没有重载'init'，所以我们需要明确说明它是一个开放的符号：</span>
  <span class="Keyword">mixin</span> <span class="Identifier">init</span>
  <span class="Identifier">new</span> <span class="Identifier">result</span>
  <span class="Identifier">init</span> <span class="Identifier">result</span></pre><p><tt class="docutils literal"><span class="pre">mixin</span></tt> 语句只在模板和泛型中有意义。</p>

<h2><a class="toc-backref" id="泛型-bind语句" href="#泛型-bind语句">Bind语句</a></h2><p><tt class="docutils literal"><span class="pre">bind</span></tt> 语句是 <tt class="docutils literal"><span class="pre">mixin</span></tt> 语句的对应语句。 它可以用于显式声明应该提前绑定的标识符（即标识符应该在模板/泛型定义的范围内查找）：</p>
<pre class="listing"><span class="Comment"># 模块A</span>
<span class="Keyword">var</span>
  <span class="Identifier">lastId</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">template</span> <span class="Identifier">genId</span><span class="Operator">*:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Keyword">bind</span> <span class="Identifier">lastId</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">lastId</span><span class="Punctuation">)</span>
  <span class="Identifier">lastId</span></pre><pre class="listing"><span class="Comment"># 模块B</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>

<span class="Identifier">echo</span> <span class="Identifier">genId</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>但是 <tt class="docutils literal"><span class="pre">bind</span></tt> 很少有用，因为符号绑定默认来自定义的作用域。 <tt class="docutils literal"><span class="pre">bind</span></tt> 语句只在模板和泛型中有意义。</p>

<h1><a class="toc-backref" id="模板" href="#模板">模板</a></h1><p>模板是宏的一种简单形式：它是一种简单的替换机制，可以在Nim的抽象语法树上运行。 它在编译器的语义传递中处理。</p>
<p><em>调用</em> 模板的语法与调用过程相同。</p>
<p>示例：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Punctuation">`</span><span class="Operator">!=</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Comment"># 此定义存在于系统模块中</span>
  <span class="Keyword">not</span> <span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="DecNumber">5</span> <span class="Operator">!=</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Comment"># 编译器将其重写为：: assert(not (5 == 6))</span></pre><p><tt class="docutils literal"><span class="pre">!=</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;=</span></tt>, <tt class="docutils literal"><span class="pre">in</span></tt>, <tt class="docutils literal"><span class="pre">notin</span></tt>, <tt class="docutils literal"><span class="pre">isnot</span></tt> 运算符实际上是模板：</p>
<p><tt class="docutils literal"><span class="pre">a &gt; b</span></tt> 变换成 <tt class="docutils literal"><span class="pre">b &lt; a</span></tt>.<br /><tt class="docutils literal"><span class="pre">a in b</span></tt> 变换成 <tt class="docutils literal"><span class="pre">contains(b, a)</span></tt>.<br /><tt class="docutils literal"><span class="pre">notin</span></tt> 和 <tt class="docutils literal"><span class="pre">isnot</span></tt> 见名知意。<br /></p><p>模板的“类型”可以是符号 <tt class="docutils literal"><span class="pre">untyped</span></tt> ， <tt class="docutils literal"><span class="pre">typed</span></tt> 或 <tt class="docutils literal"><span class="pre">typedesc</span></tt> 。 这些是“元类型”，它们只能在某些上下文中使用。 也可以使用常规类型;这意味着需要 <tt class="docutils literal"><span class="pre">typed</span></tt> 表达式。</p>

<h2><a class="toc-backref" id="模板-类型化和无类型形参" href="#模板-类型化和无类型形参">类型化和无类型形参</a></h2><p><tt class="docutils literal"><span class="pre">无类型</span></tt> 参数表示在将表达式传递给模板之前不执行符号查找和类型解析。 这意味着例如 <em>未声明</em> 标识符可以传递给模板：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 有效</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">3</span></pre><pre class="listing"><span class="Keyword">template</span> <span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typed</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 无效，因为x尚未声明，因此没有类型</span></pre><p>每个参数都是 <tt class="docutils literal"><span class="pre">无类型</span></tt> 的模板称为 <span id="立即_1">立即</span> 模板。 由于历史原因模板可以使用 <tt class="docutils literal"><span class="pre">立即</span></tt> 编译指示进行显式注释，然后这些模板不会参与重载分辨率，编译器会 <em>忽略</em> 参数的类型。 现在不推荐使用显式立即模板。</p>
<p><strong>注意</strong>: 由于历史原因 <tt class="docutils literal"><span class="pre">stmt</span></tt> 是类型化 <tt class="docutils literal"><span class="pre">typed</span></tt> 的别名， <tt class="docutils literal"><span class="pre">expr</span></tt> 是无类型 <tt class="docutils literal"><span class="pre">untyped</span></tt> 的别名, 但他们被移除了。</p>

<h2><a class="toc-backref" id="模板-向模板传代码块" href="#模板-向模板传代码块">向模板传代码块</a></h2><p>您可以在特殊的 <tt class="docutils literal"><span class="pre">:</span></tt> 语法之后将一个语句块作为最后一个参数传递给模板：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">,</span> <span class="Identifier">actions</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
  <span class="Keyword">if</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">try</span><span class="Punctuation">:</span>
      <span class="Identifier">actions</span>
    <span class="Keyword">finally</span><span class="Punctuation">:</span>
      <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;cannot open: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">fn</span><span class="Punctuation">)</span>

<span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">txt</span><span class="Punctuation">,</span> <span class="StringLit">&quot;ttempl3.txt&quot;</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span><span class="Punctuation">:</span>  <span class="Comment"># 特殊冒号</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 1&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 2&quot;</span><span class="Punctuation">)</span></pre><p>在这个例子中，两个 <tt class="docutils literal"><span class="pre">writeLine</span></tt> 语句绑定到 <tt class="docutils literal"><span class="pre">actions</span></tt> 参数。</p>
<p>通常将一块代码传递给模板，接受块的参数需要是“untyped”类型。 因为符号查找会延迟到模板实例化时间：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">(</span><span class="Identifier">body</span><span class="Punctuation">:</span> <span class="Identifier">typed</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">block</span><span class="Punctuation">:</span>
    <span class="Identifier">body</span>

<span class="Identifier">t</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span>

<span class="Identifier">t</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">2</span>  <span class="Comment"># '尝试重新声明i'失败</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span></pre><p>上面的代码因已经声明了 <tt class="docutils literal"><span class="pre">i</span></tt> 的错误信息失败。 原因是 <tt class="docutils literal"><span class="pre">var i = ...</span></tt> 需要在传递给 <tt class="docutils literal"><span class="pre">body</span></tt> 参数之前进行类型检查，而Nim中的类型检查意味着符号查找。 为了使符号查找成功，需要将 <tt class="docutils literal"><span class="pre">i</span></tt> 添加到当前（即外部）范围。 在类型检查之后，这些对符号表的添加不会回滚（无论好坏）。 同样的代码可以用 <tt class="docutils literal"><span class="pre">untyped</span></tt> ，因为传递的主体不需要进行类型检查：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">(</span><span class="Identifier">body</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">block</span><span class="Punctuation">:</span>
    <span class="Identifier">body</span>

<span class="Identifier">t</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span>

<span class="Identifier">t</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">2</span>  <span class="Comment"># 编译</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span></pre>
<h2><a class="toc-backref" id="模板-无类型可变参数" href="#模板-无类型可变参数">无类型可变参数</a></h2><p>除了 <tt class="docutils literal"><span class="pre">untyped</span></tt> 元类型防止类型检查之外， <tt class="docutils literal"><span class="pre">varargs[untyped]</span></tt> 甚至连参数的数量都可以不确定：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">hideIdentifiers</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">untyped</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">hideIdentifiers</span><span class="Punctuation">(</span><span class="Identifier">undeclared1</span><span class="Punctuation">,</span> <span class="Identifier">undeclared2</span><span class="Punctuation">)</span></pre><p>但是，由于模板无法通过varargs进行迭代，因此该功能通常对宏非常有用。</p>

<h2><a class="toc-backref" id="模板-模板符号绑定" href="#模板-模板符号绑定">模板符号绑定</a></h2><p>模板是 <span id="卫生_1">卫生</span> 宏，它打开了一个新的作用域。大多数符号都是从模板的定义作用域绑定的：</p>
<pre class="listing"><span class="Comment"># 模块A</span>
<span class="Keyword">var</span>
  <span class="Identifier">lastId</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">template</span> <span class="Identifier">genId</span><span class="Operator">*:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">lastId</span><span class="Punctuation">)</span>
  <span class="Identifier">lastId</span></pre><pre class="listing"><span class="Comment"># 模块B</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>

<span class="Identifier">echo</span> <span class="Identifier">genId</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># 'lastId'已被'genId'的定义作用域所约束</span></pre><p>在泛型中，``mixin`` 或 <tt class="docutils literal"><span class="pre">bind</span></tt> 语句可以影响符号绑定。</p>

<h2><a class="toc-backref" id="模板-标识符构造" href="#模板-标识符构造">标识符构造</a></h2><p>在模板中，可以使用反引号表示法构造标识符：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">typedef</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">,</span> <span class="Identifier">typ</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">type</span>
    <span class="Punctuation">`</span><span class="Identifier">T</span> <span class="Identifier">name</span><span class="Punctuation">`</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">typ</span>
    <span class="Punctuation">`</span><span class="Identifier">P</span> <span class="Identifier">name</span><span class="Punctuation">`</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Punctuation">`</span><span class="Identifier">T</span> <span class="Identifier">name</span><span class="Punctuation">`</span>

<span class="Identifier">typedef</span><span class="Punctuation">(</span><span class="Identifier">myint</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">PMyInt</span></pre><p>示例中 <tt class="docutils literal"><span class="pre">name</span></tt> 用 <tt class="docutils literal"><span class="pre">myint</span></tt> 实例化，所以 `T name` 变为 <tt class="docutils literal"><span class="pre">Tmyint</span></tt> 。</p>

<h2><a class="toc-backref" id="模板-模板形参查询规则" href="#模板-模板形参查询规则">模板形参查询规则</a></h2><p>模板中的参数 <tt class="docutils literal"><span class="pre">p</span></tt> 甚至在表达式 <tt class="docutils literal"><span class="pre">x.p</span></tt> 中被替换。 因此，模板参数可以用作字段名称，也可以使用相同的参数名称对限定的全局符号进行隐藏：</p>
<pre class="listing"><span class="Comment"># 模块'm'</span>

<span class="Keyword">type</span>
  <span class="Identifier">Lev</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">levA</span><span class="Punctuation">,</span> <span class="Identifier">levB</span>

<span class="Keyword">var</span> <span class="Identifier">abclev</span> <span class="Operator">=</span> <span class="Identifier">levB</span>

<span class="Keyword">template</span> <span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">abclev</span><span class="Punctuation">:</span> <span class="Identifier">Lev</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">abclev</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">abclev</span>

<span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">levA</span><span class="Punctuation">)</span>
<span class="Comment"># 生成: 'levA levA'</span></pre><p>但是可以通过 <tt class="docutils literal"><span class="pre">bind</span></tt> 语句正确捕获全局符号：</p>
<pre class="listing"><span class="Comment"># 模块'm'</span>

<span class="Keyword">type</span>
  <span class="Identifier">Lev</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">levA</span><span class="Punctuation">,</span> <span class="Identifier">levB</span>

<span class="Keyword">var</span> <span class="Identifier">abclev</span> <span class="Operator">=</span> <span class="Identifier">levB</span>

<span class="Keyword">template</span> <span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">abclev</span><span class="Punctuation">:</span> <span class="Identifier">Lev</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">bind</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">abclev</span>
  <span class="Identifier">echo</span> <span class="Identifier">abclev</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">abclev</span>

<span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">levA</span><span class="Punctuation">)</span>
<span class="Comment"># 生成: 'levA levB'</span></pre>
<h2><a class="toc-backref" id="模板-模板卫生" href="#模板-模板卫生">模板卫生</a></h2><p>每个默认模板是 <span id="卫生的_1">卫生的</span>: 无法在实例化上下文中访问模板中声明的本地标识符：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">newException</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">exceptn</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">,</span> <span class="Identifier">message</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Keyword">var</span>
    <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">exceptn</span>  <span class="Comment"># e是隐式符号生成</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">)</span>
  <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">msg</span> <span class="Operator">=</span> <span class="Identifier">message</span>
  <span class="Identifier">e</span>

<span class="Comment"># 所以这是可以的:</span>
<span class="Keyword">let</span> <span class="Identifier">e</span> <span class="Operator">=</span> <span class="StringLit">&quot;message&quot;</span>
<span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IoError</span><span class="Punctuation">,</span> <span class="Identifier">e</span><span class="Punctuation">)</span></pre><p>是否在模板中声明的符号是否暴露给实例化范围由 <span id="inject_1">inject</span> 和 <span id="gensym_1">gensym</span> 编译指示控制，gensym的符号不会暴露而是注入。 <tt class="docutils literal"><span class="pre">type</span></tt>, <tt class="docutils literal"><span class="pre">var</span></tt>, <tt class="docutils literal"><span class="pre">let</span></tt> 和 <tt class="docutils literal"><span class="pre">const</span></tt> 的实体符号默认是 <tt class="docutils literal"><span class="pre">gensym</span></tt> ，``proc``, <tt class="docutils literal"><span class="pre">iterator</span></tt>, <tt class="docutils literal"><span class="pre">converter</span></tt>, <tt class="docutils literal"><span class="pre">template</span></tt>, <tt class="docutils literal"><span class="pre">macro</span></tt> 是 <tt class="docutils literal"><span class="pre">inject</span></tt>. 但是，如果实体的名称作为模板参数传递，则它是一个注入符号：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">,</span> <span class="Identifier">actions</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Keyword">block</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>  <span class="Comment"># 因为'f'是模板形参，它被隐式注入</span>
    <span class="Operator">...</span>

<span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">txt</span><span class="Punctuation">,</span> <span class="StringLit">&quot;ttempl3.txt&quot;</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 1&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 2&quot;</span><span class="Punctuation">)</span></pre><p><tt class="docutils literal"><span class="pre">inject</span></tt> 和 <tt class="docutils literal"><span class="pre">gensym</span></tt> 编译指示是二等注释;它们在模板定义之外没有语义，不能被抽象：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span> <span class="Identifier">myInject</span><span class="Punctuation">:</span> <span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">myInject</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># 不行</span></pre><p>为了摆脱模板中的卫生，可以为模板使用 <span id="dirty_1">dirty</span> 编译指示。 <tt class="docutils literal"><span class="pre">inject</span></tt> 和 <tt class="docutils literal"><span class="pre">gensym</span></tt> 在 <tt class="docutils literal"><span class="pre">dirty</span></tt> 模板中没有意义。</p>

<h2><a class="toc-backref" id="模板-方法调用语法限制" href="#模板-方法调用语法限制">方法调用语法限制</a></h2><p><tt class="docutils literal"><span class="pre">x.f</span></tt> 中的表达式 <tt class="docutils literal"><span class="pre">x</span></tt> 需要进行语义检查（即符号查找和类型检查），然后才能确定需要将其重写为 <tt class="docutils literal"><span class="pre">f（x）</span></tt> 。 因此，当用于调用模板/宏时，点语法有一些限制：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">declareVar</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">const</span> <span class="Identifier">name</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="DecNumber">45</span>

<span class="Comment"># 不能编译:</span>
<span class="Identifier">unknownIdentifier</span><span class="Operator">.</span><span class="Identifier">declareVar</span></pre><p>另一个常见的例子是：</p>
<pre class="listing"><span class="Keyword">from</span> <span class="Identifier">sequtils</span> <span class="Keyword">import</span> <span class="Identifier">toSeq</span>

<span class="Keyword">iterator</span> <span class="Identifier">something</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Keyword">yield</span> <span class="StringLit">&quot;Hello&quot;</span>
  <span class="Keyword">yield</span> <span class="StringLit">&quot;World&quot;</span>

<span class="Keyword">var</span> <span class="Identifier">info</span> <span class="Operator">=</span> <span class="Identifier">something</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">toSeq</span></pre><p>这里的问题是编译器已经决定 <tt class="docutils literal"><span class="pre">something()</span></tt> 作为迭代器在 <tt class="docutils literal"><span class="pre">toSeq</span></tt> 将其转换为序列之前不可调用。</p>

<h1><a class="toc-backref" id="宏" href="#宏">宏</a></h1><p>宏是在编译时执行的特殊函数。 通常，宏的输入是传递给它的代码的抽象语法树（AST）。 然后，宏可以对其进行转换并返回转换后的AST。 这可用于添加自定义语言功能并实现 <span id="领域特定语言（dsl）_1">领域特定语言（DSL）</span> 。</p>
<p>宏调用是一种语义分析 <em>不</em> 会完全从上到下，从左到右进行的情况。相反，语义分析至少发生两次：</p>
<ul class="simple"><li>语义分析识别并解析宏调用。</li>
<li>编译器执行宏体（可以调用其他触发器）。</li>
<li>它将宏调用的AST替换为宏返回的AST。</li>
<li>它重复了代码区域的语义分析。</li>
<li>如果宏返回的AST包含其他宏调用，则此过程将进行迭代。</li>
</ul>
<p>虽然宏启用了高级编译时代码转换，但它们无法更改Nim的语法。 但是，这并不是真正的限制因为Nim的语法无论如何都足够灵活。</p>

<h2><a class="toc-backref" id="宏-debug示例" href="#宏-debug示例">Debug示例</a></h2><p>以下示例实现了一个强大的 <tt class="docutils literal"><span class="pre">debug</span></tt> 命令，该命令接受可变数量的参数：</p>
<pre class="listing"><span class="Comment"># 使用Nim语法树，我们需要一个在``macros``模块中定义的API：</span>
<span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">args</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">untyped</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Comment"># `args` 是 `NimNode` 值的集合，每个值都包含宏的参数的AST。</span>
  <span class="Comment"># 宏总是必须返回一个 `NimNode` 。</span>
  <span class="Comment"># 类型为 `nnkStmtList` 的节点适用于此用例。</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">nnkStmtList</span><span class="Operator">.</span><span class="Identifier">newTree</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Comment"># 迭代传递给此宏的任何参数：</span>
  <span class="Keyword">for</span> <span class="Identifier">n</span> <span class="Keyword">in</span> <span class="Identifier">args</span><span class="Punctuation">:</span>
    <span class="Comment"># 添加对写入表达式的语句列表的调用;</span>
    <span class="Comment"># `toStrLit` 将AST转换为其字符串表示形式：</span>
    <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;write&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">repr</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Comment"># 添加对写入“：”的语句列表的调用</span>
    <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;write&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Comment"># 添加对写入表达式值的语句列表的调用：</span>
    <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;writeLine&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string&quot;</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">45</span>

<span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>宏调用扩展成：</p>
<pre class="listing"><span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[0]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[1]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;x&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>传递给 <tt class="docutils literal"><span class="pre">varargs</span></tt> 参数的参数包含在数组构造函数表达式中。 这就是为什么 <tt class="docutils literal"><span class="pre">debug</span></tt> 遍历所有 <tt class="docutils literal"><span class="pre">n</span></tt> 的子节点。</p>

<h2><a class="toc-backref" id="宏-bindsym" href="#宏-bindsym">BindSym</a></h2><p>上面的 <tt class="docutils literal"><span class="pre">debug</span></tt> 宏依赖于 <tt class="docutils literal"><span class="pre">write</span></tt> ， <tt class="docutils literal"><span class="pre">writeLine</span></tt> 和 <tt class="docutils literal"><span class="pre">stdout</span></tt> 在系统模块中声明的事实，因此在实例化的上下文中可见。 有一种方法可以使用绑定标识符（又名 <span id="符号_1">符号</span>)而不是使用未绑定的标识符。 内置的 <tt class="docutils literal"><span class="pre">bindSym</span></tt> 可以用于：</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">typed</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newNimNode</span><span class="Punctuation">(</span><span class="Identifier">nnkStmtList</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">x</span> <span class="Keyword">in</span> <span class="Identifier">n</span><span class="Punctuation">:</span>
    <span class="Comment"># 我们可以在作用域中通过'bindSym'绑定符号:</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;write&quot;</span><span class="Punctuation">,</span> <span class="RawData">bindSym&quot;stdout&quot;</span><span class="Punctuation">,</span> <span class="Identifier">toStrLit</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;write&quot;</span><span class="Punctuation">,</span> <span class="RawData">bindSym&quot;stdout&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newStrLitNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;writeLine&quot;</span><span class="Punctuation">,</span> <span class="RawData">bindSym&quot;stdout&quot;</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string&quot;</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">45</span>

<span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>宏调用扩展为：</p>
<pre class="listing"><span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[0]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[1]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;x&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>但是，符号 <tt class="docutils literal"><span class="pre">write</span></tt> ， <tt class="docutils literal"><span class="pre">writeLine</span></tt> 和 <tt class="docutils literal"><span class="pre">stdout</span></tt> 已经绑定，不再被查找。如示例所示， <tt class="docutils literal"><span class="pre">bindSym</span></tt> 可以隐式地处理重载符号。</p>

<h2><a class="toc-backref" id="宏-caseminusof宏" href="#宏-caseminusof宏">Case-Of宏</a></h2><p>在Nim中，可以使用具有 <em>case-of</em> 表达式的语法的宏，区别在于所有分支都传递给宏实现并由宏实现处理。 然后是宏实现将 <em>of-branches</em> 转换为有效的Nim语句。 以下示例应显示如何将此功能用于词法分析器。</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">case_token</span><span class="Punctuation">(</span><span class="Identifier">args</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">untyped</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">args</span><span class="Operator">.</span><span class="Identifier">treeRepr</span>
  <span class="Comment"># 从正则表达式创建词法分析器</span>
  <span class="Comment"># ... (实现留给读者作为练习 ;-)</span>
  <span class="Keyword">discard</span>

<span class="Identifier">case_token</span><span class="Punctuation">:</span> <span class="Comment"># 这个冒号告诉解析器它是一个宏语句</span>
<span class="Keyword">of</span> <span class="RawData">r&quot;[A-Za-z_]+[A-Za-z_0-9]*&quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkIdentifier</span>
<span class="Keyword">of</span> <span class="RawData">r&quot;0-9+&quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkInteger</span>
<span class="Keyword">of</span> <span class="RawData">r&quot;[\+\-\*\?]+&quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkOperator</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkUnknown</span></pre><p><strong>风格注释</strong> ：为了代码可读性，最好使用功能最少但仍然足够的编程结构。所以“检查清单”是：</p>
<ol class="simple"><li>如果可能，请使用普通的proc和iterator。</li>
<li>否则：如果可能，使用泛型的proc和iterator。</li>
<li>否则：如果可能，请使用模板。</li>
<li>否则：使用宏。</li>
</ol>

<h2><a class="toc-backref" id="宏-macros用作编译指示" href="#宏-macros用作编译指示">Macros用作编译指示</a></h2><p>整个例程（procs，iterators等）也可以通过编译指示表示法传递给模板或宏：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">m</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">m</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre><p>这是一个简单的语法转换：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">m</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">m</span><span class="Punctuation">:</span>
  <span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre>
<h2><a class="toc-backref" id="宏-for循环宏" href="#宏-for循环宏">For循环宏</a></h2><p>一个宏作为唯一的输入参数，特殊类型 <tt class="docutils literal"><span class="pre">system.ForLoopStmt</span></tt> 的表达式可以重写整个 <tt class="docutils literal"><span class="pre">for</span></tt> 循环：</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">macros</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;forLoopMacros&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">macro</span> <span class="Identifier">enumerate</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">ForLoopStmt</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">expectKind</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">nnkForStmt</span>
  <span class="Comment"># 我们剥离第一个for循环变量并将其用作整数计数器：</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newStmtList</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newVarStmt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span> <span class="Identifier">body</span> <span class="Operator">=</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">1</span><span class="Punctuation">]</span>
  <span class="Keyword">if</span> <span class="Identifier">body</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">!=</span> <span class="Identifier">nnkStmtList</span><span class="Punctuation">:</span>
    <span class="Identifier">body</span> <span class="Operator">=</span> <span class="Identifier">newTree</span><span class="Punctuation">(</span><span class="Identifier">nnkStmtList</span><span class="Punctuation">,</span> <span class="Identifier">body</span><span class="Punctuation">)</span>
  <span class="Identifier">body</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;inc&quot;</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span> <span class="Identifier">newFor</span> <span class="Operator">=</span> <span class="Identifier">newTree</span><span class="Punctuation">(</span><span class="Identifier">nnkForStmt</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">3</span><span class="Punctuation">:</span>
    <span class="Identifier">newFor</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
  <span class="Comment"># 将枚举（X）转换为'X'</span>
  <span class="Identifier">newFor</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">2</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span>
  <span class="Identifier">newFor</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">body</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newFor</span>
  <span class="Comment"># 现在将整个宏包装在一个块中以创建一个新的作用域</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">quote</span> <span class="Keyword">do</span><span class="Punctuation">:</span>
    <span class="Keyword">block</span><span class="Punctuation">:</span> <span class="Punctuation">`</span><span class="Identifier">result</span><span class="Punctuation">`</span>

<span class="Keyword">for</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Identifier">enumerate</span><span class="Punctuation">(</span><span class="Identifier">items</span><span class="Punctuation">(</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">b</span>

<span class="Comment"># 没有将宏包装在一个块中，我们需要在这里为 `a` 和 `b` 选择不同的名称以避免重定义错误</span>
<span class="Keyword">for</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Identifier">enumerate</span><span class="Punctuation">(</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">b</span></pre><p>目前，必须通过 <tt class="docutils literal"><span class="pre">{.experimental: &quot;forLoopMacros&quot;.}</span></tt> 显式启用循环宏。</p>

<h1><a class="toc-backref" id="特殊类型" href="#特殊类型">特殊类型</a></h1>
<h2><a class="toc-backref" id="特殊类型-static-t" href="#特殊类型-static-t">static[T]</a></h2><p>顾名思义，静态参数必须是常量表达式：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">precompiledRegex</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">:</span> <span class="Keyword">static</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">RegEx</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">res</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">global</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">re</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span>
  <span class="Keyword">return</span> <span class="Identifier">res</span>

<span class="Identifier">precompiledRegex</span><span class="Punctuation">(</span><span class="StringLit">&quot;/d+&quot;</span><span class="Punctuation">)</span> <span class="Comment"># 用预编译的正则表达式替换调用，存储在全局变量中</span>

<span class="Identifier">precompiledRegex</span><span class="Punctuation">(</span><span class="Identifier">paramStr</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Comment"># 错误，命令行选项不是常量表达式</span></pre><p>出于代码生成的目的，所有静态参数都被视为通用参数 -  proc将针对每个唯一提供的值（或值的组合）单独编译。</p>
<p>静态参数也可以出现在泛型类型的签名中：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="Identifier">M</span><span class="Punctuation">,</span><span class="Identifier">N</span><span class="Punctuation">:</span> <span class="Keyword">static</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">Number</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Punctuation">(</span><span class="Identifier">M</span><span class="Operator">*</span><span class="Identifier">N</span> <span class="Operator">-</span> <span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span>
    <span class="Comment"># 注意 `Number` 在这里只是一个类型约束，而 `static int` 要求我们提供一个int值</span>
  
  <span class="Identifier">AffineTransform2D</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span>
  <span class="Identifier">AffineTransform3D</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span>

<span class="Keyword">var</span> <span class="Identifier">m1</span><span class="Punctuation">:</span> <span class="Identifier">AffineTransform3D</span><span class="Punctuation">[</span><span class="Identifier">float</span><span class="Punctuation">]</span>  <span class="Comment"># 正确</span>
<span class="Keyword">var</span> <span class="Identifier">m2</span><span class="Punctuation">:</span> <span class="Identifier">AffineTransform2D</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Comment"># 错误 `string`不是`Number`</span></pre><p>请注意，``static T`` 只是底层泛型类型 <tt class="docutils literal"><span class="pre">static[T]</span></tt> 的语法方便。 可以省略类型参数以获取所有常量表达式的类型类。 可以通过使用另一个类型类实例化 <tt class="docutils literal"><span class="pre">static</span></tt> 来创建更具体的类型类。</p>
<p>您可以通过将表达式强制转换为相应的 <tt class="docutils literal"><span class="pre">static</span></tt> 类型来强制将表达式在编译时作为常量表达式进行求值：</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">math</span>

<span class="Identifier">echo</span> <span class="Keyword">static</span><span class="Punctuation">(</span><span class="Identifier">fac</span><span class="Punctuation">(</span><span class="DecNumber">5</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Keyword">static</span><span class="Punctuation">[</span><span class="Identifier">bool</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="FloatNumber">16.</span><span class="Identifier">isPowerOfTwo</span><span class="Punctuation">)</span></pre><p>编译器将报告任何未能评估表达式或可能的类型不匹配错误。</p>

<h2><a class="toc-backref" id="特殊类型-typedesc-t" href="#特殊类型-typedesc-t">typedesc[T]</a></h2><p>在许多情况下，Nim允许您将类型的名称视为常规值。 这些值仅在编译阶段存在，但由于所有值必须具有类型，因此 <tt class="docutils literal"><span class="pre">typedesc</span></tt> 被视为其特殊类型。</p>
<p><tt class="docutils literal"><span class="pre">typedesc</span></tt> 就像一个通用类型。例如，符号 <tt class="docutils literal"><span class="pre">int</span></tt> 的类型是 <tt class="docutils literal"><span class="pre">typedesc [int]</span></tt> 。 就像常规泛型类型一样，当泛型参数被省略时， <tt class="docutils literal"><span class="pre">typedesc</span></tt> 表示所有类型的类型类。 作为一种语法方便，您还可以使用 <tt class="docutils literal"><span class="pre">typedesc</span></tt> 作为修饰符。</p>
<p>具有 <tt class="docutils literal"><span class="pre">typedesc</span></tt> 参数的过程被认为是隐式通用的。 它们将针对提供的类型的每个唯一组合进行实例化，并且在proc的主体内，每个参数的名称将引用绑定的具体类型：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;allocating &quot;</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Operator">.</span><span class="Identifier">name</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Operator">.</span><span class="Identifier">new</span>
<span class="Keyword">var</span> <span class="Identifier">tree</span> <span class="Operator">=</span> <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>当存在多种类型的参数时，它们将自由地绑定到不同类型。 要强制绑定一次行为，可以使用显式通用参数：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">acceptOnlyTypePairs</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">,</span> <span class="Identifier">U</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">C</span><span class="Punctuation">,</span> <span class="Identifier">D</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">U</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>绑定后，类型参数可以出现在proc签名的其余部分中：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">declareVariableWithType</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span> <span class="Operator">=</span> <span class="Identifier">value</span>

<span class="Identifier">declareVariableWithType</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="DecNumber">42</span></pre><p>通过约束与类型参数匹配的类型集，可以进一步影响重载解析。 这在实践中通过模板将属性附加到类型。 约束可以是具体类型或类型类。</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">maxval</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Keyword">template</span> <span class="Identifier">maxval</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">float</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span> <span class="Identifier">Inf</span>

<span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="Identifier">int</span><span class="Operator">.</span><span class="Identifier">maxval</span>
<span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">float</span><span class="Operator">.</span><span class="Identifier">maxval</span>
<span class="Keyword">when</span> <span class="Identifier">false</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="Identifier">string</span><span class="Operator">.</span><span class="Identifier">maxval</span> <span class="Comment"># 错误，没有为字符串实现maxval</span>

<span class="Keyword">template</span> <span class="Identifier">isNumber</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Keyword">object</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;Don't think so.&quot;</span>
<span class="Keyword">template</span> <span class="Identifier">isNumber</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">SomeInteger</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;Yes!&quot;</span>
<span class="Keyword">template</span> <span class="Identifier">isNumber</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">SomeFloat</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;Maybe, could be NaN.&quot;</span>

<span class="Identifier">echo</span> <span class="StringLit">&quot;is int a number? &quot;</span><span class="Punctuation">,</span> <span class="Identifier">isNumber</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;is float a number? &quot;</span><span class="Punctuation">,</span> <span class="Identifier">isNumber</span><span class="Punctuation">(</span><span class="Identifier">float</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;is RootObj a number? &quot;</span><span class="Punctuation">,</span> <span class="Identifier">isNumber</span><span class="Punctuation">(</span><span class="Identifier">RootObj</span><span class="Punctuation">)</span></pre><p>传递 <tt class="docutils literal"><span class="pre">typedesc</span></tt> 几乎完全相同，只是因为宏没有一般地实例化。 类型表达式简单地作为 <tt class="docutils literal"><span class="pre">NimNode</span></tt> 传递给宏，就像其他所有东西一样。</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">forwardType</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span> <span class="Operator">=</span>
  <span class="Comment"># ``arg`` 是 ``NimNode`` 类型</span>
  <span class="Keyword">let</span> <span class="Identifier">tmp</span><span class="Punctuation">:</span> <span class="Identifier">NimNode</span> <span class="Operator">=</span> <span class="Identifier">arg</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">tmp</span>

<span class="Keyword">var</span> <span class="Identifier">tmp</span><span class="Punctuation">:</span> <span class="Identifier">forwardType</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="特殊类型-typeof操作符" href="#特殊类型-typeof操作符">typeof操作符</a></h2><p><strong>注意</strong>: <tt class="docutils literal"><span class="pre">typeof(x)</span></tt> 由于历史原因也可以写成 <tt class="docutils literal"><span class="pre">type(x)</span></tt> ，但不鼓励。</p>
<p>您可以通过从中构造一个 <tt class="docutils literal"><span class="pre">typeof</span></tt> 值来获取给定表达式的类型（在许多其他语言中，这被称为 <span id="typeof_1">typeof</span> 操作符):</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Keyword">var</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typeof</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># y has type int</span></pre><p>如果 <tt class="docutils literal"><span class="pre">typeof</span></tt> 用于确定proc/iterator/converter <tt class="docutils literal"><span class="pre">c(X)</span></tt> 调用的结果类型（其中``X``代表可能为空的参数列表），首选将 <tt class="docutils literal"><span class="pre">c</span></tt> 解释为迭代器，这种可以通过将 <tt class="docutils literal"><span class="pre">typeOfProc</span></tt> 作为第二个参数传递给 <tt class="docutils literal"><span class="pre">typeof</span></tt> 来改变：</p>
<pre class="listing"><span class="Keyword">iterator</span> <span class="Identifier">split</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Identifier">split</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Comment"># 因为迭代器是首选解释，`y` 的类型为 ``string`` ：</span>
<span class="Identifier">assert</span> <span class="Identifier">typeof</span><span class="Punctuation">(</span><span class="StringLit">&quot;a b c&quot;</span><span class="Operator">.</span><span class="Identifier">split</span><span class="Punctuation">)</span> <span class="Keyword">is</span> <span class="Identifier">string</span>

<span class="Identifier">assert</span> <span class="Identifier">typeof</span><span class="Punctuation">(</span><span class="StringLit">&quot;a b c&quot;</span><span class="Operator">.</span><span class="Identifier">split</span><span class="Punctuation">,</span> <span class="Identifier">typeOfProc</span><span class="Punctuation">)</span> <span class="Keyword">is</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span></pre>
<h1><a class="toc-backref" id="模块" href="#模块">模块</a></h1><p>Nim支持通过模块概念将程序拆分为多个部分。 每个模块都需要在自己的文件中，并且有自己的 <span id="命名空间_1">命名空间</span> 。 模块启用 <span id="信息隐藏_1">信息隐藏</span> and <span id="分开编译_1">分开编译</span> 。 模块可以通过 <span id="import_1">import</span> 语句访问另一个模块的符号。 <span id="递归模块依赖_1">递归模块依赖</span> 是允许的，但有点微妙。 仅导出标有星号（``*``）的顶级符号。 有效的模块名称只能是有效的Nim标识符（因此其文件名为 <tt class="docutils literal"><span class="pre">标识符.nim</span></tt> ）。</p>
<p>编译模块的算法是：</p>
<ul class="simple"><li>像往常一样编译整个模块，递归地执行import语句</li>
<li>如果有一个只导入已解析的（即导出的）符号的环;如果出现未知标识符则中止</li>
</ul>
<p>这可以通过一个例子来说明：</p>
<pre class="listing"><span class="Comment"># 模块A</span>
<span class="Keyword">type</span>
  <span class="Identifier">T1</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Identifier">int</span>  <span class="Comment"># 模块A导出类型 ``T1``</span>
<span class="Keyword">import</span> <span class="Identifier">B</span>     <span class="Comment"># 编译器开始解析B</span>

<span class="Keyword">proc</span> <span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span> <span class="Comment"># 因为B在这里被完全解析了</span>

<span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><pre class="listing"><span class="Comment"># 模块 B</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>  <span class="Comment"># 这里没有解析A，仅导入已知的A符号。</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">T1</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">T1</span> <span class="Operator">=</span>
  <span class="Comment"># 这是有效的，因为编译器已经将T1添加到A的接口符号表中</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="DecNumber">1</span></pre>
<h3><a class="toc-backref" id="模块-import语句" href="#模块-import语句">Import语句</a></h3><p>在 <tt class="docutils literal"><span class="pre">import</span></tt> 语句之后，可以跟随模块名称列表或单个模块名称后跟 <tt class="docutils literal"><span class="pre">except</span></tt> 列表以防止导入某些符号：</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">strutils</span> <span class="Keyword">except</span> <span class="Punctuation">`</span><span class="Operator">%</span><span class="Punctuation">`</span><span class="Punctuation">,</span> <span class="Identifier">toUpperAscii</span>

<span class="Comment"># 行不通:</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;$1&quot;</span> <span class="Operator">%</span> <span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">toUpperAscii</span></pre><p>没有检查 <tt class="docutils literal"><span class="pre">except</span></tt> 列表是否真的从模块中导出。 此功能允许针对不导出这些标识符的旧版本模块进行编译。</p>

<h3><a class="toc-backref" id="模块-include语句" href="#模块-include语句">Include语句</a></h3><p><tt class="docutils literal"><span class="pre">include</span></tt> 语句与导入模块有着根本的不同：​​它只包含文件的内容。 <tt class="docutils literal"><span class="pre">include</span></tt> 语句对于将大模块拆分为多个文件很有用：</p>
<pre class="listing"><span class="Keyword">include</span> <span class="Identifier">fileA</span><span class="Punctuation">,</span> <span class="Identifier">fileB</span><span class="Punctuation">,</span> <span class="Identifier">fileC</span></pre>
<h3><a class="toc-backref" id="模块-导入的模块名" href="#模块-导入的模块名">导入的模块名</a></h3><p>可以通过 <tt class="docutils literal"><span class="pre">as</span></tt> 关键字引入模块别名：</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">strutils</span> <span class="Keyword">as</span> <span class="Identifier">su</span><span class="Punctuation">,</span> <span class="Identifier">sequtils</span> <span class="Keyword">as</span> <span class="Identifier">qu</span>

<span class="Identifier">echo</span> <span class="Identifier">su</span><span class="Operator">.</span><span class="Identifier">format</span><span class="Punctuation">(</span><span class="StringLit">&quot;$1&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;lalelu&quot;</span><span class="Punctuation">)</span></pre><p>然后无法访问原始模块名称。 符号 <tt class="docutils literal"><span class="pre">path/to/module</span></tt> 或 <tt class="docutils literal"><span class="pre">&quot;path/to/module&quot;</span></tt> 可用于引用子目录中的模块：</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">lib</span><span class="Operator">/</span><span class="Identifier">pure</span><span class="Operator">/</span><span class="Identifier">os</span><span class="Punctuation">,</span> <span class="StringLit">&quot;lib/pure/times&quot;</span></pre><p>请注意，模块名称仍然是 <tt class="docutils literal"><span class="pre">strutils</span></tt> 而不是 <tt class="docutils literal"><span class="pre">lib/pure/strutils</span></tt> 因此 <strong>无法</strong> 做:</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">lib</span><span class="Operator">/</span><span class="Identifier">pure</span><span class="Operator">/</span><span class="Identifier">strutils</span>
<span class="Identifier">echo</span> <span class="Identifier">lib</span><span class="Operator">/</span><span class="Identifier">pure</span><span class="Operator">/</span><span class="Identifier">strutils</span><span class="Operator">.</span><span class="Identifier">toUpperAscii</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">)</span></pre><p>同样，以下内容没有意义，因为名称已经是 <tt class="docutils literal"><span class="pre">strutils</span></tt> ：</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">lib</span><span class="Operator">/</span><span class="Identifier">pure</span><span class="Operator">/</span><span class="Identifier">strutils</span> <span class="Keyword">as</span> <span class="Identifier">strutils</span></pre>
<h3><a class="toc-backref" id="模块-从目录中集体导入" href="#模块-从目录中集体导入">从目录中集体导入</a></h3><p>语法 <tt class="docutils literal"><span class="pre">import dir / [moduleA, moduleB]</span></tt> 可用于从同一目录导入多个模块。</p>
<p>路径名在语法上是Nim标识符或字符串文字。如果路径名不是有效的Nim标识符，则它必须是字符串文字：</p>
<pre class="listing"><span class="Keyword">import</span> <span class="StringLit">&quot;gfx/3d/somemodule&quot;</span> <span class="Comment"># 在引号中因为'3d'不是有效的Nim标识符</span></pre>
<h3><a class="toc-backref" id="模块-伪importslashinclude目录" href="#模块-伪importslashinclude目录">伪import/include目录</a></h3><p>目录也可以是所谓的“伪目录”。当存在多个具有相同路径的模块时，它们可用于避免歧义。</p>
<p>有两个伪目录：</p>
<p>1. <tt class="docutils literal"><span class="pre">std</span></tt>: <tt class="docutils literal"><span class="pre">std</span></tt> 伪目录是Nim标准库的抽象位置。 例如，语法 <tt class="docutils literal"><span class="pre">import std / strutils</span></tt> 用于明确地引用标准库的 <tt class="docutils literal"><span class="pre">strutils</span></tt> 模块。</p>
<p>2. <tt class="docutils literal"><span class="pre">pkg</span></tt>: <tt class="docutils literal"><span class="pre">pkg</span></tt> 伪目录用于明确引用Nimble包。 但是，对于超出本文档范围的技术细节，其语义为：*使用搜索路径查找模块名称但忽略标准库位置* 。 换句话说，它与 <tt class="docutils literal"><span class="pre">std</span></tt> 相反。</p>

<h3><a class="toc-backref" id="模块-from-import语句" href="#模块-from-import语句">From import语句</a></h3><p>在 <tt class="docutils literal"><span class="pre">from</span></tt> 语句之后，一个模块名称后面跟着一个 <tt class="docutils literal"><span class="pre">import</span></tt> 来列出一个人喜欢使用的符号而没有明确的完全限定：</p>
<pre class="listing"><span class="Keyword">from</span> <span class="Identifier">strutils</span> <span class="Keyword">import</span> <span class="Punctuation">`</span><span class="Operator">%</span><span class="Punctuation">`</span>

<span class="Identifier">echo</span> <span class="StringLit">&quot;$1&quot;</span> <span class="Operator">%</span> <span class="StringLit">&quot;abc&quot;</span>
<span class="Comment"># 可能：完全限定：</span>
<span class="Identifier">echo</span> <span class="Identifier">strutils</span><span class="Operator">.</span><span class="Identifier">replace</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;z&quot;</span><span class="Punctuation">)</span></pre><p>如果想要导入模块但是想要对 <tt class="docutils literal"><span class="pre">module</span></tt> 中的每个符号进行完全限定访问，也可以使用 <tt class="docutils literal"><span class="pre">from module import nil</span></tt> 。</p>

<h3><a class="toc-backref" id="模块-export语句" href="#模块-export语句">Export语句</a></h3><p><tt class="docutils literal"><span class="pre">export</span></tt> 语句可用于符号转发，因此客户端模块不需要导入模块的依赖项：</p>
<pre class="listing"><span class="Comment"># 模块B</span>
<span class="Keyword">type</span> <span class="Identifier">MyObject</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span></pre><pre class="listing"><span class="Comment"># 模块A</span>
<span class="Keyword">import</span> <span class="Identifier">B</span>
<span class="Keyword">export</span> <span class="Identifier">B</span><span class="Operator">.</span><span class="Identifier">MyObject</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">MyObject</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;my object&quot;</span></pre><pre class="listing"><span class="Comment"># 模块C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>

<span class="Comment"># B.MyObject这里已经被隐式导入：</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">MyObject</span>
<span class="Identifier">echo</span> <span class="Operator">$</span><span class="Identifier">x</span></pre><p>当导出的符号是另一个模块时，将转发其所有定义。您可以使用 <tt class="docutils literal"><span class="pre">except</span></tt> 列表来排除某些符号。</p>
<p>请注意，导出时，只需指定模块名称：</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">foo</span><span class="Operator">/</span><span class="Identifier">bar</span><span class="Operator">/</span><span class="Identifier">baz</span>
<span class="Keyword">export</span> <span class="Identifier">baz</span></pre>
<h2><a class="toc-backref" id="模块-作用域规则" href="#模块-作用域规则">作用域规则</a></h2><p>标识符从其声明点开始有效，直到声明发生的块结束。 标识符已知的范围是标识符的范围。 标识符的确切范围取决于它的声明方式。</p>

<h3><a class="toc-backref" id="作用域规则-块作用域" href="#作用域规则-块作用域">块作用域</a></h3><p>在块的声明部分中声明的变量的 <em>作用域</em> 从声明点到块结束有效。 如果块包含第二个块，其中标识符被重新声明，则在该块内，第二个声明将是有效的。 跳出内部区块后，第一个声明再次有效。 除非对过程或迭代器重载有效，否则不能在同一个块中重新定义标识符。</p>

<h3><a class="toc-backref" id="作用域规则-元组或对象作用域" href="#作用域规则-元组或对象作用域">元组或对象作用域</a></h3><p>元组或对象定义中的字段标识符在以下位置有效：</p>
<ul class="simple"><li>到元组/对象定义的结尾。</li>
<li>给定元组/对象类型的变量的字段指示符。</li>
<li>在对象类型的所有后代类型中。</li>
</ul>

<h3><a class="toc-backref" id="作用域规则-模块作用域" href="#作用域规则-模块作用域">模块作用域</a></h3><p>模块的所有标识符从声明点到模块结束都是有效的。 来自间接依赖模块的标识符 <em>不</em> 可用。 The <span id="system_1">system</span> 模块自动导入每个模块。</p>
<p>如果模块通过两个不同的模块导入标识符，则必须限定每次出现的标识符，除非它是重载过程或迭代器，在这种情况下会发生重载解析：</p>
<pre class="listing"><span class="Comment"># 模块A</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*:</span> <span class="Identifier">string</span></pre><pre class="listing"><span class="Comment"># 模块B</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*:</span> <span class="Identifier">int</span></pre><pre class="listing"><span class="Comment"># 模块C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 错误: x有歧义</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 没有错误: 使用限定符</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 没有歧义: 使用模块C的x</span></pre>
<h3><a class="toc-backref" id="作用域规则-代码重排" href="#作用域规则-代码重排">代码重排</a></h3><p><strong>注意</strong> ：代码重新排序是实验性的，必须通过 <tt class="docutils literal"><span class="pre">{.experimental.}</span></tt> 启用。</p>
<p>代码重新排序功能可以在顶级范围内隐式重新排列过程，模板和宏定义以及变量声明和初始化，这样在很大程度上，程序员不必担心正确排序定义或被迫使用转发声明前缀模块内的定义。</p>
<blockquote><p>注意：以下是代码重新排序前体的文档，即 {.noForward.} 。<blockquote><p><p>在此模式下，过程定义可能不按顺序出现，编译器将推迟其语义分析和编译，直到它实际需要使用定义生成代码。 在这方面，此模式类似于动态脚本语言的操作方式，其中函数调用在代码执行之前不会被解析。 以下是编译器采用的详细算法：</p>
<p>1. 次遇到可调用符号时，编译器将只记录符号可调用名称，并将其添加到当前作用域中的相应重载集。 在此步骤中，它不会尝试解析符号签名中使用的任何类型表达式（因此它们可以引用其他尚未定义的符号）。</p>
<p>2. 当遇到顶级调用时（通常在模块的最末端），编译器将尝试确定匹配的重载集中所有符号的实际类型。 这是一个潜在的递归过程，因为符号的签名可能包含其他调用表达式，其类型也将在此时解析。</p>
<p>3. 最后，在选择最佳重载之后，编译器将启动编译各自符号的正文。这反过来将导致编译器发现需要解决的更多调用表达式和步骤必要时将重复图2和3。</p>
<p>请注意，如果在此方案中从未使用过可调用符号，则为身体永远不会编译。这是导致最佳的默认行为编译时间，但如果所有定义都是详尽的汇编必需的，使用 <tt class="docutils literal"><span class="pre">nim check</span></tt> 也提供此选项。</p>
</p></blockquote>
</p></blockquote>
<p>示例：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;codeReordering&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">bar</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">bar</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Identifier">foo</span><span class="Punctuation">(</span><span class="DecNumber">10</span><span class="Punctuation">)</span></pre><p>变量也可以重新排序。 <em>初始化</em> 的变量（即将声明和赋值组合在一个语句中的变量）可以重新排序其整个初始化语句。 小心顶级执行代码：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;codeReordering&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">foo</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">foo</span> <span class="Operator">=</span> <span class="DecNumber">5</span>

<span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># 输出: &quot;5&quot;</span></pre><p>重要的是要注意，重新排序 <em>仅</em> 适用于顶级范围的符号。因此，以下将 <em>编译失败</em> ：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;codeReordering&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">b</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Keyword">proc</span> <span class="Identifier">b</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hello!&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
<h1><a class="toc-backref" id="编译器消息" href="#编译器消息">编译器消息</a></h1><p>Nim编译器发出不同类型的消息： <span id="hint_1">hint</span>, <span id="warning_1">warning</span>, and <span id="error_1">error</span> 消息。 如果编译器遇到任何静态错误，则会发出 <em>error</em> 消息。</p>

<h1><a class="toc-backref" id="编译指示" href="#编译指示">编译指示</a></h1><p>Pragma是Nim的方法，可以在不引入大量新关键字的情况下为编译器提供额外的信息/命令。 在语义检查期间，语境处理是即时处理的。 Pragma包含在特殊的 <tt class="docutils literal"><span class="pre">{.</span></tt> 和 <tt class="docutils literal"><span class="pre">.}</span></tt> 花括号中。 在访问该功能的更好的语法变得可用之前，编译指示通常也被用作第一个使用语言功能的实现。</p>

<h2><a class="toc-backref" id="编译指示-deprecated编译指示" href="#编译指示-deprecated编译指示">deprecated编译指示</a></h2><p>deprecated编译指示用于将符号标记为已弃用：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deprecated</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deprecated</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">char</span></pre><p>该编译指示还可以接受一个可选的警告字符串以转发给开发人员。</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">thing</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deprecated</span><span class="Punctuation">:</span> <span class="StringLit">&quot;use thong instead&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="编译指示-nosideeffect编译指示" href="#编译指示-nosideeffect编译指示">noSideEffect编译指示</a></h2><p><tt class="docutils literal"><span class="pre">noSideEffect</span></tt> 编译指示用于标记proc / iterator没有副作用。 这意味着proc / iterator仅更改可从其参数访问的位置，并且返回值仅取决于参数。 如果它的参数都没有类型``var T``或``ref T``或``ptr T``，这意味着没有修改位置。 如果编译器无法验证，则将proc / iterator标记为无副作用是一个静态错误。</p>
<p>作为一种特殊的语义规则，内置的 <a class="reference external" href="system.html#debugEcho">debugEcho</a> 没有副作用，因此它可以用于调试标记为 <tt class="docutils literal"><span class="pre">noSideEffect</span></tt> 的例程。</p>
<p><tt class="docutils literal"><span class="pre">func</span></tt> 是没有副作用的proc语法糖。</p>
<pre class="listing"><span class="Keyword">func</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre><p>要覆盖编译器的副作用分析，可以使用 <tt class="docutils literal"><span class="pre">{.noSideEffect.}</span></tt> 编译指示块:</p>
<pre class="listing"><span class="Keyword">func</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">noSideEffect</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;test&quot;</span></pre>
<h2><a class="toc-backref" id="编译指示-compiletime编译指示" href="#编译指示-compiletime编译指示">compileTime编译指示</a></h2><p><tt class="docutils literal"><span class="pre">compileTime</span></tt> pragma用于标记仅在编译时执行期间使用的proc或变量。 不会为它生成代码。 编译时触发器可用作宏的帮助器。 从该语言的0.12.0版开始，在其参数类型中使用 <tt class="docutils literal"><span class="pre">system.NimNode</span></tt> 的proc被隐式声明为 <tt class="docutils literal"><span class="pre">compileTime</span></tt> ：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">astHelper</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">NimNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">NimNode</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">n</span></pre><p>同:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">astHelper</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">NimNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">NimNode</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compileTime</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">n</span></pre>
<h2><a class="toc-backref" id="编译指示-noreturn编译指示" href="#编译指示-noreturn编译指示">noReturn编译指示</a></h2><p><tt class="docutils literal"><span class="pre">noreturn</span></tt> 编译指示用于标记不返回的过程。</p>

<h2><a class="toc-backref" id="编译指示-acyclic编译指示" href="#编译指示-acyclic编译指示">acyclic编译指示</a></h2><p><tt class="docutils literal"><span class="pre">acyclic</span></tt> 编译指示用于类型声明。弃用并忽略。</p>

<h2><a class="toc-backref" id="编译指示-final编译指示" href="#编译指示-final编译指示">final编译指示</a></h2><p><tt class="docutils literal"><span class="pre">final</span></tt> 编译指示可以用于对象类型，以指定它不能从中继承。</p>
<p>请注意，继承仅适用于从现有对象继承的对象（通过 <tt class="docutils literal"><span class="pre">超类型对象</span></tt> 语法）或已标记为 <tt class="docutils literal"><span class="pre">可继承</span></tt> 的对象。</p>

<h2><a class="toc-backref" id="编译指示-shallow编译指示" href="#编译指示-shallow编译指示">shallow编译指示</a></h2><p><tt class="docutils literal"><span class="pre">shallow</span></tt> 编译指示会影响类型的语义：允许编译器生成浅拷贝。 这可能会导致严重的语义问题并破坏内存安全。 但是，它可以大大加快赋值，因为Nim的语义需要深拷贝序列和字符串。 这可能很昂贵，特别是如果用序列构建树结构：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">NodeKind</span> <span class="Operator">=</span> <span class="Keyword">enum</span> <span class="Identifier">nkLeaf</span><span class="Punctuation">,</span> <span class="Identifier">nkInner</span>
  <span class="Identifier">Node</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">shallow</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">NodeKind</span>
    <span class="Keyword">of</span> <span class="Identifier">nkLeaf</span><span class="Punctuation">:</span>
      <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Keyword">of</span> <span class="Identifier">nkInner</span><span class="Punctuation">:</span>
      <span class="Identifier">children</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Node</span><span class="Punctuation">]</span></pre>
<h2><a class="toc-backref" id="编译指示-pure编译指示" href="#编译指示-pure编译指示">pure编译指示</a></h2><p>可以使用 <tt class="docutils literal"><span class="pre">pure</span></tt> 编译指示标记对象类型，以便省略用于运行时类型标识的类型字段。 这曾经是与其他编译语言二进制兼容所必需的。</p>
<p>枚举类型可以标记为 <tt class="docutils literal"><span class="pre">纯</span></tt> 。然后访问其字段始终需要完全限定。</p>

<h2><a class="toc-backref" id="编译指示-asmnostackframe编译指示" href="#编译指示-asmnostackframe编译指示">asmNoStackFrame编译指示</a></h2><p>proc可以使用 <tt class="docutils literal"><span class="pre">asmNoStackFrame</span></tt> 编译指示标记，告诉编译器它不应该为过程生成堆栈帧。 也有像 <tt class="docutils literal"><span class="pre">return result;</span></tt> 生成的没有出口的语句，生成的C函数声明为 <tt class="docutils literal"><span class="pre">__declspec(naked)</span></tt> 或 <tt class="docutils literal"><span class="pre">__attribute__((naked))</span></tt> (取决于使用的C编译器)。</p>
<p><strong>注意</strong> ：此pragma只应由仅包含汇编语句的过程使用。</p>

<h2><a class="toc-backref" id="编译指示-error编译指示" href="#编译指示-error编译指示">error编译指示</a></h2><p><tt class="docutils literal"><span class="pre">error</span></tt> 编译指示用于使编译器输出具有给定内容的错误消息。但是，编译错误后不一定会中止。</p>
<p><tt class="docutils literal"><span class="pre">error</span></tt> 编译指示也可用于注释符号（如迭代器或proc）。 然后，符号的 <em>使用</em> 会触发静态错误。 这对于排除由于重载和类型转换而导致某些操作有效特别有用：</p>
<pre class="listing"><span class="Comment">## 检查是否比较了基础int值而不是指针：</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">error</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="编译指示-fatal编译指示" href="#编译指示-fatal编译指示">fatal编译指示</a></h2><p><tt class="docutils literal"><span class="pre">fatal</span></tt> 编译指示用于使编译器输出具有给定内容的错误消息。 与 <tt class="docutils literal"><span class="pre">error</span></tt> 编译指示相反，编译保证会被此编译指示中止。</p>
<p>示例：</p>
<pre class="listing"><span class="Keyword">when</span> <span class="Keyword">not</span> <span class="Identifier">defined</span><span class="Punctuation">(</span><span class="Identifier">objc</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">fatal</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Compile this program with the objc command!&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="编译指示-warning编译指示" href="#编译指示-warning编译指示">warning编译指示</a></h2><p><tt class="docutils literal"><span class="pre">warning</span></tt> 编译指示用于使编译器输出具有给定内容的警告消息，警告后继续编译。</p>

<h2><a class="toc-backref" id="编译指示-hint编译指示" href="#编译指示-hint编译指示">hint编译指示</a></h2><p><tt class="docutils literal"><span class="pre">hint</span></tt> 编译指示用于使编译器输出具有给定内容的提示消息，提示后继续编译。</p>

<h2><a class="toc-backref" id="编译指示-line编译指示" href="#编译指示-line编译指示">line编译指示</a></h2><p><tt class="docutils literal"><span class="pre">line</span></tt> pragma可用于影响带注释语句的行信息，如堆栈回溯中所示：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">myassert</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">,</span> <span class="Identifier">msg</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">cond</span><span class="Punctuation">:</span>
    <span class="Comment"># 更改'raise'语句的运行时行信息：</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">instantiationInfo</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
      <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">EAssertionFailed</span><span class="Punctuation">,</span> <span class="Identifier">msg</span><span class="Punctuation">)</span></pre><p>如果 <tt class="docutils literal"><span class="pre">line</span></tt> 编译指示与参数一起使用，则参数需要是 <tt class="docutils literal"><span class="pre">tuple[filename: string, line: int]</span></tt> 。 如果在没有参数的情况下使用它，则使用 <tt class="docutils literal"><span class="pre">system.InstantiationInfo()</span></tt> 。</p>

<h2><a class="toc-backref" id="编译指示-linearscanend-编译指示" href="#编译指示-linearscanend-编译指示">linearScanEnd 编译指示</a></h2><p><tt class="docutils literal"><span class="pre">linearScanEnd</span></tt> 编译指示可以用来告诉编译器如何编译Nim <span id="case_1">case</span> 语句。 从语法上讲，它必须用作语句：</p>
<pre class="listing"><span class="Keyword">case</span> <span class="Identifier">myInt</span>
<span class="Keyword">of</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;most common case&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">linearScanEnd</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;second most common case&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;unlikely: use branch table&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;unlikely too: use branch table for &quot;</span><span class="Punctuation">,</span> <span class="Identifier">myInt</span></pre><p>在这个例子中，case分支 <tt class="docutils literal"><span class="pre">0</span></tt> 和 <tt class="docutils literal"><span class="pre">1</span></tt> 比其他情况更常见。 因此，生成的汇编程序代码应首先测试这些值，以便CPU的分支预测器有很好的成功机会（避免昂贵的CPU管道停顿）。 其他情况可能会被放入O(1)开销的跳转表中，但代价是（很可能）管道停顿。</p>
<p>应该将 <tt class="docutils literal"><span class="pre">linearScanEnd</span></tt> 编译指示放入应通过线性扫描进行测试的最后一个分支。 如果放入整个 <tt class="docutils literal"><span class="pre">case</span></tt> 语句的最后一个分支，整个 <tt class="docutils literal"><span class="pre">case</span></tt> 语句使用线性扫描。</p>

<h2><a class="toc-backref" id="编译指示-computedgoto编译指示" href="#编译指示-computedgoto编译指示">computedGoto编译指示</a></h2><p><tt class="docutils literal"><span class="pre">calculateGoto</span></tt> 编译指示可用于告诉编译器如何编译在 <tt class="docutils literal"><span class="pre">while true</span></tt> 语句中中的Nim <span id="case_2">case</span> 语句。 从语法上讲，它必须在循环中用作语句：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">enumA</span><span class="Punctuation">,</span> <span class="Identifier">enumB</span><span class="Punctuation">,</span> <span class="Identifier">enumC</span><span class="Punctuation">,</span> <span class="Identifier">enumD</span><span class="Punctuation">,</span> <span class="Identifier">enumE</span>

<span class="Keyword">proc</span> <span class="Identifier">vm</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">instructions</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">100</span><span class="Punctuation">,</span> <span class="Identifier">MyEnum</span><span class="Punctuation">]</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">2</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumC</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumD</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumA</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">5</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumD</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumC</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">7</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumA</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">8</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumB</span>
  
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">12</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumE</span>
  <span class="Keyword">var</span> <span class="Identifier">pc</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">computedGoto</span><span class="Operator">.</span><span class="Punctuation">}</span>
    <span class="Keyword">let</span> <span class="Identifier">instr</span> <span class="Operator">=</span> <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="Identifier">pc</span><span class="Punctuation">]</span>
    <span class="Keyword">case</span> <span class="Identifier">instr</span>
    <span class="Keyword">of</span> <span class="Identifier">enumA</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;yeah A&quot;</span>
    <span class="Keyword">of</span> <span class="Identifier">enumC</span><span class="Punctuation">,</span> <span class="Identifier">enumD</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;yeah CD&quot;</span>
    <span class="Keyword">of</span> <span class="Identifier">enumB</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;yeah B&quot;</span>
    <span class="Keyword">of</span> <span class="Identifier">enumE</span><span class="Punctuation">:</span>
      <span class="Keyword">break</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">pc</span><span class="Punctuation">)</span>

<span class="Identifier">vm</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>如示例所示， <tt class="docutils literal"><span class="pre">computedGoto</span></tt> 对解释器最有用。 如果底层后端（C编译器）不支持计算的goto扩展，则简单地忽略编译指示。</p>

<h2><a class="toc-backref" id="编译指示-unroll编译指示" href="#编译指示-unroll编译指示">unroll编译指示</a></h2><p><tt class="docutils literal"><span class="pre">unroll</span></tt> 编译指示可用于告诉编译器它应该为执行效率展开 <span id="for_2">for</span> 或 <span id="while_1">while</span> 循环:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">searchChar</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">unroll</span><span class="Punctuation">:</span> <span class="FloatNumber">4.</span><span class="Punctuation">}</span>
    <span class="Keyword">if</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">i</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Operator">-</span><span class="DecNumber">1</span></pre><p>在上面的例子中，搜索循环按因子4展开。展开因子也可以省略;然后编译器选择适当的展开因子。</p>
<p><strong>注意</strong> ：目前编译器会识别但忽略此编译指示。</p>

<h2><a class="toc-backref" id="编译指示-immediate编译指示" href="#编译指示-immediate编译指示">immediate编译指示</a></h2><p>immediate编译指示已经弃用。请参阅 <a class="reference external" href="#类型化和无类型形参">类型化和无类型形参</a>.</p>

<h2><a class="toc-backref" id="编译指示-编译选项编译指示" href="#编译指示-编译选项编译指示">编译选项编译指示</a></h2><p>此处列出的编译指示可用于覆盖proc/method/converter的代码生成选项。</p>
<p>该实现目前提供以下可能的选项（稍后可以添加各种其他选项）。</p>
<table border="1" class="docutils"><tr><th>pragma</th><th>allowed values</th><th>description</th></tr>
<tr><td>checks</td><td>on|off</td><td>打开或关闭所有运行时检查的代码生成。</td></tr>
<tr><td>boundChecks</td><td>on|off</td><td>打开或关闭数组绑定检查的代码生成。</td></tr>
<tr><td>overflowChecks</td><td>on|off</td><td>打开或关闭上溢或下溢检查的代码生成。</td></tr>
<tr><td>nilChecks</td><td>on|off</td><td>打开或关闭nil指针检查的代码生成。</td></tr>
<tr><td>assertions</td><td>on|off</td><td>打开或关闭断言的代码生成。</td></tr>
<tr><td>warnings</td><td>on|off</td><td>打开或关闭编译器的警告消息。</td></tr>
<tr><td>hints</td><td>on|off</td><td>打开或关闭编译器的提示消息。</td></tr>
<tr><td>optimization</td><td>none|speed|size</td><td>优化代码的速度或大小，或禁用优化。</td></tr>
<tr><td>patterns</td><td>on|off</td><td>打开或关闭术语重写模板/宏。</td></tr>
<tr><td>callconv</td><td>cdecl|...</td><td>指定后面的所有过程（和过程类型）的默认调用约定。</td></tr>
</table><p>示例：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">checks</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Punctuation">,</span> <span class="Identifier">optimization</span><span class="Punctuation">:</span> <span class="Identifier">speed</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Comment"># 编译时没有运行时检查并优化速度</span></pre>
<h2><a class="toc-backref" id="编译指示-push和pop编译指示" href="#编译指示-push和pop编译指示">push和pop编译指示</a></h2><p><span id="pushslashpop_1">push/pop</span> 编译指示与option指令非常相似，但用于暂时覆盖设置。 示例：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">checks</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Comment"># 编译本节而不进行运行时检查，因为它对速度至关重要</span>
<span class="Comment"># ... some code ...</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Comment"># 恢复堆栈</span></pre>
<h2><a class="toc-backref" id="编译指示-register编译指示" href="#编译指示-register编译指示">register编译指示</a></h2><p><tt class="docutils literal"><span class="pre">register</span></tt> 编译指示仅用于变量。 它将变量声明为 <tt class="docutils literal"><span class="pre">register</span></tt> ，给编译器一个提示，即应该将变量放在硬件寄存器中以便更快地访问。 C编译器通常会忽略这一点，但有充分的理由：无论如何，他们通常会做得更好。</p>
<p>在高度特定的情况下（例如，字节码解释器的调度循环），它可能提供好处。</p>

<h2><a class="toc-backref" id="编译指示-global编译指示" href="#编译指示-global编译指示">global编译指示</a></h2><p><tt class="docutils literal"><span class="pre">global</span></tt> 编译指示可以应用于proc中的变量，以指示编译器将其存储在全局位置并在程序启动时初始化它。</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">isHexNumber</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">pattern</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">global</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="RawData">re&quot;[0-9a-fA-F]+&quot;</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">match</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span></pre><p>在泛型proc中使用时，将为proc的每个实例创建一个单独的唯一全局变量。 未定义模块中创建的全局变量的初始化顺序，但所有这些变量的顺序将在其原始模块中的任何顶级变量之后以及导入模块中的任何变量之前初始化。</p>

<h2><a class="toc-backref" id="编译指示-pragma编译指示" href="#编译指示-pragma编译指示">pragma编译指示</a></h2><p><tt class="docutils literal"><span class="pre">pragma</span></tt> 编译指示可用于声明用户定义的编译指示。 这很有用，因为Nim的模板和宏不会影响编译指示。 用户定义的编译指示与所有其他符号在不同的模块范围内。 它们无法从模块导入。</p>
<p>示例：</p>
<pre class="listing"><span class="Keyword">when</span> <span class="Identifier">appType</span> <span class="Operator">==</span> <span class="StringLit">&quot;lib&quot;</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Punctuation">:</span> <span class="Identifier">rtl</span><span class="Punctuation">,</span> <span class="Identifier">exportc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">,</span> <span class="Identifier">cdecl</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Punctuation">:</span> <span class="Identifier">rtl</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="StringLit">&quot;client.dll&quot;</span><span class="Punctuation">,</span> <span class="Identifier">cdecl</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">rtl</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Operator">+</span><span class="Identifier">b</span></pre><p>在该示例中，引入了名为 <tt class="docutils literal"><span class="pre">rtl</span></tt> 的新编译指示，该编译指示从动态库导入符号或导出用于动态库生成的符号。</p>

<h2><a class="toc-backref" id="编译指示-禁用某些消息" href="#编译指示-禁用某些消息">禁用某些消息</a></h2><p>Nim会产生一些可能会惹恼用户的警告和提示（“行太长”）。 提供了一种禁用某些消息的机制：每个提示和警告消息都在括号中包含一个符号。 这是可用于启用或禁用它的消息标识符：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">hint</span><span class="Punctuation">[</span><span class="Identifier">LineTooLong</span><span class="Punctuation">]</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Comment"># 关掉行太长的提示</span></pre><p>这通常比一次禁用所有警告更好。</p>

<h2><a class="toc-backref" id="编译指示-used编译指示" href="#编译指示-used编译指示">used编译指示</a></h2><p>Nim会对未导出但未使用的符号生成警告。 <tt class="docutils literal"><span class="pre">used</span></tt> 编译指示可以附加到符号以抑制此警告。 当符号由宏生成时，这尤其有用：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">implementArithOps</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Identifier">echoAdd</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">used</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
    <span class="Identifier">echo</span> <span class="Identifier">a</span> <span class="Operator">+</span> <span class="Identifier">b</span>
  <span class="Keyword">proc</span> <span class="Identifier">echoSub</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">used</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
    <span class="Identifier">echo</span> <span class="Identifier">a</span> <span class="Operator">-</span> <span class="Identifier">b</span>

<span class="Comment"># 没有为未使用的'echoSub'发出警告</span>
<span class="Identifier">implementArithOps</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Identifier">echoAdd</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">5</span></pre>
<h2><a class="toc-backref" id="编译指示-experimental编译指示" href="#编译指示-experimental编译指示">experimental编译指示</a></h2><p><tt class="docutils literal"><span class="pre">experimental</span></tt> 编译指示实现了实验语言功能。 根据具体特征，这意味着该特征被认为对于其他稳定版本而言太不稳定，或者该特征的未来不确定（可能随时删除）。 示例：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;parallel&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">useParallel</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">parallel</span><span class="Punctuation">:</span>
    <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">4</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;echo in parallel&quot;</span></pre><p>作为顶级语句，实验编译指示为其启用的模块的其余部分启用了一项功能。 这对于跨越模块范围的宏和通用实例化是有问题的。 目前这些用法必须放在 <tt class="docutils literal"><span class="pre">.push/pop</span></tt> 环境中：</p>
<pre class="listing"><span class="Comment"># client.nim</span>
<span class="Keyword">proc</span> <span class="Identifier">useParallel</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">unused</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># use a generic T here to show the problem.</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;parallel&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Identifier">parallel</span><span class="Punctuation">:</span>
    <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">4</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;echo in parallel&quot;</span>
  
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><pre class="listing"><span class="Keyword">import</span> <span class="Identifier">client</span>
<span class="Identifier">useParallel</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span></pre>
<h1><a class="toc-backref" id="特定实现的编译指示" href="#特定实现的编译指示">特定实现的编译指示</a></h1><p>本节描述了当前Nim实现支持的其他编译指示，但不应将其视为语言规范的一部分。</p>

<h2><a class="toc-backref" id="特定实现的编译指示-bitsize-编译指示" href="#特定实现的编译指示-bitsize-编译指示">Bitsize 编译指示</a></h2><p><tt class="docutils literal"><span class="pre">bitsize</span></tt> 编译指示用于对象字段成员。它将该字段声明为C/C++中的位字段。</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">mybitfield</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">flag</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">bitsize</span><span class="Punctuation">:</span><span class="FloatNumber">1.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">cuint</span></pre><p>生成:</p>
<pre class="listing"><span class="Keyword">struct</span> <span class="Identifier">mybitfield</span> <span class="Punctuation">{</span>
  <span class="Keyword">unsigned</span> <span class="Keyword">int</span> <span class="Identifier">flag</span><span class="Punctuation">:</span><span class="DecNumber">1</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span><span class="Punctuation">;</span></pre>
<h2><a class="toc-backref" id="特定实现的编译指示-volatile编译指示" href="#特定实现的编译指示-volatile编译指示">Volatile编译指示</a></h2><p><tt class="docutils literal"><span class="pre">volatile</span></tt> 编译指示仅用于变量。 它将变量声明为 <tt class="docutils literal"><span class="pre">volatile</span></tt> ，无论C/C++中的含义是什么（它的语义在C/C++中没有很好地定义）。</p>
<p><strong>注意</strong> ：LLVM后端不存在此编译指示。</p>

<h2><a class="toc-backref" id="特定实现的编译指示-nodecl编译指示" href="#特定实现的编译指示-nodecl编译指示">NoDecl编译指示</a></h2><p><tt class="docutils literal"><span class="pre">noDecl</span></tt> 编译指示几乎可以应用于任何符号（变量，proc，类型等），有时与C的互操作性有用： 它告诉Nim它不应该在C代码中为符号生成声明。</p>
<p>例如：</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">EACCES</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">noDecl</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">cint</span> <span class="Comment"># EACCES是一个变量，因为Nim不知道它的价值</span></pre><p>但是，``header`` 编译指示通常是更好的选择。</p>
<p><strong>注意</strong> ：这不适用于LLVM后端。</p>

<h2><a class="toc-backref" id="特定实现的编译指示-header编译指示" href="#特定实现的编译指示-header编译指示">Header编译指示</a></h2><p><tt class="docutils literal"><span class="pre">header</span></tt> 编译指示与 <tt class="docutils literal"><span class="pre">noDecl</span></tt> 编译指示非常相似：它几乎可以应用于任何符号并指定不应该声明它，而生成的代码应该包含一个 <tt class="docutils literal"><span class="pre">#include</span></tt> ：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">PFile</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;FILE*&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;stdio.h&gt;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">pointer</span>
    <span class="Comment"># 导入C的FILE *类型; Nim会将其视为新的指针类型</span></pre><p><tt class="docutils literal"><span class="pre">header</span></tt> 编译指示始终期望字符串不变。 字符串包含头文件：与C一样，系统头文件包含在尖括号中： <tt class="docutils literal"><span class="pre">&lt;&gt;</span></tt>  。</p>
<p>如果没有给出尖括号，Nim将生成的C代码中的头文件包含在 <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt> 中。</p>
<p><strong>注意</strong> ：这不适用于LLVM后端。</p>

<h2><a class="toc-backref" id="特定实现的编译指示-incompletestruct编译指示" href="#特定实现的编译指示-incompletestruct编译指示">IncompleteStruct编译指示</a></h2><p><tt class="docutils literal"><span class="pre">incompleteStruct</span></tt> 编译指示告诉编译器不要在 <tt class="docutils literal"><span class="pre">sizeof</span></tt> 表达式中使用底层的C <tt class="docutils literal"><span class="pre">struct</span></tt> ：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">DIR</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;DIR&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;dirent.h&gt;&quot;</span><span class="Punctuation">,</span>
         <span class="Identifier">pure</span><span class="Punctuation">,</span> <span class="Identifier">incompleteStruct</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span></pre>
<h2><a class="toc-backref" id="特定实现的编译指示-compile编译指示" href="#特定实现的编译指示-compile编译指示">Compile编译指示</a></h2><p><tt class="docutils literal"><span class="pre">compile</span></tt> 编译指示可用于编译和链接项目的C/C++源文件：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compile</span><span class="Punctuation">:</span> <span class="StringLit">&quot;myfile.cpp&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p><strong>注意</strong> ：Nim计算SHA1校验和，只有在文件发生变化时才重新编译。 您可以使用 <tt class="docutils literal"><span class="pre">-f</span></tt> 命令行选项强制重新编译该文件。</p>

<h2><a class="toc-backref" id="特定实现的编译指示-link编译指示" href="#特定实现的编译指示-link编译指示">Link编译指示</a></h2><p><tt class="docutils literal"><span class="pre">link</span></tt> 编译指示可用于将附加文件与项目链接：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">link</span><span class="Punctuation">:</span> <span class="StringLit">&quot;myfile.o&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="特定实现的编译指示-passc编译指示" href="#特定实现的编译指示-passc编译指示">PassC编译指示</a></h2><p>可以使用 <tt class="docutils literal"><span class="pre">passC</span></tt> 编译指示将其他参数传递给C编译器，就像使用命令行开关 <tt class="docutils literal"><span class="pre">--passC</span></tt> 一样：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">passC</span><span class="Punctuation">:</span> <span class="StringLit">&quot;-Wall -Werror&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>请注意，您可以使用 <a class="reference external" href="system.html">system module</a> 中的 <tt class="docutils literal"><span class="pre">gorge</span></tt> 来嵌入将在语义分析期间执行的外部命令的参数：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">passC</span><span class="Punctuation">:</span> <span class="Identifier">gorge</span><span class="Punctuation">(</span><span class="StringLit">&quot;pkg-config --cflags sdl&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="特定实现的编译指示-passl编译指示" href="#特定实现的编译指示-passl编译指示">PassL编译指示</a></h2><p><tt class="docutils literal"><span class="pre">passL</span></tt> 编译指示可用于将其他参数传递给链接器，就像使用命令行开关 <tt class="docutils literal"><span class="pre">--passL</span></tt> 一样：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">passL</span><span class="Punctuation">:</span> <span class="StringLit">&quot;-lSDLmain -lSDL&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>请注意，您可以使用 <a class="reference external" href="system.html">system module</a> 中的 <tt class="docutils literal"><span class="pre">gorge</span></tt> 来嵌入将在语义分析期间执行的外部命令的参数：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">passL</span><span class="Punctuation">:</span> <span class="Identifier">gorge</span><span class="Punctuation">(</span><span class="StringLit">&quot;pkg-config --libs sdl&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="特定实现的编译指示-emit编译指示" href="#特定实现的编译指示-emit编译指示">Emit编译指示</a></h2><p><tt class="docutils literal"><span class="pre">emit</span></tt> 编译指示可用于直接影响编译器代码生成器的输出。 因此，它使您的代码无法移植到其他代码生成器/后端。 它的使用非常不鼓励的。但是，它对于与 <span id="cplusplus_1">C++</span> 或 <span id="objective-c_1">Objective C</span> 代码非常有用。</p>
<p>示例：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="LongStringLit">&quot;&quot;&quot;
static int cvariable = 420;
&quot;&quot;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">stackTrace</span><span class="Punctuation">:</span><span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">embedsC</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">nimVar</span> <span class="Operator">=</span> <span class="DecNumber">89</span>
  <span class="Comment"># 访问字符串文字之外的发送部分中的Nim符号：</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="LongStringLit">&quot;&quot;&quot;fprintf(stdout, &quot;%d\n&quot;, cvariable + (int)&quot;&quot;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nimVar</span><span class="Punctuation">,</span> <span class="StringLit">&quot;);&quot;</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Identifier">embedsC</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p><tt class="docutils literal"><span class="pre">nimbase.h</span></tt> 定义了 <tt class="docutils literal"><span class="pre">NIM_EXTERNC</span></tt> C宏，它可以用于 <tt class="docutils literal"><span class="pre">extern &quot;C&quot;``代码，用于 ``nim c</span></tt> 和 <tt class="docutils literal"><span class="pre">nim cpp</span></tt> ，例如：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">foobar</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span><span class="StringLit">&quot;$1&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="LongStringLit">&quot;&quot;&quot;
#include &lt;stdio.h&gt;
NIM_EXTERNC
void fun(){}
&quot;&quot;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>为了向后兼容，如果``emit``语句的参数是单个字符串文字，则可以通过反引号引用Nim符号。 但是不推荐使用此用法。</p>
<p>对于顶级emit语句， 生成的C/C++文件中应该发出代码的部分可以通过前缀 <tt class="docutils literal"><span class="pre">/*TYPESECTION*/</span></tt> 或 <tt class="docutils literal"><span class="pre">/*VARSECTION*/</span></tt> 或 <tt class="docutils literal"><span class="pre">/*INCLUDESECTION*/</span></tt> 来影响:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="LongStringLit">&quot;&quot;&quot;/*TYPESECTION*/
struct Vector3 {
public:
  Vector3(): x(5) {}
  Vector3(float x_): x(x_) {}
  float x;
};
&quot;&quot;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">type</span> <span class="Identifier">Vector3</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Vector3&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">cfloat</span>

<span class="Keyword">proc</span> <span class="Identifier">constructVector3</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">cfloat</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Vector3</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Vector3(@)&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="特定实现的编译指示-importcpp编译指示" href="#特定实现的编译指示-importcpp编译指示">ImportCpp编译指示</a></h2><p><strong>注意</strong>: <a class="reference external" href="https://github.com/nim-lang/c2nim/blob/master/doc/c2nim.rst">c2nim</a> 可以解析C++子集并且知道 <tt class="docutils literal"><span class="pre">importcpp</span></tt> 编译指示模式语言。 没有必要知道这里描述的所有细节。</p>
<p>和 <a class="reference external" href="#foreign-function-interface-importc-pragma">importc pragma for C</a> 类似, <tt class="docutils literal"><span class="pre">importcpp</span></tt> 编译指示一般可以用于引入 <span id="cplusplus_2">C++</span> 方法或C++符号。 生成的代码会使用C++方法调用的语法: <tt class="docutils literal"><span class="pre">obj-&gt;method(arg)</span></tt> 。</p>
<p>结合 <tt class="docutils literal"><span class="pre">header</span></tt> 和 <tt class="docutils literal"><span class="pre">emit</span></tt> 编译指示，这允许与C++库的接口：</p>
<pre class="listing"><span class="Comment"># 和C++引擎对接的反例... ;-)</span>

<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">link</span><span class="Punctuation">:</span> <span class="StringLit">&quot;/usr/lib/libIrrlicht.so&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="LongStringLit">&quot;&quot;&quot;
using namespace irr;
using namespace core;
using namespace scene;
using namespace video;
using namespace io;
using namespace gui;
&quot;&quot;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">const</span>
  <span class="Identifier">irr</span> <span class="Operator">=</span> <span class="StringLit">&quot;&lt;irrlicht/irrlicht.h&gt;&quot;</span>

<span class="Keyword">type</span>
  <span class="Identifier">IrrlichtDeviceObj</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">header</span><span class="Punctuation">:</span> <span class="Identifier">irr</span><span class="Punctuation">,</span>
                      <span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;IrrlichtDevice&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">IrrlichtDevice</span> <span class="Operator">=</span> <span class="Keyword">ptr</span> <span class="Identifier">IrrlichtDeviceObj</span>

<span class="Keyword">proc</span> <span class="Identifier">createDevice</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">IrrlichtDevice</span> <span class="Punctuation">{</span><span class="Operator">.</span>
  <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="Identifier">irr</span><span class="Punctuation">,</span> <span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;createDevice(@)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">run</span><span class="Punctuation">(</span><span class="Identifier">device</span><span class="Punctuation">:</span> <span class="Identifier">IrrlichtDevice</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span>
  <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="Identifier">irr</span><span class="Punctuation">,</span> <span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;#.run(@)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>需要告诉编译器生成C++（命令 <tt class="docutils literal"><span class="pre">cpp</span></tt> ）才能使其工作。 当编译器发射C++代码时，会定义条件符号 <tt class="docutils literal"><span class="pre">cpp</span></tt> 。</p>

<h3><a class="toc-backref" id="importcpp编译指示-命名空间" href="#importcpp编译指示-命名空间">命名空间</a></h3><p><em>接口</em> 示例使用 <tt class="docutils literal"><span class="pre">.emit</span></tt> 来生成 <tt class="docutils literal"><span class="pre">using namespace</span></tt> 声明。 通过 <tt class="docutils literal"><span class="pre">命名空间::标识符</span></tt> 符号来引用导入的名称通常要好得多：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">IrrlichtDeviceObj</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">header</span><span class="Punctuation">:</span> <span class="Identifier">irr</span><span class="Punctuation">,</span>
                      <span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;irr::IrrlichtDevice&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span></pre>
<h3><a class="toc-backref" id="importcpp编译指示-枚举importcpp" href="#importcpp编译指示-枚举importcpp">枚举Importcpp</a></h3><p>当 <tt class="docutils literal"><span class="pre">importcpp</span></tt> 应用于枚举类型时，数字枚举值用C++枚举类型注释, 像这个示例： <tt class="docutils literal"><span class="pre">((TheCppEnum)(3))</span></tt> 。 （事实证明这是实现它的最简单方法。）</p>

<h3><a class="toc-backref" id="importcpp编译指示-过程importcpp" href="#importcpp编译指示-过程importcpp">过程Importcpp</a></h3><p>请注意，procs的 <tt class="docutils literal"><span class="pre">importcpp</span></tt> 变体使用了一种有点神秘的模式语言，以获得最大的灵活性：</p>
<ul class="simple"><li>哈希 <tt class="docutils literal"><span class="pre">#</span></tt> 符号被第一个或下一个参数替换。</li>
</ul>
<p>哈希 <tt class="docutils literal"><span class="pre">#.</span></tt> 后面的一个点表示该调用应使用C++的点或箭头表示法。</p>
<ul class="simple"><li>符号 <tt class="docutils literal"><span class="pre">@</span></tt> 被剩下的参数替换，用逗号分隔。</li>
</ul>
<p>示例：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">cppMethod</span><span class="Punctuation">(</span><span class="Identifier">this</span><span class="Punctuation">:</span> <span class="Identifier">CppObj</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">cint</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;#.CppMethod(@)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">CppObj</span>
<span class="Identifier">cppMethod</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span></pre><p>生成:</p>
<pre class="listing"><span class="Identifier">x</span><span class="Operator">-&gt;</span><span class="Identifier">CppMethod</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span></pre><p>作为一个特殊的规则来保持与旧版本的 <tt class="docutils literal"><span class="pre">importcpp</span></tt> 编译指示的向后兼容性，如果没有特殊的模式字符（任何一个 <tt class="docutils literal"><span class="pre">#'@</span></tt> ），那么认为是C++的点或箭头符号，所以上面的例子也可以写成：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">cppMethod</span><span class="Punctuation">(</span><span class="Identifier">this</span><span class="Punctuation">:</span> <span class="Identifier">CppObj</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">cint</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;CppMethod&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>请注意，模式语言自然也涵盖了C++的运算符重载功能：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">vectorAddition</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Vec3</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Vec3</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;# + #&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">dictLookup</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Dict</span><span class="Punctuation">,</span> <span class="Identifier">k</span><span class="Punctuation">:</span> <span class="Identifier">Key</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Value</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;#[#]&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><ul class="simple"><li>上标点 <tt class="docutils literal"><span class="pre">'</span></tt> 后跟0..9范围的整数 <tt class="docutils literal"><span class="pre">i</span></tt> 被第i个形参类型替换。 第0位是结果类型。这可以用于将类型传递给C++函数模板。 在 <tt class="docutils literal"><span class="pre">'</span></tt> 和数字之间可以使用星号来获得该类型的基类型。 （所以它从类型中“拿走了一颗星”; <tt class="docutils literal"><span class="pre">T *</span></tt> 变为 <tt class="docutils literal"><span class="pre">T</span></tt> 。） 可以使用两颗星来获取元素类型的元素类型等。</li>
</ul>
<p>示例：</p>
<pre class="listing"><span class="Keyword">type</span> <span class="Identifier">Input</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;System::Input&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
<span class="Keyword">proc</span> <span class="Identifier">getSubsystem</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">T</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;SystemManager::getSubsystem&lt;'*0&gt;()&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">let</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Input</span> <span class="Operator">=</span> <span class="Identifier">getSubsystem</span><span class="Punctuation">[</span><span class="Identifier">Input</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>生成:</p>
<pre class="listing"><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">SystemManager</span><span class="Punctuation">:</span><span class="Punctuation">:</span><span class="Identifier">getSubsystem</span><span class="Operator">&lt;</span><span class="Identifier">System</span><span class="Punctuation">:</span><span class="Punctuation">:</span><span class="Identifier">Input</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><ul class="simple"><li><tt class="docutils literal"><span class="pre">#@</span></tt> 是一个支持 <tt class="docutils literal"><span class="pre">cnew</span></tt> 操作的特例。 这是必需的，以便直接内联调用表达式，而无需通过临时位置。 这只是为了规避当前代码生成器的限制。</li>
</ul>
<p>例如，C++的 <tt class="docutils literal"><span class="pre">new</span></tt> 运算符可以像这样“导入”：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">cnew</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">T</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;(new '*0#@)&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Comment"># 'Foo'构造函数:</span>
<span class="Keyword">proc</span> <span class="Identifier">constructFoo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">cint</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Foo</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Foo(@)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">cnew</span> <span class="Identifier">constructFoo</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span></pre><p>生成:</p>
<pre class="listing"><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">new</span> <span class="Identifier">Foo</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span></pre><p>但是，根据用例， <tt class="docutils literal"><span class="pre">new Foo</span></tt> 也可以这样包装：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">newFoo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">cint</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Foo</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;new Foo(@)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">newFoo</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span></pre>
<h3><a class="toc-backref" id="importcpp编译指示-封装构造函数" href="#importcpp编译指示-封装构造函数">封装构造函数</a></h3><p>有时候C++类有一个私有的复制构造函数，因此不能生成像 <tt class="docutils literal"><span class="pre">Class c = Class(1,2);</span></tt> 这样的代码，而是 <tt class="docutils literal"><span class="pre">Class c(1,2);</span></tt> 。 为此，包含C ++构造函数的Nim proc需要使用 <span id="构造函数_1">构造函数</span> 编译器。 这个编译指示也有助于生成更快的C++代码，因为构造然后不会调用复制构造函数：</p>
<pre class="listing"><span class="Comment"># 更好的'Foo'构建函数：</span>
<span class="Keyword">proc</span> <span class="Identifier">constructFoo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">cint</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Foo</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Foo(@)&quot;</span><span class="Punctuation">,</span> <span class="Identifier">constructor</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h3><a class="toc-backref" id="importcpp编译指示-封装析构函数" href="#importcpp编译指示-封装析构函数">封装析构函数</a></h3><p>封装destruct由于Nim直接生成C++，所以任何析构函数都由C++编译器在作用域出口处隐式调用。 这意味着通常人们可以完全没有封装析构函数。 但是当需要显式调用它时，需要将其封装起来。 模式语言提供了所需的一切：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">destroyFoo</span><span class="Punctuation">(</span><span class="Identifier">this</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Foo</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;#.~Foo()&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h3><a class="toc-backref" id="importcpp编译指示-对象的importcpp" href="#importcpp编译指示-对象的importcpp">对象的Importcpp</a></h3><p>泛型 <tt class="docutils literal"><span class="pre">importcpp</span></tt> 的对象映射成C++模板。这意味着您可以轻松导入C++的模板，而无需对象类型的模式语言：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">StdMap</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;std::map&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;map&gt;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Punctuation">[</span><span class="Identifier">K</span><span class="Punctuation">,</span> <span class="Identifier">V</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Identifier">K</span><span class="Punctuation">,</span> <span class="Identifier">V</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">this</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">StdMap</span><span class="Punctuation">[</span><span class="Identifier">K</span><span class="Punctuation">,</span> <span class="Identifier">V</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">key</span><span class="Punctuation">:</span> <span class="Identifier">K</span><span class="Punctuation">;</span> <span class="Identifier">val</span><span class="Punctuation">:</span> <span class="Identifier">V</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span>
  <span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;#[#] = #&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;map&gt;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">StdMap</span><span class="Punctuation">[</span><span class="Identifier">cint</span><span class="Punctuation">,</span> <span class="Identifier">cdouble</span><span class="Punctuation">]</span>
<span class="Identifier">x</span><span class="Punctuation">[</span><span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="FloatNumber">91.4</span></pre><p>生成:</p>
<pre class="listing"><span class="Identifier">std</span><span class="Punctuation">:</span><span class="Punctuation">:</span><span class="Identifier">map</span><span class="Operator">&lt;</span><span class="Keyword">int</span><span class="Punctuation">,</span> <span class="Keyword">double</span><span class="Operator">&gt;</span> <span class="Identifier">x</span><span class="Punctuation">;</span>
<span class="Identifier">x</span><span class="Punctuation">[</span><span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="FloatNumber">91.4</span><span class="Punctuation">;</span></pre><ul class="simple"><li>如果需要更精确的控制, 上标点 <tt class="docutils literal"><span class="pre">'</span></tt> 可以用在提供的模式里标志泛型类型的具体类型参数。 更多细节，见过程模式中的上标点操作符。</li>
</ul>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">VectorIterator</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;std::vector&lt;'0&gt;::iterator&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>

<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">VectorIterator</span><span class="Punctuation">[</span><span class="Identifier">cint</span><span class="Punctuation">]</span></pre><p>Produces:</p>
<pre class="listing"><span class="Identifier">std</span><span class="Punctuation">:</span><span class="Punctuation">:</span><span class="Identifier">vector</span><span class="Operator">&lt;</span><span class="Keyword">int</span><span class="Operator">&gt;::</span><span class="Identifier">iterator</span> <span class="Identifier">x</span><span class="Punctuation">;</span></pre>
<h2><a class="toc-backref" id="特定实现的编译指示-importobjc编译指示" href="#特定实现的编译指示-importobjc编译指示">ImportObjC编译指示</a></h2><p>和 <a class="reference external" href="#foreign-function-interface-importc-pragma">importc pragma for C</a> 类似, <tt class="docutils literal"><span class="pre">importobjc</span></tt> 编译指示可用于导入 <span id="objective-c_2">Objective C</span> 方法。 生成的代码使用Objective C 方法调用语法: <tt class="docutils literal"><span class="pre">[obj method param1: arg]</span></tt>. 除了 <tt class="docutils literal"><span class="pre">header</span></tt> 和 <tt class="docutils literal"><span class="pre">emit</span></tt> 编译指示之外，这允许与Objective C中编写的库的对接：</p>
<pre class="listing"><span class="Comment"># 和GNUStep对接的反例 ...</span>

<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">passL</span><span class="Punctuation">:</span> <span class="StringLit">&quot;-lobjc&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="LongStringLit">&quot;&quot;&quot;
#include &lt;objc/Object.h&gt;
@interface Greeter:Object
{
}

- (void)greet:(long)x y:(long)dummy;
@end

#include &lt;stdio.h&gt;
@implementation Greeter

- (void)greet:(long)x y:(long)dummy
{
  printf(&quot;Hello, World!\n&quot;);
}
@end

#include &lt;stdlib.h&gt;
&quot;&quot;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">type</span>
  <span class="Identifier">Id</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;id&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;objc/Object.h&gt;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">final</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Identifier">newGreeter</span><span class="Punctuation">:</span> <span class="Identifier">Id</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importobjc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Greeter new&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">greet</span><span class="Punctuation">(</span><span class="Identifier">self</span><span class="Punctuation">:</span> <span class="Identifier">Id</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importobjc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;greet&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">free</span><span class="Punctuation">(</span><span class="Identifier">self</span><span class="Punctuation">:</span> <span class="Identifier">Id</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importobjc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;free&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">var</span> <span class="Identifier">g</span> <span class="Operator">=</span> <span class="Identifier">newGreeter</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Identifier">g</span><span class="Operator">.</span><span class="Identifier">greet</span><span class="Punctuation">(</span><span class="DecNumber">12</span><span class="Punctuation">,</span> <span class="DecNumber">34</span><span class="Punctuation">)</span>
<span class="Identifier">g</span><span class="Operator">.</span><span class="Identifier">free</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>需要告诉编译器生成Objective C(命令 <tt class="docutils literal"><span class="pre">objc</span></tt> )以使其工作。当编译器发出Objective C代码时，定义条件符号 <tt class="docutils literal"><span class="pre">objc</span></tt> 。</p>

<h2><a class="toc-backref" id="特定实现的编译指示-codegendecl编译指示" href="#特定实现的编译指示-codegendecl编译指示">CodegenDecl编译指示</a></h2><p><tt class="docutils literal"><span class="pre">codegenDecl</span></tt> 编译指示可用于直接影响Nim的代码生成器。</p>
<p>它接收一个格式字符串，用于确定如何在生成的代码中声明变量或proc。</p>
<p>对于变量，格式字符串中的$1表示变量的类型，$2是变量的名称。</p>
<p>以下Nim哇到处:</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">a</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">codegenDecl</span><span class="Punctuation">:</span> <span class="StringLit">&quot;$# progmem $#&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre><p>会生成这个C代码:</p>
<pre class="listing"><span class="Keyword">int</span> <span class="Identifier">progmem</span> <span class="Identifier">a</span></pre><p>对于过程，$1是过程的返回类型，$2是过程的名称，$3是参数列表。</p>
<p>下列nim代码:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">myinterrupt</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">codegenDecl</span><span class="Punctuation">:</span> <span class="StringLit">&quot;__interrupt $# $#$#&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;realistic interrupt handler&quot;</span></pre><p>会生成这个代码:</p>
<pre class="listing"><span class="Identifier">__interrupt</span> <span class="Keyword">void</span> <span class="Identifier">myinterrupt</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="特定实现的编译指示-injectstmt编译指示" href="#特定实现的编译指示-injectstmt编译指示">InjectStmt编译指示</a></h2><p><tt class="docutils literal"><span class="pre">injectStmt</span></tt> 编译指示可用于在当前模块中的每个其他语句之前注入语句。 它只应该用于调试：</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">injectStmt</span><span class="Punctuation">:</span> <span class="Identifier">gcInvariants</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Comment"># ... 这里的复杂代码会导致崩溃 ...</span></pre>
<h2><a class="toc-backref" id="特定实现的编译指示-编译期定义的编译指示" href="#特定实现的编译指示-编译期定义的编译指示">编译期定义的编译指示</a></h2><p>此处列出的编译指示可用于在编译时选择接受-d /--define选项中的值。</p>
<p>该实现目前提供以下可能的选项（稍后可以添加各种其他选项）。</p>
<table border="1" class="docutils"><tr><th>pragma</th><th>description</th></tr>
<tr><td><span id="intdefine_1">intdefine</span></td><td>读取构建时定义为整数</td></tr>
<tr><td><span id="strdefine_1">strdefine</span></td><td>读取构建时定义为字符串</td></tr>
<tr><td><span id="booldefine_1">booldefine</span></td><td>读取构建时定义为bool</td></tr>
</table><pre class="listing"><span class="Keyword">const</span> <span class="Identifier">FooBar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">intdefine</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">5</span>
<span class="Identifier">echo</span> <span class="Identifier">FooBar</span></pre><pre>nim c -d:FooBar=42 foobar.nim</pre>
<p>在上面的例子中，提供-d标志会导致符号 <tt class="docutils literal"><span class="pre">FooBar</span></tt> 在编译时被覆盖，打印出42。 如果省略 <tt class="docutils literal"><span class="pre">-d:FooBar = 42</span></tt> ，则使用默认值5。要查看是否提供了值，可以使用 <tt class="docutils literal"><span class="pre">defined(FooBar)</span></tt> 。</p>
<p>语法 <tt class="docutils literal"><span class="pre">-d：flag</span></tt> 实际上只是 <tt class="docutils literal"><span class="pre">-d:flag = true</span></tt> 的快捷方式。</p>

<h2><a class="toc-backref" id="特定实现的编译指示-自定义标注" href="#特定实现的编译指示-自定义标注">自定义标注</a></h2><p>可以定义自定义类型的编译指示。 自定义编译指示不会直接影响代码生成，但可以通过宏检测它们的存在。 使用带有编译指示“pragma”的注释模板定义自定义编译指示：</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">dbTable</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">table_space</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">template</span> <span class="Identifier">dbKey</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">primary_key</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span> <span class="Identifier">false</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">template</span> <span class="Identifier">dbForeignKey</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">template</span> <span class="Identifier">dbIgnore</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>考虑风格化的对象关系映射(ORM)实现示例:</p>
<pre class="listing"><span class="Keyword">const</span> <span class="Identifier">tblspace</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">strdefine</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="StringLit">&quot;dev&quot;</span> <span class="Comment"># dev, test和prod环境的开关</span>

<span class="Keyword">type</span>
  <span class="Identifier">User</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dbTable</span><span class="Punctuation">(</span><span class="StringLit">&quot;users&quot;</span><span class="Punctuation">,</span> <span class="Identifier">tblspace</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">id</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dbKey</span><span class="Punctuation">(</span><span class="Identifier">primary_key</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">name</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="RawData">dbKey&quot;full_name&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Identifier">is_cached</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dbIgnore</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">bool</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  
  <span class="Identifier">UserProfile</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dbTable</span><span class="Punctuation">(</span><span class="StringLit">&quot;profiles&quot;</span><span class="Punctuation">,</span> <span class="Identifier">tblspace</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">id</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dbKey</span><span class="Punctuation">(</span><span class="Identifier">primary_key</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">user_id</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dbForeignKey</span><span class="Punctuation">:</span> <span class="Identifier">User</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">read_access</span><span class="Punctuation">:</span> <span class="Identifier">bool</span>
    <span class="Identifier">write_access</span><span class="Punctuation">:</span> <span class="Identifier">bool</span>
    <span class="Identifier">admin_acess</span><span class="Punctuation">:</span> <span class="Identifier">bool</span></pre><p>在此示例中，自定义编译指示用于描述Nim对象如何映射到关系数据库的模式。 自定义编译指示可以包含零个或多个参数。 为了传递多个参数，请使用模板调用语法之一。 键入所有参数并遵循模板的标准重载决策规则。 因此，可以为参数，按名称传递，varargs等提供默认值。</p>
<p>可以在可以指定普通编译指示的所有位置使用自定义编译指示。 可以注释过程，模板，类型和变量定义，语句等。</p>
<p>宏模块包括帮助程序，可用于简化自定义编译器访问 <tt class="docutils literal"><span class="pre">hasCustomPragma</span></tt> ， <tt class="docutils literal"><span class="pre">getCustomPragmaVal</span></tt> 。 有关详细信息，请参阅宏模块文档。 这些宏没有魔法，它们不会通过遍历AST对象表示做任何你不能做的事情。</p>
<p>自定义编译指示的更多示例：</p>
<ul class="simple"><li>更好的序列化/反序列化控制:</li>
</ul>
<pre class="listing"><span class="Keyword">type</span> <span class="Identifier">MyObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">a</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dontSerialize</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">b</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">defaultDeserialize</span><span class="Punctuation">:</span> <span class="FloatNumber">5.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">c</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">serializationKey</span><span class="Punctuation">:</span> <span class="StringLit">&quot;_c&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre><ul class="simple"><li>在游戏引擎中采用gui检查的类型：</li>
</ul>
<pre class="listing"><span class="Keyword">type</span> <span class="Identifier">MyComponent</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">position</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">editable</span><span class="Punctuation">,</span> <span class="Identifier">animatable</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">Vector3</span>
  <span class="Identifier">alpha</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">editRange</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="FloatNumber">0.0</span><span class="Operator">..</span><span class="FloatNumber">1.0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">animatable</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">float32</span></pre>
<h1><a class="toc-backref" id="外部函数接口" href="#外部函数接口">外部函数接口</a></h1><p>Nim的 <span id="ffi_1">FFI</span> (外部函数接口) 非常广泛，这里只记载扩展到其它未来后端的部分 (如 LLVM/JavaScript后端)。</p>

<h2><a class="toc-backref" id="外部函数接口-importc编译指示" href="#外部函数接口-importc编译指示">Importc编译指示</a></h2><p><tt class="docutils literal"><span class="pre">importc</span></tt> 编译指示提供了一种从C导入proc或变量的方法。 可选参数是包含C标识符的字符串。 如果缺少参数，则C名称与Nim标识符 <em>拼写完全相同</em> ：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">printf</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;stdio.h&gt;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;printf&quot;</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>请注意，此编译指示有点用词不当：其他后端确实在同一名称下提供相同的功能。</p>
<p>此外，如果一个人正在与C++或Objective-C对接，可以使用 <a class="reference external" href="manual.html＃implementation-specific-pragmas-importcpp-pragma">ImportCpp pragma</a> 或 <a class="reference external" href="manual.html＃implementation-specific-pragmas- importobjc-pragma">importObjC pragma</a> 。</p>
<p>传递给 <tt class="docutils literal"><span class="pre">importc</span></tt> 的字符串文字可以是格式字符串：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;prefix$1&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>在示例中， <tt class="docutils literal"><span class="pre">p</span></tt> 的外部名称设置为 <tt class="docutils literal"><span class="pre">prefixp</span></tt> 。 只有 <tt class="docutils literal"><span class="pre">$1</span></tt> 可用，文字美元符号必须写成 <tt class="docutils literal"><span class="pre">$$</span></tt> 。</p>

<h2><a class="toc-backref" id="外部函数接口-exportc编译指示" href="#外部函数接口-exportc编译指示">Exportc编译指示</a></h2><p><tt class="docutils literal"><span class="pre">exportc</span></tt> 编译指示提供了一种将类型，变量或过程导出到C的方法。 枚举和常量无法导出。 可选参数是包含C标识符的字符串。 如果缺少参数，则C名称是Nim标识符 <em>与拼写完全相同</em> ：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">exportc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;callMe&quot;</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>请注意，此编译指示有点用词不当：其他后端确实在同一名称下提供相同的功能。</p>
<p>传递给 <tt class="docutils literal"><span class="pre">exportc</span></tt> 的字符串文字可以是格式字符串：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">exportc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;prefix$1&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">s</span></pre><p>在示例中， <tt class="docutils literal"><span class="pre">p</span></tt> 的外部名称设置为 <tt class="docutils literal"><span class="pre">prefixp</span></tt> 。 只有 <tt class="docutils literal"><span class="pre">$1</span></tt> 可用，文字美元符号必须写成 <tt class="docutils literal"><span class="pre">$$</span></tt> 。</p>

<h2><a class="toc-backref" id="外部函数接口-extern编译指示" href="#外部函数接口-extern编译指示">Extern编译指示</a></h2><p>就像 <tt class="docutils literal"><span class="pre">exportc</span></tt> 或 <tt class="docutils literal"><span class="pre">importc</span></tt> 一样， <tt class="docutils literal"><span class="pre">extern</span></tt> 编译指示会影响名称修改。传递给 <tt class="docutils literal"><span class="pre">extern</span></tt> 的字符串文字可以是格式字符串：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">extern</span><span class="Punctuation">:</span> <span class="StringLit">&quot;prefix$1&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">s</span></pre><p>在示例中， <tt class="docutils literal"><span class="pre">p</span></tt> 的外部名称设置为 <tt class="docutils literal"><span class="pre">prefixp</span></tt> 。只有 <tt class="docutils literal"><span class="pre">$1</span></tt> 可用，文字美元符号必须写成 <tt class="docutils literal"><span class="pre">$$</span></tt> 。</p>

<h2><a class="toc-backref" id="外部函数接口-bycopy编译指示" href="#外部函数接口-bycopy编译指示">Bycopy编译指示</a></h2><p><tt class="docutils literal"><span class="pre">bycopy</span></tt> 编译指示可以应用于对象或元组类型，并指示编译器按类型将类型传递给过程：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Vector</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">bycopy</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">float</span></pre>
<h2><a class="toc-backref" id="外部函数接口-byref编译指示" href="#外部函数接口-byref编译指示">Byref编译指示</a></h2><p><tt class="docutils literal"><span class="pre">byref</span></tt> 编译指示可以应用于对象或元组类型，并指示编译器通过引用（隐藏指针）将类型传递给过程。</p>

<h2><a class="toc-backref" id="外部函数接口-varargs编译指示" href="#外部函数接口-varargs编译指示">Varargs编译指示</a></h2><p><tt class="docutils literal"><span class="pre">varargs</span></tt> 编译指示只适用于过程 (和过程类型)。 它告诉Nim proc可以在最后指定的参数获取可变数量的参数。 Nim字符串值将自动转换为C字符串：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">printf</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">nodecl</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Identifier">printf</span><span class="Punctuation">(</span><span class="StringLit">&quot;hallo %s&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;world&quot;</span><span class="Punctuation">)</span> <span class="Comment"># &quot;world&quot;将作为C字符串传递</span></pre>
<h2><a class="toc-backref" id="外部函数接口-union编译指示" href="#外部函数接口-union编译指示">Union编译指示</a></h2><p><tt class="docutils literal"><span class="pre">union</span></tt> 编译指示适用于任何 <tt class="docutils literal"><span class="pre">对象</span></tt> 类型。 这意味着所有对象的字段在内存中是重叠的。 这会在生成的C / C ++代码中生成一个 <tt class="docutils literal"><span class="pre">union</span></tt> 而不是 <tt class="docutils literal"><span class="pre">struct</span></tt> 。 然后，对象声明不能使用继承或任何GC的内存，但目前尚不做检查。</p>
<p><strong>未来方向</strong>: 应该允许在联合中使用GC内存并且GC应当保守地扫描联合。</p>

<h2><a class="toc-backref" id="外部函数接口-packed编译指示" href="#外部函数接口-packed编译指示">Packed编译指示</a></h2><p><tt class="docutils literal"><span class="pre">packed</span></tt> 编译指示适用于任何 <tt class="docutils literal"><span class="pre">对象</span></tt> 类型。 它确保对象的字段打包在连续的内存中。 将数据包或消息存储到网络或硬件驱动程序以及与C的互操作性非常有用。 没有定义packed编译指示的继承用法，且不应该与GC的内存（ref）一起使用。</p>
<p><strong>未来方向</strong>: 在packed pragma中使用GC内存将导致静态错误。应该定义和记录继承的用法。</p>

<h2><a class="toc-backref" id="外部函数接口-用于导入的dynlib编译指示" href="#外部函数接口-用于导入的dynlib编译指示">用于导入的Dynlib编译指示</a></h2><p>使用 <tt class="docutils literal"><span class="pre">dynlib</span></tt> 编译指示，可以从动态库（Windows的 <tt class="docutils literal"><span class="pre">.dll</span></tt> 文件，UNIX的 <tt class="docutils literal"><span class="pre">lib*.so</span></tt> 文件）导入过程或变量。</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">gtk_image_new</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PGtkWidget</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="StringLit">&quot;libgtk-x11-2.0.so&quot;</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>通常，导入动态库不需要任何特殊的链接器选项或链接到导入库。 这也意味着不需要安装 <em>开发</em> 包。</p>
<p><tt class="docutils literal"><span class="pre">dynlib</span></tt> 导入机制支持版本控制方案：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">Tcl_Eval</span><span class="Punctuation">(</span><span class="Identifier">interp</span><span class="Punctuation">:</span> <span class="Identifier">pTcl_Interp</span><span class="Punctuation">,</span> <span class="Identifier">script</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span>
  <span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="StringLit">&quot;libtcl(|8.5|8.4|8.3).so.(1|0)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>在运行时，搜索动态库（按此顺序）</p>
<blockquote><p>libtcl.so.1 libtcl.so.0 libtcl8.5.so.1 libtcl8.5.so.0 libtcl8.4.so.1 libtcl8.4.so.0 libtcl8.3.so.1 libtcl8.3.so.0</p></blockquote>
<p><tt class="docutils literal"><span class="pre">dynlib</span></tt> 编译指示不仅支持常量字符串作为参数，还支持字符串表达式：</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">os</span>

<span class="Keyword">proc</span> <span class="Identifier">getDllName</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;mylib.dll&quot;</span>
  <span class="Keyword">if</span> <span class="Identifier">existsFile</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;mylib2.dll&quot;</span>
  <span class="Keyword">if</span> <span class="Identifier">existsFile</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span>
  <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;could not load dynamic library&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">myImport</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="Identifier">getDllName</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p><strong>注意</strong>: 形如 <tt class="docutils literal"><span class="pre">libtcl(|8.5|8.4).so</span></tt> 只支持常量字符串，因为它们需要预编译。</p>
<p><strong>注意</strong>: 传变量给 <tt class="docutils literal"><span class="pre">dynlib</span></tt> 编译指示在进行时会失败，因为初始化问题的顺序。</p>
<p><strong>注意</strong>: <tt class="docutils literal"><span class="pre">dynlib</span></tt> 导入可以用 <tt class="docutils literal"><span class="pre">--dynlibOverride:name</span></tt> 命令行选项重写。 编译器用户指南包括更多信息。</p>

<h2><a class="toc-backref" id="外部函数接口-用于导出的dynlib编译指示" href="#外部函数接口-用于导出的dynlib编译指示">用于导出的Dynlib编译指示</a></h2><p>过程可以用 <tt class="docutils literal"><span class="pre">dynlib</span></tt> 编译指示导出到一个动态库。 编译指示没有实参而且必须和 <tt class="docutils literal"><span class="pre">exportc</span></tt> 拼接在一起:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">exportme</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span> <span class="Identifier">exportc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>这只有当程序通过 <tt class="docutils literal"><span class="pre">--app:lib</span></tt> 命令行选项编译为动态库时有用。 此编译指示仅对Windows目标上的代码生成有影响，因此当忘写并且仅在Mac和/或Linux上测试动态库时，不会出现错误。 在Windows上，这个编译指示在函数声明中添加了 <tt class="docutils literal"><span class="pre">__declspec(dllexport)</span></tt> 。</p>

<h1><a class="toc-backref" id="线程" href="#线程">线程</a></h1><p>要启用线程支持，需要使用 <tt class="docutils literal"><span class="pre">--threads:on</span></tt> 命令行开关。 然后 <tt class="docutils literal"><span class="pre">system</span></tt> 模块包含几个线程原语。 请参阅低级线程API <a class="reference external" href="threads.html">threads</a> 和 <a class="reference external" href="channels.html">channels</a>  模块。 还有高级并行结构可用。见 <a class="reference external" href="manual_experimental.html#parallel-amp-spawn">spawn</a> 更多细节。</p>
<p>Nim的线程内存模型与其他常见编程语言（C，Pascal，Java）完全不同：每个线程都有自己的（垃圾收集）堆，内存共享仅限于全局变量。 这有助于防止竞争条件。 GC效率得到了很大提高，因为GC永远不必停止其他线程并看到它们引用的内容。</p>

<h2><a class="toc-backref" id="线程-thread编译指示" href="#线程-thread编译指示">Thread编译指示</a></h2><p>作为新执行线程执行的proc应该由 <tt class="docutils literal"><span class="pre">thread</span></tt> 编译指示标记，以便于阅读。 编译器检查是否存在 <span class="dx">无堆共享限制</span>: 的违规。此限制意味着构造一个由不同（线程本地）堆分配的内存组成的数据结构是无效的。</p>
<p>线程proc被传递给 <tt class="docutils literal"><span class="pre">createThread</span></tt> 或 <tt class="docutils literal"><span class="pre">spawn</span></tt> 并间接调用；所以 <tt class="docutils literal"><span class="pre">thread</span></tt> 编译指示暗示 <tt class="docutils literal"><span class="pre">procvar</span></tt> 。</p>

<h2><a class="toc-backref" id="线程-gc安全" href="#线程-gc安全">GC安全</a></h2><p>当过程不通过调用GC不安全的过程直接或间接访问任何含有GC内存的全局变量(<tt class="docutils literal"><span class="pre">string</span></tt>, <tt class="docutils literal"><span class="pre">seq</span></tt>, <tt class="docutils literal"><span class="pre">ref</span></tt> 或闭包)时，我们称过程 <tt class="docutils literal"><span class="pre">p</span></tt> <span id="gc安全_1">GC安全</span> 。</p>
<p><span id="gcsafe_1">gcsafe</span> 可用于将proc标记为gcsafe，否则此属性由编译器推断。 请注意， <tt class="docutils literal"><span class="pre">noSideEffect</span></tt> 意味着 <tt class="docutils literal"><span class="pre">gcsafe</span></tt> 。创建线程的唯一方法是通过 <tt class="docutils literal"><span class="pre">spawn</span></tt> 或 <tt class="docutils literal"><span class="pre">createThread</span></tt> 。 被调用的proc不能使用 <tt class="docutils literal"><span class="pre">var</span></tt> 参数，也不能使用任何参数包含 <tt class="docutils literal"><span class="pre">ref</span></tt> 或 <tt class="docutils literal"><span class="pre">closure</span></tt> 类型。 这会强制执行 <em>无堆共享限制</em> 。</p>
<p>从C导入的例程总是被假定为 <tt class="docutils literal"><span class="pre">gcsafe</span></tt> 。 要禁用GC安全检查，可以使用 <tt class="docutils literal"><span class="pre">--threadAnalysis:off</span></tt> 命令行开关。 这是一种临时解决方法，可以简化从旧代码到新线程模型的移植工作。</p>
<p>要覆盖编译器的gcsafety分析，可以使用 <tt class="docutils literal"><span class="pre">{.gcsafe.}</span></tt> 编译指示:</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">someGlobal</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string here&quot;</span>
  <span class="Identifier">perThread</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">threadvar</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">string</span>

<span class="Keyword">proc</span> <span class="Identifier">setPerThread</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">gcsafe</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">deepCopy</span><span class="Punctuation">(</span><span class="Identifier">perThread</span><span class="Punctuation">,</span> <span class="Identifier">someGlobal</span><span class="Punctuation">)</span></pre><p>未来的方向:</p>
<ul class="simple"><li>可能会提供一个共享的GC堆内存。</li>
</ul>

<h2><a class="toc-backref" id="线程-threadvar编译指示" href="#线程-threadvar编译指示">Threadvar编译指示</a></h2><p>变量可以用 <tt class="docutils literal"><span class="pre">threadvar</span></tt> 编译指示标记，使它成为 <span id="threadminuslocal_1">thread-local</span> 变量; 另外，这意味着 <tt class="docutils literal"><span class="pre">global</span></tt> 编译指示的所有效果。</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">checkpoints</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">threadvar</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span></pre><p>由于实现限制，无法在 <tt class="docutils literal"><span class="pre">var</span></tt> 部分中初始化线程局部变量。 （在创建线程时需要复制每个线程局部变量。）</p>

<h2><a class="toc-backref" id="线程-线程和异常" href="#线程-线程和异常">线程和异常</a></h2><p>线程和异常之间的交互很简单：一个线程中的 <em>处理过的</em> 异常不会影响任何其他线程。但是，一个线程中的 <em>未处理的</em> 异常终止整个 <em>进程</em> 。</p>
</p>
  
  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small>Made with Nim. Generated: 2020-03-14 05:19:29 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
