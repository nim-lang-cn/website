<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>Nim教程 (I)</title>
<style type="text/css" >
/*
Stylesheet for use with Docutils/rst2html.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.

Modified from Chad Skeeters' rst2html-style
https://bitbucket.org/cskeeters/rst2html-style/

Modified by Boyd Greenfield and narimiran
*/

html {
  font-size: 100%;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%; }

body {
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif;
  font-weight: 400;
  font-size: 1.125em;
  line-height: 1.5;
  color: #222;
  background-color: #FCFCFC; }

/* Skeleton grid */
.container {
  position: relative;
  width: 100%;
  max-width: 1050px;
  margin: 0 auto;
  padding: 0;
  box-sizing: border-box; }

.column,
.columns {
  width: 100%;
  float: left;
  box-sizing: border-box;
  margin-left: 1%;
}

.column:first-child,
.columns:first-child {
  margin-left: 0; }

.three.columns {
  width: 19%; }

.nine.columns {
  width: 80.0%; }

.twelve.columns {
  width: 100%;
  margin-left: 0; }

@media screen and (max-width: 860px) {
  .three.columns {
    display: none;
  }
  .nine.columns {
    width: 98.0%;
  }
  body {
    font-size: 1em;
    line-height: 1.35;
  }
}

cite {
  font-style: italic !important; }


/* Nim search input */
div#searchInputDiv {
  margin-bottom: 1em;
}
input#searchInput {
  width: 80%;
}

/*
 * Some custom formatting for input forms.
 * This also fixes input form colors on Firefox with a dark system theme on Linux.
 */
input {
  -moz-appearance: none;
  color: #333;
  background-color: #f8f8f8;
  border: 1px solid #aaa;
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif;
  font-size: 0.9em;
  padding: 6px;
}
input:focus {
  border: 1px solid #1fa0eb;
  box-shadow: 0 0 2px #1fa0eb;
}

/* Docgen styles */
/* Links */
a {
  color: #07b;
  text-decoration: none;
}

a span.Identifier {
  text-decoration: underline;
  text-decoration-color: #aab;
}

a.reference-toplevel {
  font-weight: bold;
}

a.toc-backref {
  text-decoration: none;
  color: #222; }

a.link-seesrc {
  color: #607c9f;
  font-size: 0.9em;
  font-style: italic; }

a:hover,
a:focus {
  color: #607c9f;
  text-decoration: underline; }

a:hover span.Identifier {
  color: #607c9f;
}


sub,
sup {
  position: relative;
  font-size: 75%;
  line-height: 0;
  vertical-align: baseline; }

sup {
  top: -0.5em; }

sub {
  bottom: -0.25em; }

img {
  width: auto;
  height: auto;
  max-width: 100%;
  vertical-align: middle;
  border: 0;
  -ms-interpolation-mode: bicubic; }

@media print {
  * {
    color: black !important;
    text-shadow: none !important;
    background: transparent !important;
    box-shadow: none !important; }

  a,
  a:visited {
    text-decoration: underline; }

  a[href]:after {
    content: " (" attr(href) ")"; }

  abbr[title]:after {
    content: " (" attr(title) ")"; }

  .ir a:after,
  a[href^="javascript:"]:after,
  a[href^="#"]:after {
    content: ""; }

  pre,
  blockquote {
    border: 1px solid #999;
    page-break-inside: avoid; }

  thead {
    display: table-header-group; }

  tr,
  img {
    page-break-inside: avoid; }

  img {
    max-width: 100% !important; }

  @page {
    margin: 0.5cm; }

  h1 {
    page-break-before: always; }

  h1.title {
    page-break-before: avoid; }

  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3; }

  h2,
  h3 {
    page-break-after: avoid; }
}


p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

small {
  font-size: 85%; }

strong {
  font-weight: 600;
  font-size: 0.95em;
  color: #3c3c3c;
}

em {
  font-style: italic; }

h1 {
  font-size: 1.8em;
  font-weight: 400;
  padding-bottom: .25em;
  border-bottom: 1px solid #aaa;
  margin-top: 2.5em;
  margin-bottom: 1em;
  line-height: 1.2em; }

h1.title {
  padding-bottom: 1em;
  border-bottom: 0px;
  font-size: 2.5em;
  text-align: center;
  font-weight: 900;
  margin-top: 0.75em;
  margin-bottom: 0em;
}

h2 {
  font-size: 1.3em;
  margin-top: 2em; }

h2.subtitle {
  text-align: center; }

h3 {
  font-size: 1.125em;
  font-style: italic;
  margin-top: 1.5em; }

h4 {
  font-size: 1.125em;
  margin-top: 1em; }

h5 {
  font-size: 1.125em;
  margin-top: 0.75em; }

h6 {
  font-size: 1.1em; }


ul,
ol {
  padding: 0;
  margin-top: 0.5em;
  margin-left: 0.75em; }

ul ul,
ul ol,
ol ol,
ol ul {
  margin-bottom: 0;
  margin-left: 1.25em; }

li {
    list-style-type: circle;
}

ul.simple-boot li {
    list-style-type: none;
    margin-left: 0em;
    margin-bottom: 0.5em;
}

ol.simple > li, ul.simple > li {
  margin-bottom: 0.25em;
  margin-left: 0.4em }

ul.simple.simple-toc > li {
    margin-top: 1em;
}

ul.simple-toc {
  list-style: none;
  font-size: 0.9em;
  margin-left: -0.3em;
  margin-top: 1em; }

ul.simple-toc > li {
    list-style-type: none;
}

ul.simple-toc-section {
  list-style-type: circle;
  margin-left: 1em;
  color: #6c9aae; }


ol.arabic {
  list-style: decimal; }

ol.loweralpha {
  list-style: lower-alpha; }

ol.upperalpha {
  list-style: upper-alpha; }

ol.lowerroman {
  list-style: lower-roman; }

ol.upperroman {
  list-style: upper-roman; }

ul.auto-toc {
  list-style-type: none; }


dl {
  margin-bottom: 1.5em; }

dt {
  margin-bottom: -0.5em;
  margin-left: 0.0em; }

dd {
  margin-left: 2.0em;
  margin-bottom: 3.0em;
  margin-top: 0.5em; }


hr {
  margin: 2em 0;
  border: 0;
  border-top: 1px solid #aaa; }

blockquote {
  font-size: 0.9em;
  font-style: italic;
  padding-left: 0.5em;
  margin-left: 0;
  border-left: 5px solid #bbc;
}

.pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  font-weight: 500;
  font-size: 0.85em;
  background-color: #f0f3ff;
  padding-left: 3px;
  padding-right: 3px;
  border-radius: 4px;
}

pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  color: #222;
  font-weight: 500;
  display: inline-block;
  box-sizing: border-box;
  min-width: 100%;
  padding: 0.5em;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  font-size: 0.85em;
  white-space: pre !important;
  overflow-y: hidden;
  overflow-x: visible;
  background-color: ghostwhite;
  border: 1px solid #dde;
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.pre-scrollable {
  max-height: 340px;
  overflow-y: scroll; }


/* Nim line-numbered tables */
.line-nums-table {
  width: 100%;
  table-layout: fixed; }

table.line-nums-table {
  border-radius: 4px;
  border: 1px solid #cccccc;
  background-color: ghostwhite;
  border-collapse: separate;
  margin-top: 15px;
  margin-bottom: 25px; }

.line-nums-table tbody {
  border: none; }

.line-nums-table td pre {
  border: none;
  background-color: transparent; }

.line-nums-table td.blob-line-nums {
  width: 28px; }

.line-nums-table td.blob-line-nums pre {
  color: #b0b0b0;
  -webkit-filter: opacity(75%);
  text-align: right;
  border-color: transparent;
  background-color: transparent;
  padding-left: 0px;
  margin-left: 0px;
  padding-right: 0px;
  margin-right: 0px; }


table {
  max-width: 100%;
  background-color: transparent;
  margin-top: 0.5em;
  margin-bottom: 1.5em;
  border-collapse: collapse;
  border-color: #ccc;
  border-spacing: 0;
  font-size: 0.9em;
}

table th, table td {
  padding: 0px 0.5em 0px;
}

table th {
  background-color: #e8e8e8;
  font-weight: bold; }

table th.docinfo-name {
    background-color: transparent;
}

table tr:hover {
  background-color: ghostwhite; }


/* rst2html default used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0; }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 !important; }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 !important; }

.last, .with-subtitle {
  margin-bottom: 0 !important; }

.hidden {
  display: none; }

blockquote.epigraph {
  margin: 2em 5em; }

dl.docutils dd {
  margin-bottom: 0.5em; }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden; }


div.figure {
  margin-left: 2em;
  margin-right: 2em; }

div.footer, div.header {
  clear: both;
  text-align: center;
  color: #666;
  font-size: smaller; }

div.footer {
    padding-top: 5em;
}

div.line-block {
  display: block;
  margin-top: 1em;
  margin-bottom: 1em; }

div.line-block div.line-block {
  margin-top: 0;
  margin-bottom: 0;
  margin-left: 1.5em; }

div.topic {
  margin: 2em; }

div.search_results {
  background-color: antiquewhite;
  margin: 3em;
  padding: 1em;
  border: 1px solid #4d4d4d;
}

div#global-links ul {
  margin-left: 0;
  list-style-type: none;
}

div#global-links > simple-boot {
    margin-left: 3em;
}

hr.docutils {
  width: 75%; }

img.align-left, .figure.align-left, object.align-left {
  clear: left;
  float: left;
  margin-right: 1em; }

img.align-right, .figure.align-right, object.align-right {
  clear: right;
  float: right;
  margin-left: 1em; }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto; }

.align-left {
  text-align: left; }

.align-center {
  clear: both;
  text-align: center; }

.align-right {
  text-align: right; }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit; }

p.attribution {
  text-align: right;
  margin-left: 50%; }

p.caption {
  font-style: italic; }

p.credits {
  font-style: italic;
  font-size: smaller; }

p.label {
  white-space: nowrap; }

p.rubric {
  font-weight: bold;
  font-size: larger;
  color: maroon;
  text-align: center; }

p.topic-title {
  font-weight: bold; }

pre.address {
  margin-bottom: 0;
  margin-top: 0;
  font: inherit; }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em;
  margin-right: 2em; }

pre.code .ln {
  color: grey; }

/* line numbers */
pre.code, code {
  background-color: #eeeeee; }

pre.code .comment, code .comment {
  color: #5c6576; }

pre.code .keyword, code .keyword {
  color: #3B0D06;
  font-weight: bold; }

pre.code .literal.string, code .literal.string {
  color: #0c5404; }

pre.code .name.builtin, code .name.builtin {
  color: #352b84; }

pre.code .deleted, code .deleted {
  background-color: #DEB0A1; }

pre.code .inserted, code .inserted {
  background-color: #A3D289; }

span.classifier {
  font-style: oblique; }

span.classifier-delimiter {
  font-weight: bold; }

span.option {
  white-space: nowrap; }

span.problematic {
  color: #b30000; }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80%; }

span.DecNumber {
  color: #252dbe; }

span.BinNumber {
  color: #252dbe; }

span.HexNumber {
  color: #252dbe; }

span.OctNumber {
  color: #252dbe; }

span.FloatNumber {
  color: #252dbe; }

span.Identifier {
  color: #222; }

span.Keyword {
  font-weight: 600;
  color: #5e8f60; }

span.StringLit {
  color: #a4255b; }

span.LongStringLit {
  color: #a4255b; }

span.CharLit {
  color: #a4255b; }

span.EscapeSequence {
  color: black; }

span.Operator {
  color: black; }

span.Punctuation {
  color: black; }

span.Comment, span.LongComment {
  font-style: italic;
  font-weight: 400;
  color: #484a86; }

span.RegularExpression {
  color: darkviolet; }

span.TagStart {
  color: darkviolet; }

span.TagEnd {
  color: darkviolet; }

span.Key {
  color: #252dbe; }

span.Value {
  color: #252dbe; }

span.RawData {
  color: #a4255b; }

span.Assembler {
  color: #252dbe; }

span.Preprocessor {
  color: #252dbe; }

span.Directive {
  color: #252dbe; }

span.Command, span.Rule, span.Hyperlink, span.Label, span.Reference,
span.Other {
  color: black; }

/* Pop type, const, proc, and iterator defs in nim def blocks */
dt pre > span.Identifier, dt pre > span.Operator {
  color: #155da4;
  font-weight: 700; }

dt pre > span.Keyword ~ span.Identifier, dt pre > span.Identifier ~ span.Identifier,
dt pre > span.Operator ~ span.Identifier, dt pre > span.Other ~ span.Identifier {
  color: inherit;
  font-weight: inherit; }

/* Nim sprite for the footer (taken from main page favicon) */
.nim-sprite {
  display: inline-block;
  height: 16px;
  width: 16px;
  background-position: 0 0;
  background-size: 16px 16px;
  -webkit-filter: opacity(50%);
  background-repeat: no-repeat;
  background-image: url("data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA==");
  margin-bottom: -5px; }

span.pragmadots {
  /* Position: relative frees us up to make the dots
  look really nice without fucking up the layout and
  causing bulging in the parent container */
  position: relative;
  /* 1px down looks slightly nicer */
  top: 1px;
  padding: 2px;
  background-color: #e8e8e8;
  border-radius: 4px;
  margin: 0 2px;
  cursor: pointer;
  font-size: 0.8em;
}

span.pragmadots:hover {
  background-color: #DBDBDB;
}
span.pragmawrap {
  display: none;
}

span.attachedType {
  display: none;
  visibility: hidden;
}
</style>

<script type="text/javascript" src="dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }
}
</script>

</head>
<body onload="main()">
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Nim教程 (I)</h1>
    <div class="row">
  <div class="three columns">
  <div id="global-links">
    <ul class="simple-boot">
      <li>
        <a href="manual.html">Manual</a>
      </li>
      <li>
        <a href="lib.html">Standard library</a>
      </li>
      <li>
        <a href="theindex.html">Index</a>
      </li>
    </ul>
  </div>
  <div id="searchInputDiv">
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
  <ul class="simple simple-toc" id="toc-list">
<li><a class="reference" id="引言_toc" href="#引言">引言</a></li>
<li><a class="reference" id="第一个程序_toc" href="#第一个程序">第一个程序</a></li>
<li><a class="reference" id="词法元素_toc" href="#词法元素">词法元素</a></li>
<ul class="simple"><li><a class="reference" id="词法元素-字符串和字符字面值_toc" href="#词法元素-字符串和字符字面值">字符串和字符字面值</a></li>
<li><a class="reference" id="词法元素-注释_toc" href="#词法元素-注释">注释</a></li>
<li><a class="reference" id="词法元素-数字_toc" href="#词法元素-数字">数字</a></li>
</ul><li><a class="reference" id="var语句_toc" href="#var语句">var语句</a></li>
<li><a class="reference" id="赋值语句_toc" href="#赋值语句">赋值语句</a></li>
<li><a class="reference" id="常量_toc" href="#常量">常量</a></li>
<li><a class="reference" id="let语句_toc" href="#let语句">let语句</a></li>
<li><a class="reference" id="流程控制语句_toc" href="#流程控制语句">流程控制语句</a></li>
<ul class="simple"><li><a class="reference" id="流程控制语句-if语句_toc" href="#流程控制语句-if语句">If语句</a></li>
<li><a class="reference" id="流程控制语句-case语句_toc" href="#流程控制语句-case语句">Case语句</a></li>
<li><a class="reference" id="流程控制语句-while语句_toc" href="#流程控制语句-while语句">While语句</a></li>
<li><a class="reference" id="流程控制语句-for语句_toc" href="#流程控制语句-for语句">For语句</a></li>
<li><a class="reference" id="流程控制语句-作用域和块语句_toc" href="#流程控制语句-作用域和块语句">作用域和块语句</a></li>
<li><a class="reference" id="流程控制语句-break语句_toc" href="#流程控制语句-break语句">Break语句</a></li>
<li><a class="reference" id="流程控制语句-continue语句_toc" href="#流程控制语句-continue语句">Continue语句</a></li>
<li><a class="reference" id="流程控制语句-when语句_toc" href="#流程控制语句-when语句">When语句</a></li>
</ul><li><a class="reference" id="语句和缩进_toc" href="#语句和缩进">语句和缩进</a></li>
<li><a class="reference" id="过程_toc" href="#过程">过程</a></li>
<ul class="simple"><li><a class="reference" id="过程-result变量_toc" href="#过程-result变量">Result变量</a></li>
<li><a class="reference" id="过程-形参_toc" href="#过程-形参">形参</a></li>
<li><a class="reference" id="过程-discard语句_toc" href="#过程-discard语句">Discard语句</a></li>
<li><a class="reference" id="过程-命名参数_toc" href="#过程-命名参数">命名参数</a></li>
<li><a class="reference" id="过程-默认值_toc" href="#过程-默认值">默认值</a></li>
<li><a class="reference" id="过程-重载过程_toc" href="#过程-重载过程">重载过程</a></li>
<li><a class="reference" id="过程-操作符_toc" href="#过程-操作符">操作符</a></li>
<li><a class="reference" id="过程-前向声明_toc" href="#过程-前向声明">前向声明</a></li>
</ul><li><a class="reference" id="迭代器_toc" href="#迭代器">迭代器</a></li>
<li><a class="reference" id="基本类型_toc" href="#基本类型">基本类型</a></li>
<ul class="simple"><li><a class="reference" id="基本类型-布尔值_toc" href="#基本类型-布尔值">布尔值</a></li>
<li><a class="reference" id="基本类型-字符_toc" href="#基本类型-字符">字符</a></li>
<li><a class="reference" id="基本类型-字符串_toc" href="#基本类型-字符串">字符串</a></li>
<li><a class="reference" id="基本类型-整型_toc" href="#基本类型-整型">整型</a></li>
<li><a class="reference" id="基本类型-浮点_toc" href="#基本类型-浮点">浮点</a></li>
<li><a class="reference" id="基本类型-类型转换_toc" href="#基本类型-类型转换">类型转换</a></li>
</ul><li><a class="reference" id="内部类型表示_toc" href="#内部类型表示">内部类型表示</a></li>
<li><a class="reference" id="高级类型_toc" href="#高级类型">高级类型</a></li>
<ul class="simple"><li><a class="reference" id="高级类型-枚举_toc" href="#高级类型-枚举">枚举</a></li>
<li><a class="reference" id="高级类型-序数类型_toc" href="#高级类型-序数类型">序数类型</a></li>
<li><a class="reference" id="高级类型-子范围_toc" href="#高级类型-子范围">子范围</a></li>
<li><a class="reference" id="高级类型-集合类型_toc" href="#高级类型-集合类型">集合类型</a></li>
<ul class="simple"><li><a class="reference" id="集合类型-位字段_toc" href="#集合类型-位字段">位字段</a></li>
</ul><li><a class="reference" id="高级类型-数组_toc" href="#高级类型-数组">数组</a></li>
<li><a class="reference" id="高级类型-序列_toc" href="#高级类型-序列">序列</a></li>
<li><a class="reference" id="高级类型-开放数组_toc" href="#高级类型-开放数组">开放数组</a></li>
<li><a class="reference" id="高级类型-可变参数_toc" href="#高级类型-可变参数">可变参数</a></li>
<li><a class="reference" id="高级类型-切片_toc" href="#高级类型-切片">切片</a></li>
<li><a class="reference" id="高级类型-对象_toc" href="#高级类型-对象">对象</a></li>
<li><a class="reference" id="高级类型-元组_toc" href="#高级类型-元组">元组</a></li>
<li><a class="reference" id="高级类型-引用和指针类型_toc" href="#高级类型-引用和指针类型">引用和指针类型</a></li>
<li><a class="reference" id="高级类型-过程类型_toc" href="#高级类型-过程类型">过程类型</a></li>
<li><a class="reference" id="高级类型-distinct类型_toc" href="#高级类型-distinct类型">Distinct类型</a></li>
</ul><li><a class="reference" id="模块_toc" href="#模块">模块</a></li>
<ul class="simple"><li><a class="reference" id="模块-排除符号_toc" href="#模块-排除符号">排除符号</a></li>
<li><a class="reference" id="模块-from语句_toc" href="#模块-from语句">From语句</a></li>
<li><a class="reference" id="模块-include语句_toc" href="#模块-include语句">Include语句</a></li>
</ul><li><a class="reference" id="part-2_toc" href="#part-2">Part 2</a></li>

</ul>

  </div>
  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  
  <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">Author:</th><td> Andreas Rumpf</td></tr>
<tr><th class="docinfo-name">Version:</th><td> |nimversion|</td></tr>
</tbody></table>
<h1><a class="toc-backref" id="引言" href="#引言">引言</a></h1><blockquote><p>
"人是一种视觉动物 -- 我渴望美好事物。"
</p></blockquote><p>本文是编程语言Nim的教程。该教程认为你熟悉基本的编程概念如变量、类型和语句但非常基础。 <a class="reference external" href="manual.html">manual</a>  包含更多的高级特性示例。本教程的代码示例和其它的Nim文档遵守 <a class="reference external" href="nep1.html">Nim style guide</a> 。</p>

<h1><a class="toc-backref" id="第一个程序" href="#第一个程序">第一个程序</a></h1><p>我们从一个调整过的&quot;hello world&quot;程序开始：</p>
<pre class="listing"><span class="Comment"># 这是注释</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;What's your name? &quot;</span>
<span class="Keyword">var</span> <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;Hi, &quot;</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="StringLit">&quot;!&quot;</span></pre><p>保存到文件&quot;greetings.nim&quot;，编译运行：</p>
<blockquote><p>nim compile --run greetings.nim</p></blockquote>
<p>用 <tt class="docutils literal"><span class="pre">--run</span></tt> <a class="reference external" href="nimc.html#compiler-usage-command-line-switches">switch</a> Nim在编译之后自动执行文件。你可以在文件名后给程序追加命令行参数nim compile --run greetings.nim arg1 arg2</p>
<p>经常使用的命令和开关有缩写，所以你可以用:<pre>
nim c -r greetings.nim</pre>
</p>
<p>编译发布版使用:<pre>
nim c -d:release greetings.nim</pre>
</p>
<p>Nim编译器默认生成大量运行时检查，旨在方便调试。用 <tt class="docutils literal"><span class="pre">-d:release</span></tt>  <a class="reference external" href="nimc.html#compiler-usage-compile-time-symbols">关闭一些检查并且打开优化</a> 。 （译者注，-d:release的功能在最近的版本已经发生变化，现在会打开运行时检查，使用-d:danger来替代，以生成更好性能的代码）</p>
<p>程序的作用显而易见，需要解释下语法：没有缩进的语句会在程序开始时执行。缩进是Nim语句进行分组的方式。缩进仅允许空格，不允许制表符。</p>
<p>字符串字面值用双引号括起来。 <tt class="docutils literal"><span class="pre">var</span></tt> 语句声明一个新的名为 <tt class="docutils literal"><span class="pre">name</span></tt> ，类型为 <tt class="docutils literal"><span class="pre">string</span></tt> ，值为 <a class="reference external" href="system.html#readLine,File">readLine</a> 方法返回值的变量名。 因为编译器知道 <a class="reference external" href="system.html#readLine,File">readLine</a> 返回一个字符串，你可以省略声明中的类型(这叫作 <span id="局部类型推导_1">局部类型推导</span> )。所以也可以这样：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span></pre><p>请注意，这基本上是Nim中存在的唯一类型推导形式：兼顾简洁与可读。</p>
<p>&quot;hello world&quot;程序包括一些编译器已知的标识符： <tt class="docutils literal"><span class="pre">echo</span></tt> ， <a class="reference external" href="system.html#readLine,File">readLine</a> 等。这些内置声名在 <a class="reference external" href="system.html">system</a> <a class="reference external" href="#模块中，system">模块中，system</a> 模块通过其它模块隐式的导出。</p>

<h1><a class="toc-backref" id="词法元素" href="#词法元素">词法元素</a></h1><p>让我们看看Nim词法元素的更多细节：像其它编程语言一样，Nim由（字符串）字面值、标识符、关键字、注释、操作符、和其它标点符号构成。</p>

<h2><a class="toc-backref" id="词法元素-字符串和字符字面值" href="#词法元素-字符串和字符字面值">字符串和字符字面值</a></h2><p>字符串字面值通过双引号括起来；字符字面值用单引号。特殊字符通过 <tt class="docutils literal"><span class="pre">\</span></tt> 转义: <tt class="docutils literal"><span class="pre">\n</span></tt> 表示换行， <tt class="docutils literal"><span class="pre">\t</span></tt> 表示制表符等，还有 <em>原始</em> 字符串字面值：</p>
<pre class="listing"><span class="RawData">r&quot;C:\program files\nim&quot;</span></pre><p>在原始字面值中反斜杠不是转义字符。</p>
<p>第三种也是最后一种写字符串字面值的方法是 <em>长字符串字面值</em> 。用三引号 <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;...&quot;&quot;&quot;</span></tt> 写，他们可以跨行并且 <tt class="docutils literal"><span class="pre">\</span></tt> 也不是转义字符。例如它们对嵌入HTML代码模板很有用。</p>

<h2><a class="toc-backref" id="词法元素-注释" href="#词法元素-注释">注释</a></h2><p>注释在任何字符串或字符字面值之外，以哈希字符 <tt class="docutils literal"><span class="pre">#</span></tt> 开始，文档以 <tt class="docutils literal"><span class="pre">##</span></tt> 开始：</p>
<pre class="listing"><span class="Comment"># 注释。</span>

<span class="Keyword">var</span> <span class="Identifier">myVariable</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment">## 文档注释</span></pre><p>文档注释是令牌；它们只允许在输入文件中的某些位置，因为它们属于语法树！这个功能可实现更简单的文档生成器。</p>
<p>多行注释以 <tt class="docutils literal"><span class="pre">#[</span></tt> 开始，以 <tt class="docutils literal"><span class="pre">]#</span></tt> 结束。多行注释也可以嵌套。</p>
<pre class="listing"><span class="LongComment">#[
You can have any Nim code text commented
out inside this with no indentation restrictions.
      yes(&quot;May I ask a pointless question?&quot;)
  #[
     Note: these can be nested!!
  ]#
]#</span></pre><p>你也可以和 <em>长字符串字面值</em> 一起使用 <a class="reference external" href="#procedures-discard-statement">discard语句</a> 来构建块注释。</p>
<pre class="listing"><span class="Keyword">discard</span> <span class="LongStringLit">&quot;&quot;&quot; You can have any Nim code text commented
out inside this with no indentation restrictions.
      yes(&quot;May I ask a pointless question?&quot;) &quot;&quot;&quot;</span></pre>
<h2><a class="toc-backref" id="词法元素-数字" href="#词法元素-数字">数字</a></h2><p>数字字面值与其它大多数语言一样。作为一个特别的地方，为了更好的可读性，允许使用下划线： <tt class="docutils literal"><span class="pre">1_000_000</span></tt> (一百万)。 包含点（或者'e'或'E'）的数字是浮点字面值： <tt class="docutils literal"><span class="pre">1.0e9</span></tt> （十亿）。十六进制字面值前缀是 <tt class="docutils literal"><span class="pre">0x</span></tt> ，二进制字面值用 <tt class="docutils literal"><span class="pre">0b</span></tt> ，八进制用 <tt class="docutils literal"><span class="pre">0o</span></tt> 。 单独一个前导零不产生八进制。</p>

<h1><a class="toc-backref" id="var语句" href="#var语句">var语句</a></h1><p>var语句声明一个本地或全局变量:</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># 声明x和y拥有类型 ``int``</span></pre><p>缩进可以用在 <tt class="docutils literal"><span class="pre">var</span></tt> 关键字后来列一个变量段。</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Comment"># 可以有注释</span>
  <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre>
<h1><a class="toc-backref" id="赋值语句" href="#赋值语句">赋值语句</a></h1><p>赋值语句为一个变量赋予新值或者更一般地，赋值到一个存储地址：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span> <span class="Comment"># 引入一个新变量`x`并且赋值给它</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;xyz&quot;</span>     <span class="Comment"># 赋新值给 `x`</span></pre><p><tt class="docutils literal"><span class="pre">=</span></tt> 是 <em>赋值操作符</em> 。赋值操作符可以重载。你可以用一个赋值语句声明多个变量并且所有的变量具有相同的类型：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">3</span>  <span class="Comment"># 给变量`x`和`y`赋值3</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;x &quot;</span><span class="Punctuation">,</span> <span class="Identifier">x</span>  <span class="Comment"># 输出 &quot;x 3&quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;y &quot;</span><span class="Punctuation">,</span> <span class="Identifier">y</span>  <span class="Comment"># 输出 &quot;y 3&quot;</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">42</span>        <span class="Comment"># 改变`x`为42而不改变`y`</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;x &quot;</span><span class="Punctuation">,</span> <span class="Identifier">x</span>  <span class="Comment"># 输出&quot;x 42&quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;y &quot;</span><span class="Punctuation">,</span> <span class="Identifier">y</span>  <span class="Comment"># 输出&quot;y 3&quot;</span></pre><p>注意，使用过程对声明的多个变量进行赋值时可能会产生意外结果：编译器会 <em>展开</em> 赋值并多次调用该过程。 如果程序的结果取决于副作用，变量可能最终会有不同的值。为了安全起见，多赋值时使用没有副作用的过程。</p>

<h1><a class="toc-backref" id="常量" href="#常量">常量</a></h1><p>常量是绑定在一个值上的符号。常量值不能改变。编译器必须能够在编译期对常量声明进行求值：</p>
<pre class="listing"><span class="Keyword">const</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span> <span class="Comment"># 常量x包含字符串&quot;abc&quot;</span></pre><p>可以在 <tt class="docutils literal"><span class="pre">const</span></tt> 关键字之后使用缩进来列出整个常量部分：</p>
<pre class="listing"><span class="Keyword">const</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Comment"># 这也可以有注释</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">2</span>
  <span class="Identifier">z</span> <span class="Operator">=</span> <span class="Identifier">y</span> <span class="Operator">+</span> <span class="DecNumber">5</span> <span class="Comment"># 计算是可能的</span></pre>
<h1><a class="toc-backref" id="let语句" href="#let语句">let语句</a></h1><p><tt class="docutils literal"><span class="pre">let</span></tt> 语句像 <tt class="docutils literal"><span class="pre">var</span></tt> 语句一样但声明的符号是 <em>单赋值</em> 变量：初始化后它们的值将不能改变。</p>
<pre class="listing"><span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span> <span class="Comment"># 引入一个新变量`x`并绑定一个值</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;xyz&quot;</span>     <span class="Comment"># 非法: 给`x`赋值</span></pre><p><tt class="docutils literal"><span class="pre">let</span></tt> 和 <tt class="docutils literal"><span class="pre">const</span></tt> 的区别在于: <tt class="docutils literal"><span class="pre">let</span></tt> 引入一个变量不能重新赋值。 <tt class="docutils literal"><span class="pre">const</span></tt> 表示&quot;强制编译期求值并放入数据段&quot;:</p>
<pre class="listing"><span class="Keyword">const</span> <span class="Identifier">input</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span> <span class="Comment"># 错误: 需要常量表达式</span></pre><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">input</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>   <span class="Comment"># 可以</span></pre>
<h1><a class="toc-backref" id="流程控制语句" href="#流程控制语句">流程控制语句</a></h1><p>greetings程序由三个顺序执行的语句构成。只有最原始的程序可以不需要分支和循环。</p>

<h2><a class="toc-backref" id="流程控制语句-if语句" href="#流程控制语句-if语句">If语句</a></h2><p>if语句是分支流程控制的一种方法:</p>
<pre class="listing"><span class="Keyword">let</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">if</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Poor soul, you lost your name?&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;name&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Very funny, your name is name.&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Hi, &quot;</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="StringLit">&quot;!&quot;</span></pre><p>可以没有或多个 <tt class="docutils literal"><span class="pre">elif</span></tt> ，并且 <tt class="docutils literal"><span class="pre">else</span></tt> 是可选的， <tt class="docutils literal"><span class="pre">elif</span></tt> 关键字是 <tt class="docutils literal"><span class="pre">else if</span></tt> 的简写，并且避免过度缩进。（ <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt> 是空字符串，不包含字符。）</p>

<h2><a class="toc-backref" id="流程控制语句-case语句" href="#流程控制语句-case语句">Case语句</a></h2><p>另一个分支的方法是case语句。case语句是多分支：</p>
<pre class="listing"><span class="Keyword">let</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">case</span> <span class="Identifier">name</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Poor soul, you lost your name?&quot;</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;name&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Very funny, your name is name.&quot;</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;Dave&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Frank&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Cool name!&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Hi, &quot;</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="StringLit">&quot;!&quot;</span></pre><p>可以看出，对于分支允许使用逗号分隔的值列表。</p>
<p>case语句可以处理整型、其它序数类型和字符串。（序数类型后面会讲到） 对整型或序数类型值，也可以用范围：</p>
<pre class="listing"><span class="Comment"># 这段语句将会在后面解释:</span>
<span class="Keyword">from</span> <span class="Identifier">strutils</span> <span class="Keyword">import</span> <span class="Identifier">parseInt</span>

<span class="Identifier">echo</span> <span class="StringLit">&quot;A number please: &quot;</span>
<span class="Keyword">let</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Keyword">case</span> <span class="Identifier">n</span>
<span class="Keyword">of</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="FloatNumber">4.</span><span class="Operator">.</span><span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;The number is in the set: {0, 1, 2, 4, 5, 6, 7}&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;The number is 3 or 8&quot;</span></pre><p>上面的代码不能编译: 原因是你必须覆盖每个 <tt class="docutils literal"><span class="pre">n</span></tt> 可能包含的值，但代码里只处理了 <tt class="docutils literal"><span class="pre">0..8</span></tt> 。 因为列出来每个可能的值不现实（尽管范围可以实现），我们通过告诉编译器不处理其它值来修复：</p>
<pre class="listing"><span class="Operator">...</span>
<span class="Keyword">case</span> <span class="Identifier">n</span>
<span class="Keyword">of</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="FloatNumber">4.</span><span class="Operator">.</span><span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;The number is in the set: {0, 1, 2, 4, 5, 6, 7}&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;The number is 3 or 8&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">discard</span></pre><p>空 <a class="reference external" href="#procedures-discard-statement">discard语句</a> 是一个 <em>什么都不做</em> 的语句。编译器知道带有else部分的case语句不会失败，因此错误消失。 请注意，不可能覆盖所有可能的字符串值：这就是字符串情况总是需要else分支的原因。</p>
<p>通常情况下，case语句用于枚举的子范围类型，其中编译器对检查您是否覆盖了任何可能的值有很大帮助。</p>

<h2><a class="toc-backref" id="流程控制语句-while语句" href="#流程控制语句-while语句">While语句</a></h2><p>while语句是一个简单的循环结构:</p>
<pre class="listing"><span class="Identifier">echo</span> <span class="StringLit">&quot;What's your name? &quot;</span>
<span class="Keyword">var</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">while</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Please tell me your name: &quot;</span>
  <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
  <span class="Comment"># 没有 ``var`` ， 因为我们没有声明一个新变量</span></pre><p>示例使用while循环来不断的询问用户的名字，只要用户什么都没有输入（只按回车）。</p>

<h2><a class="toc-backref" id="流程控制语句-for语句" href="#流程控制语句-for语句">For语句</a></h2><p><tt class="docutils literal"><span class="pre">for</span></tt> 语句是一个循环遍历迭代器提供的任何元素的构造。示例使用内置的 <a class="reference external" href="system.html#countup">countup</a> 迭代器:</p>
<pre class="listing"><span class="Identifier">echo</span> <span class="StringLit">&quot;Counting to ten: &quot;</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">10</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span>
<span class="Comment"># --&gt; Outputs 1 2 3 4 5 6 7 8 9 10 on different lines</span></pre><p>变量 <tt class="docutils literal"><span class="pre">i</span></tt> 通过 <tt class="docutils literal"><span class="pre">for</span></tt> 循环隐式的声明并具有 <tt class="docutils literal"><span class="pre">int</span></tt> 类型, 因为这里 <a class="reference external" href="system.html#countup">countup</a> 返回的。 <tt class="docutils literal"><span class="pre">i</span></tt> 遍历 1, 2, .., 10，每个值被 <tt class="docutils literal"><span class="pre">echo</span></tt> 。 这段代码作用是一样的:</p>
<pre class="listing"><span class="Identifier">echo</span> <span class="StringLit">&quot;Counting to 10: &quot;</span>
<span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
<span class="Keyword">while</span> <span class="Identifier">i</span> <span class="Operator">&lt;=</span> <span class="DecNumber">10</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span> <span class="Comment"># increment i by 1</span>
<span class="Comment"># --&gt; Outputs 1 2 3 4 5 6 7 8 9 10 on different lines</span></pre><p>倒数可以轻松实现 (但不常需要):</p>
<pre class="listing"><span class="Identifier">echo</span> <span class="StringLit">&quot;Counting down from 10 to 1: &quot;</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">countdown</span><span class="Punctuation">(</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span>
<span class="Comment"># --&gt; Outputs 10 9 8 7 6 5 4 3 2 1 on different lines</span></pre><p>计数在程序中经常出现，Nim有一个 <a class="reference external" href="system.html#...i,S,T">..</a> 迭代器作用是一样的</p>
<pre class="listing"><span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">:</span>
  <span class="Operator">...</span></pre><p>零索引计数有两个简写 <tt class="docutils literal"><span class="pre">..&lt;</span></tt> 和 <tt class="docutils literal"><span class="pre">..^</span></tt> ，为了简化计数到较高索引的前一位。</p>
<pre class="listing"><span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.&lt;</span><span class="DecNumber">10</span><span class="Punctuation">:</span>
  <span class="Operator">...</span>  <span class="Comment"># 0..9</span></pre><p>or</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string&quot;</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.&lt;</span><span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">:</span>
  <span class="Operator">...</span></pre><p>其它有用的迭代器（如数组和序列）是</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">items</span></tt> 和 <tt class="docutils literal"><span class="pre">mitems</span></tt> ，提供不可改变和可改变元素，</li>
<li><tt class="docutils literal"><span class="pre">pairs</span></tt> 和 <tt class="docutils literal"><span class="pre">mpairs</span></tt> 提供元素和索引数字。</li>
</ul>
<pre class="listing"><span class="Keyword">for</span> <span class="Identifier">index</span><span class="Punctuation">,</span> <span class="Identifier">item</span> <span class="Keyword">in</span> <span class="Punctuation">[</span><span class="StringLit">&quot;a&quot;</span><span class="Punctuation">,</span><span class="StringLit">&quot;b&quot;</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">pairs</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">item</span><span class="Punctuation">,</span> <span class="StringLit">&quot; at index &quot;</span><span class="Punctuation">,</span> <span class="Identifier">index</span>
<span class="Comment"># =&gt; a at index 0</span>
<span class="Comment"># =&gt; b at index 1</span></pre>
<h2><a class="toc-backref" id="流程控制语句-作用域和块语句" href="#流程控制语句-作用域和块语句">作用域和块语句</a></h2><p>控制流语句有一个还没有讲的特性: 它们有自己的作用域。这意味着在下面的示例中, <tt class="docutils literal"><span class="pre">x</span></tt> 在作用域外是不可访问的:</p>
<pre class="listing"><span class="Keyword">while</span> <span class="Identifier">false</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;hi&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Comment"># 不行</span></pre><p>一个while(for)语句引入一个隐式块。标识符是只在它们声明的块内部可见。 <tt class="docutils literal"><span class="pre">block</span></tt> 语句可以用来显式地打开一个新块：</p>
<pre class="listing"><span class="Keyword">block</span> <span class="Identifier">myblock</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;hi&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Comment"># 不行</span></pre><p>块的 <em>label</em> (本例中的 <tt class="docutils literal"><span class="pre">myblock</span></tt> ) 是可选的。</p>

<h2><a class="toc-backref" id="流程控制语句-break语句" href="#流程控制语句-break语句">Break语句</a></h2><p>块可以用一个 <tt class="docutils literal"><span class="pre">break</span></tt> 语句跳出。break语句可以跳出一个 <tt class="docutils literal"><span class="pre">while</span></tt>, <tt class="docutils literal"><span class="pre">for</span></tt>, 或 <tt class="docutils literal"><span class="pre">block</span></tt> 语句. 它跳出最内层的结构, 除非给定一个块标签:</p>
<pre class="listing"><span class="Keyword">block</span> <span class="Identifier">myblock</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;entering block&quot;</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;looping&quot;</span>
    <span class="Keyword">break</span> <span class="Comment"># 跳出循环,但不跳出块</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;still in block&quot;</span>

<span class="Keyword">block</span> <span class="Identifier">myblock2</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;entering block&quot;</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;looping&quot;</span>
    <span class="Keyword">break</span> <span class="Identifier">myblock2</span> <span class="Comment"># 跳出块 (和循环)</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;still in block&quot;</span></pre>
<h2><a class="toc-backref" id="流程控制语句-continue语句" href="#流程控制语句-continue语句">Continue语句</a></h2><p>像其它编程语言一样， <tt class="docutils literal"><span class="pre">continue</span></tt> 语句立刻开始下一次迭代:</p>
<pre class="listing"><span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
  <span class="Keyword">if</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span> <span class="Keyword">continue</span>
  <span class="Identifier">echo</span> <span class="Identifier">x</span></pre>
<h2><a class="toc-backref" id="流程控制语句-when语句" href="#流程控制语句-when语句">When语句</a></h2><p>示例:</p>
<pre class="listing"><span class="Keyword">when</span> <span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostOS</span> <span class="Operator">==</span> <span class="StringLit">&quot;windows&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;running on Windows!&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostOS</span> <span class="Operator">==</span> <span class="StringLit">&quot;linux&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;running on Linux!&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostOS</span> <span class="Operator">==</span> <span class="StringLit">&quot;macosx&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;running on Mac OS X!&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;unknown operating system&quot;</span></pre><p><tt class="docutils literal"><span class="pre">when</span></tt> 语句几乎等价于 <tt class="docutils literal"><span class="pre">if</span></tt> 语句, 但有以下区别:</p>
<ul class="simple"><li>每个条件必须是常量表达式，因为它被编译器求值。</li>
<li>分支内的语句不打开新作用域。</li>
<li>编译器检查语义并 <em>仅</em> 为属于第一个求值为true的条件生成代码。</li>
</ul>
<p><tt class="docutils literal"><span class="pre">when</span></tt> 语句在写平台特定代码时有用，类似于C语言中的 <tt class="docutils literal"><span class="pre">#ifdef</span></tt> 结构。</p>

<h1><a class="toc-backref" id="语句和缩进" href="#语句和缩进">语句和缩进</a></h1><p>既然我们覆盖了基本的控制流语句, 让我们回到Nim缩进规则。</p>
<p>在Nim中 <em>简单语句</em> 和 <em>复杂语句</em> 有区别。 <em>简单语句</em> 不能包含其它语句：属于简单语句的赋值, 过程调用或 <tt class="docutils literal"><span class="pre">return</span></tt> 语句。 <em>复杂语句</em> 像 <tt class="docutils literal"><span class="pre">if</span></tt> 、 <tt class="docutils literal"><span class="pre">when</span></tt> 、 <tt class="docutils literal"><span class="pre">for</span></tt> 、 <tt class="docutils literal"><span class="pre">while</span></tt> 可以包含其它语句。 为了避免歧义，复杂语句必须缩进, 但单个简单语句不必:</p>
<pre class="listing"><span class="Comment"># 单个赋值语句不需要缩进:</span>
<span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">false</span>

<span class="Comment"># 嵌套if语句需要缩进:</span>
<span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span>
  <span class="Keyword">if</span> <span class="Identifier">y</span><span class="Punctuation">:</span>
    <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">false</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">true</span>

<span class="Comment"># 需要缩进, 因为条件后有两个语句：</span>
<span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">false</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">false</span></pre><p><em>表达式</em> 是语句通常有一个值的部分。 例如，一个if语句中的条件是表达式。表达式为了更好的可读性可以在某些地方缩进：</p>
<pre class="listing"><span class="Keyword">if</span> <span class="Identifier">thisIsaLongCondition</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
    <span class="Identifier">thisIsAnotherLongCondition</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span>
       <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">true</span></pre><p>根据经验，表达式中的缩进允许在操作符、开放的小括号和逗号后。</p>
<p>用小括号和分号 <tt class="docutils literal"><span class="pre">(;)</span></tt> 可以在只允许表达式的地方使用语句：</p>
<pre class="listing"><span class="Comment"># 编译期计算fac(4) :</span>
<span class="Keyword">const</span> <span class="Identifier">fac4</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">1</span><span class="Punctuation">;</span> <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="DecNumber">4</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">*=</span> <span class="Identifier">i</span><span class="Punctuation">;</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre>
<h1><a class="toc-backref" id="过程" href="#过程">过程</a></h1><p>为了在示例中定义如 <a class="reference external" href="system.html#echo">echo</a> 和 <a class="reference external" href="system.html#readLine,File">readLine</a> 的新命令, 需要 <tt class="docutils literal"><span class="pre">procedure</span></tt> 的概念。 (一些语言叫 <em>方法</em> 或 <em>函数</em> 。) 在Nim中新的过程用 <tt class="docutils literal"><span class="pre">proc</span></tt> 关键字定义:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">yes</span><span class="Punctuation">(</span><span class="Identifier">question</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">question</span><span class="Punctuation">,</span> <span class="StringLit">&quot; (y/n)&quot;</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Keyword">case</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="StringLit">&quot;y&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Y&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;yes&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Yes&quot;</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="StringLit">&quot;n&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;N&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;no&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;No&quot;</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">false</span>
    <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;Please be clear: yes or no&quot;</span>

<span class="Keyword">if</span> <span class="Identifier">yes</span><span class="Punctuation">(</span><span class="StringLit">&quot;Should I delete all your important files?&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;I'm sorry Dave, I'm afraid I can't do that.&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;I think you know what the problem is just as well as I do.&quot;</span></pre><p>这个示例展示了一个名叫 <tt class="docutils literal"><span class="pre">yes</span></tt> 的过程，它问用户一个 <tt class="docutils literal"><span class="pre">question</span></tt> 并返回true如果他们回答&quot;yes&quot;（或类似的回答），返回false当他们回答&quot;no&quot;（或类似的回答）。一个 <tt class="docutils literal"><span class="pre">return</span></tt> 语句立即跳出过程。 <tt class="docutils literal"><span class="pre">(question: string): bool</span></tt> 语法描述过程需要一个名为 <tt class="docutils literal"><span class="pre">question</span></tt> ，类型为 <tt class="docutils literal"><span class="pre">string</span></tt> 的变量，并且返回一个 <tt class="docutils literal"><span class="pre">bool</span></tt> 值。 <tt class="docutils literal"><span class="pre">bool</span></tt> 类型是内置的：合法的值只有 <tt class="docutils literal"><span class="pre">true</span></tt> 和 <tt class="docutils literal"><span class="pre">false</span></tt> 。if或while语句中的条件必须是 <tt class="docutils literal"><span class="pre">bool</span></tt> 类型。</p>
<p>一些术语: 示例中 <tt class="docutils literal"><span class="pre">question</span></tt> 叫做一个(形) <em>参</em>, <tt class="docutils literal"><span class="pre">&quot;Should I...&quot;</span></tt> 叫做 <em>实参</em> 传递给这个参数。</p>

<h2><a class="toc-backref" id="过程-result变量" href="#过程-result变量">Result变量</a></h2><p>一个返回值的过程有一个隐式 <tt class="docutils literal"><span class="pre">result</span></tt> 变量声明代表返回值。一个没有表达式的 <tt class="docutils literal"><span class="pre">return</span></tt> 语句是 <tt class="docutils literal"><span class="pre">return result</span></tt> 的简写。 <tt class="docutils literal"><span class="pre">result</span></tt> 总在过程的结尾自动返回如果退出时没有 <tt class="docutils literal"><span class="pre">return</span></tt> 语句.</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">x</span><span class="Punctuation">:</span>
    <span class="Keyword">if</span> <span class="Identifier">i</span> <span class="Operator">&lt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
      <span class="Keyword">return</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">result</span> <span class="Operator">+</span> <span class="Identifier">i</span>

<span class="Identifier">echo</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># echos 0</span>
<span class="Identifier">echo</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">)</span> <span class="Comment"># echos 12</span>
<span class="Identifier">echo</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span> <span class="Punctuation">,</span> <span class="Operator">-</span><span class="DecNumber">1</span> <span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Comment"># echos 7</span></pre><p><tt class="docutils literal"><span class="pre">result</span></tt> 变量已经隐式地声明在函数的开头，那么比如再次用'var result'声明， 将用一个相同名字的普通变量遮蔽它。result变量也已经用返回类型的默认值初始化过。 注意引用数据类型将是 <tt class="docutils literal"><span class="pre">nil</span></tt> 在过程的开头，因此可能需要手动初始化。</p>

<h2><a class="toc-backref" id="过程-形参" href="#过程-形参">形参</a></h2><p>形参在过程体中不可改变。默认地，它们的值不能被改变，这允许编译器以最高效的方式实现参数传递。如果在一个过程内需要可以改变的变量，它必须在过程体中用 <tt class="docutils literal"><span class="pre">var</span></tt> 声明。 遮蔽形参名是可能的，实际上是一个习语：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">printSeq</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">,</span> <span class="Identifier">nprinted</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">nprinted</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">nprinted</span> <span class="Operator">==</span> <span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">min</span><span class="Punctuation">(</span><span class="Identifier">nprinted</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Operator">&lt;</span><span class="Identifier">nprinted</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></pre><p>如果过程需要为调用者修改实参，可以用 <tt class="docutils literal"><span class="pre">var</span></tt> 参数:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span>        <span class="Comment"># 整除</span>
  <span class="Identifier">remainder</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span>  <span class="Comment"># 整数取模操作</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Comment"># 修改x和y</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span>
<span class="Identifier">echo</span> <span class="Identifier">y</span></pre><p>示例中, <tt class="docutils literal"><span class="pre">res</span></tt> 和 <tt class="docutils literal"><span class="pre">remainder</span></tt> 是 <tt class="docutils literal"><span class="pre">var parameters</span></tt> 。Var参数可以被过程修改，改变对调用者可见。注意上面的示例用一个元组作为返回类型而不是var参数会更好。</p>

<h2><a class="toc-backref" id="过程-discard语句" href="#过程-discard语句">Discard语句</a></h2><p>调用仅为其副作用返回值并忽略返回值的过程, <strong>必须</strong> 用 <tt class="docutils literal"><span class="pre">discard</span></tt> 语句。Nim不允许静默地扔掉一个返回值：</p>
<pre class="listing"><span class="Keyword">discard</span> <span class="Identifier">yes</span><span class="Punctuation">(</span><span class="StringLit">&quot;May I ask a pointless question?&quot;</span><span class="Punctuation">)</span></pre><p>返回类型可以被隐式地忽略如果调用的方法、迭代器已经用 <tt class="docutils literal"><span class="pre">discardable</span></tt> pragma声明过。</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">discardable</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">return</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>

<span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># now valid</span></pre><p>在 <a class="reference external" href="#comments">Comments</a> 段中描述 <tt class="docutils literal"><span class="pre">discard</span></tt> 语句也可以用于创建块注释。</p>

<h2><a class="toc-backref" id="过程-命名参数" href="#过程-命名参数">命名参数</a></h2><p>通常一个过程有许多参数而且参数的顺序不清晰。这在构造一个复杂数据类型时尤为突出。因此可以对传递给过程的实参命名，以便于看清哪个实参属于哪个形参：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">width</span><span class="Punctuation">,</span> <span class="Identifier">height</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">title</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">;</span>
                  <span class="Identifier">show</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Window</span> <span class="Operator">=</span>
   <span class="Operator">...</span>

<span class="Keyword">var</span> <span class="Identifier">w</span> <span class="Operator">=</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">show</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">,</span> <span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;My Application&quot;</span><span class="Punctuation">,</span>
                     <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">600</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">800</span><span class="Punctuation">)</span></pre><p>既然我们使用命名实参来调用 <tt class="docutils literal"><span class="pre">createWindow</span></tt> 实参的顺序不再重要。有序实参和命名实参混合起来用也没有问题，但不是很好读：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">w</span> <span class="Operator">=</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;My Application&quot;</span><span class="Punctuation">,</span>
                     <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">600</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">800</span><span class="Punctuation">,</span> <span class="Identifier">true</span><span class="Punctuation">)</span></pre><p>编译器检查每个形参只接收一个实参。</p>

<h2><a class="toc-backref" id="过程-默认值" href="#过程-默认值">默认值</a></h2><p>为了使 <tt class="docutils literal"><span class="pre">createWindow</span></tt> 方法更易于使用，它应当提供 <tt class="docutils literal"><span class="pre">默认值</span></tt> ；这些值在调用者没有指定时用作实参：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">500</span><span class="Punctuation">,</span> <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">700</span><span class="Punctuation">,</span>
                  <span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;unknown&quot;</span><span class="Punctuation">,</span>
                  <span class="Identifier">show</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Window</span> <span class="Operator">=</span>
   <span class="Operator">...</span>

<span class="Keyword">var</span> <span class="Identifier">w</span> <span class="Operator">=</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;My Application&quot;</span><span class="Punctuation">,</span> <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">600</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">800</span><span class="Punctuation">)</span></pre><p>现在调用 <tt class="docutils literal"><span class="pre">createWindow</span></tt> 只需要设置不同于默认值的值。</p>
<p>现在形参可以由默认值进行类型推导；例如，没有必要写 <tt class="docutils literal"><span class="pre">title: string = &quot;unknown&quot;</span></tt> 。</p>

<h2><a class="toc-backref" id="过程-重载过程" href="#过程-重载过程">重载过程</a></h2><p>Nim提供类似C++的过程重载能力：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">toString</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Keyword">proc</span> <span class="Identifier">toString</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;true&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;false&quot;</span>

<span class="Identifier">echo</span> <span class="Identifier">toString</span><span class="Punctuation">(</span><span class="DecNumber">13</span><span class="Punctuation">)</span>   <span class="Comment"># calls the toString(x: int) proc</span>
<span class="Identifier">echo</span> <span class="Identifier">toString</span><span class="Punctuation">(</span><span class="Identifier">true</span><span class="Punctuation">)</span> <span class="Comment"># calls the toString(x: bool) proc</span></pre><p>(注意 <tt class="docutils literal"><span class="pre">toString</span></tt> 通常是Nim中的 <a class="reference external" href="system.html#$">$</a> 。) 编译器为 <tt class="docutils literal"><span class="pre">toString</span></tt> 调用选择最合适的过程。 重载解析算法不在这里讨论（会在手册中具体说明）。 不论如何，它不会导致意外，并且基于一个非常简单的统一算法。有歧义的调用会作为错误报告。</p>

<h2><a class="toc-backref" id="过程-操作符" href="#过程-操作符">操作符</a></h2><p>Nim库重度使用重载，一个原因是每个像 <tt class="docutils literal"><span class="pre">+</span></tt> 的操作符就是一个重载过程。解析器让你在 <tt class="docutils literal"><span class="pre">中缀标记</span></tt> (<tt class="docutils literal"><span class="pre">a + b</span></tt>)或 <tt class="docutils literal"><span class="pre">前缀标记</span></tt> (<tt class="docutils literal"><span class="pre">+ a</span></tt>)中使用操作符。 一个中缀操作符总是有两个实参，一个前缀操作符总是一个。(后缀操作符是不可能的，因为这有歧义： <tt class="docutils literal"><span class="pre">a @ @ b</span></tt> 表示 <tt class="docutils literal"><span class="pre">(a) @ (@b)</span></tt> 还是 <tt class="docutils literal"><span class="pre">(a@) @ (b)</span></tt> ？它总是表示 <tt class="docutils literal"><span class="pre">(a) @ (@b)</span></tt> , 因为Nim中没有后缀操作符。</p>
<p>除了几个内置的关键字操作符如 <tt class="docutils literal"><span class="pre">and</span></tt> 、 <tt class="docutils literal"><span class="pre">or</span></tt> 、 <tt class="docutils literal"><span class="pre">not</span></tt> ，操作符总是由以下符号构成： <tt class="docutils literal"><span class="pre">+ - * \ / &lt; &gt; = @ $ ~ &amp; % ! ? ^ . |</span></tt></p>
<p>允许用户定义的操作符。没有什么阻止你定义自己的 <tt class="docutils literal"><span class="pre">@!?+~</span></tt> 操作符，但这么做降低了可读性。</p>
<p>操作符优先级由第一个字符决定。细节可以在手册中找到。</p>
<p>用反引号&quot;``&quot;括起来定义一个新操作符：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">myDataType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Comment"># 现在$操作符对myDataType生效，重载解析确保$对内置类型像之前一样工作。</span></pre><p>&quot;``&quot;标记也可以来用调用一个像任何其它过程的操作符:</p>
<pre class="listing"><span class="Keyword">if</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span><span class="Punctuation">(</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="DecNumber">7</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;True&quot;</span></pre>
<h2><a class="toc-backref" id="过程-前向声明" href="#过程-前向声明">前向声明</a></h2><p>每个变量、过程等，需要使用前向声明。前向声明不能互相递归：</p>
<pre class="listing"><span class="Comment"># 前向声明:</span>
<span class="Keyword">proc</span> <span class="Identifier">even</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span></pre><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">odd</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">n</span> <span class="Operator">&gt;=</span> <span class="DecNumber">0</span><span class="Punctuation">)</span> <span class="Comment"># 确保我们没有遇到负递归</span>
  <span class="Keyword">if</span> <span class="Identifier">n</span> <span class="Operator">==</span> <span class="DecNumber">0</span><span class="Punctuation">:</span> <span class="Identifier">false</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">n</span> <span class="Operator">==</span> <span class="DecNumber">1</span> <span class="Keyword">or</span> <span class="Identifier">even</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">even</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">n</span> <span class="Operator">&gt;=</span> <span class="DecNumber">0</span><span class="Punctuation">)</span> <span class="Comment"># 确保我们没有遇到负递归</span>
  <span class="Keyword">if</span> <span class="Identifier">n</span> <span class="Operator">==</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">false</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">n</span> <span class="Operator">==</span> <span class="DecNumber">0</span> <span class="Keyword">or</span> <span class="Identifier">odd</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span></pre><p>这里 <tt class="docutils literal"><span class="pre">odd</span></tt> 取决于 <tt class="docutils literal"><span class="pre">even</span></tt> 反之亦然。因此 <tt class="docutils literal"><span class="pre">even</span></tt> 需要在完全定义前引入到编译器。前向声明的语法很简单：直接忽略 <tt class="docutils literal"><span class="pre">=</span></tt> 和过程体。 <tt class="docutils literal"><span class="pre">assert</span></tt> 只添加边界条件，将在 <a class="reference external" href="#模块">模块</a> 段中讲到。</p>
<p>语言的后续版本将弱化前向声明的要求。</p>
<p>示例也展示了一个过程体可以由一个表达式构成，其值之后被隐式返回。</p>

<h1><a class="toc-backref" id="迭代器" href="#迭代器">迭代器</a></h1><p>让我们回到简单的计数示例：</p>
<pre class="listing"><span class="Identifier">echo</span> <span class="StringLit">&quot;Counting to ten: &quot;</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">10</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span></pre><p>一个 <a class="reference external" href="system.html#countup">countup</a> 过程可以支持这个循环吗？让我们试试：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Keyword">while</span> <span class="Identifier">res</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
    <span class="Keyword">return</span> <span class="Identifier">res</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">res</span><span class="Punctuation">)</span></pre><p>这不行,问题在于过程不应当只 <tt class="docutils literal"><span class="pre">return</span></tt> ，但是迭代器后的return和 <strong>continue</strong> 已经完成。这 <em>return and continue</em> 叫做 <tt class="docutils literal"><span class="pre">yield</span></tt> 语句。现在只剩下用 <tt class="docutils literal"><span class="pre">iterator</span></tt> 替换 <tt class="docutils literal"><span class="pre">proc</span></tt> 关键字， 它来了——我们的第一个迭代器：</p>
<pre class="listing"><span class="Keyword">iterator</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Keyword">while</span> <span class="Identifier">res</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Identifier">res</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">res</span><span class="Punctuation">)</span></pre><p>迭代器看起来像过程，但有几点重要的差异：</p>
<ul class="simple"><li>迭代器只能从循环中调用。</li>
<li>迭代器不能包含 <tt class="docutils literal"><span class="pre">return</span></tt> 语句（过程不能包含 <tt class="docutils literal"><span class="pre">yield</span></tt> 语句）。</li>
<li>迭代器没有隐式 <tt class="docutils literal"><span class="pre">result</span></tt> 变量。</li>
<li>迭代器不支持递归。</li>
<li>迭代器不能前向声明，因为编译器必须能够内联迭代器。（这个限制将在编译器的未来版本中消失。）</li>
</ul>
<p>你也可以用 <tt class="docutils literal"><span class="pre">closure</span></tt> 迭代器得到一个不同的限制集合。详见 <a class="reference external" href="manual.html#iterators-and-the-for-statement-first-class-iterators">一等迭代器</a> 。 迭代器可以和过程有同样的名字和形参，因为它们有自己的命名空间。 因此，通常的做法是将迭代器包装在同名的proc中，这些迭代器会累积结果并将其作为序列返回, 像 <a class="reference external" href="strutils.html">strutils模块</a> 中的 <tt class="docutils literal"><span class="pre">split</span></tt> 。</p>

<h1><a class="toc-backref" id="基本类型" href="#基本类型">基本类型</a></h1><p>本章处理基本内置类型和它们的操作细节。</p>

<h2><a class="toc-backref" id="基本类型-布尔值" href="#基本类型-布尔值">布尔值</a></h2><p>Nim的布尔类型叫做 <tt class="docutils literal"><span class="pre">bool</span></tt> ，由两个预先定义好的值 <tt class="docutils literal"><span class="pre">true</span></tt> 和 <tt class="docutils literal"><span class="pre">false</span></tt> 构成。while、if、elif和when语句中的条件必须是布尔类型。</p>
<p>为布尔类型定义操作符 <tt class="docutils literal"><span class="pre">not, and, or, xor, &lt;, &lt;=, &gt;, &gt;=, !=, ==</span></tt> 。 <tt class="docutils literal"><span class="pre">and</span></tt> 和 <tt class="docutils literal"><span class="pre">or</span></tt> 操作符执行短路求值。例如：</p>
<pre class="listing"><span class="Keyword">while</span> <span class="Identifier">p</span> <span class="Operator">!=</span> <span class="Keyword">nil</span> <span class="Keyword">and</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Operator">!=</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">:</span>
  <span class="Comment"># 如果p == nil，p.name不被求值</span>
  <span class="Identifier">p</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">next</span></pre>
<h2><a class="toc-backref" id="基本类型-字符" href="#基本类型-字符">字符</a></h2><p>字符类型叫做 <tt class="docutils literal"><span class="pre">char</span></tt> 。大小总是一字节，所以不能表示大多数UTF-8字符；但可以表示组成多字节UTF-8字符的一个字节。原因是为了效率：对于绝大多数用例，程序依然可以正确处理UTF-8因为UTF-8是专为此设计的。 字符字面值用单引号括起来。</p>
<p>字符可以用 <tt class="docutils literal"><span class="pre">==</span></tt>, <tt class="docutils literal"><span class="pre">&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;=</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;=</span></tt> 操作符比较。 <tt class="docutils literal"><span class="pre">$</span></tt> 操作符将一个 <tt class="docutils literal"><span class="pre">char</span></tt> 转换成一个 <tt class="docutils literal"><span class="pre">string</span></tt> 。字符不能和整型混合；用 <tt class="docutils literal"><span class="pre">ord</span></tt> 过程得到一个 <tt class="docutils literal"><span class="pre">char</span></tt> 的序数值。 从整型到 <tt class="docutils literal"><span class="pre">char</span></tt> 转换使用 <tt class="docutils literal"><span class="pre">chr</span></tt> 过程。</p>

<h2><a class="toc-backref" id="基本类型-字符串" href="#基本类型-字符串">字符串</a></h2><p>字符串变量是 <strong>可以改变的</strong> ， 字符串可以追加，而且非常高效。Nim中的字符串有长度字段，以零结尾。一个字符串长度可以用内置 <tt class="docutils literal"><span class="pre">len</span></tt> 过程获取；长度不计结尾的零。访问结尾零是一个错误，它只为Nim字符串无拷贝转换为 <tt class="docutils literal"><span class="pre">cstring</span></tt> 存在。</p>
<p>字符串赋值会产生拷贝。你可以用 <tt class="docutils literal"><span class="pre">&amp;</span></tt> 操作符拼接字符串和 <tt class="docutils literal"><span class="pre">add</span></tt> 追加到一个字符串。</p>
<p>字符串用字典序比较，支持所有比较操作符。通过转换，所有字符串是UTF-8编码过的，但不是强制。例如，当从进制文件读取字符串时，他们只是一串字节序列。索引操作符 <tt class="docutils literal"><span class="pre">s[i]</span></tt> 表示 <tt class="docutils literal"><span class="pre">s</span></tt> 的第i个 <em>字符</em> , 不是第i个 <em>unichar</em> 。</p>
<p>一个字符串变量用空字符串初始化 <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt> 。</p>

<h2><a class="toc-backref" id="基本类型-整型" href="#基本类型-整型">整型</a></h2><p>Nim有以下内置整型： <tt class="docutils literal"><span class="pre">int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64</span></tt> 。</p>
<p>默认整型是 <tt class="docutils literal"><span class="pre">int</span></tt> 。整型字面值可以用 <em>类型前缀</em> 来指定一个非默认整数类型：</p>
<pre class="listing"><span class="Keyword">let</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span>     <span class="Comment"># x是 ``int``</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">0'i8</span>  <span class="Comment"># y是 ``int8``</span>
  <span class="Identifier">z</span> <span class="Operator">=</span> <span class="DecNumber">0'i64</span> <span class="Comment"># z是 ``int64``</span>
  <span class="Identifier">u</span> <span class="Operator">=</span> <span class="DecNumber">0'</span><span class="Identifier">u</span>   <span class="Comment"># u是 ``uint``</span></pre><p>多数常用整数用来计数内存中的对象，所以 <tt class="docutils literal"><span class="pre">int</span></tt> 和指针具有相同的大小。</p>
<p>整数支持通用操作符 <tt class="docutils literal"><span class="pre">+ - * div mod &lt; &lt;= == != &gt; &gt;=</span></tt> 。 也支持 <tt class="docutils literal"><span class="pre">and or xor not</span></tt> 操作符，并提供 <em>按位</em> 操作。 左移用 <tt class="docutils literal"><span class="pre">shl</span></tt> ，右移用 <tt class="docutils literal"><span class="pre">shr</span></tt> 。位移操作符实参总是被当作 <em>无符号整型</em> 。 普通乘法或除法可以做 <span id="算术位移_1">算术位移</span> 。</p>
<p>无符号操作不会引起上溢和下溢。</p>
<p>无损 <span id="自动类型转换_1">自动类型转换</span> 在表达式中使用不同类型的整数时执行。如果失真，会抛出 <span id="eoutofrange_1">EOutOfRange</span> 异常（如果错误没能在编译时检查出来）。</p>

<h2><a class="toc-backref" id="基本类型-浮点" href="#基本类型-浮点">浮点</a></h2><p>Nim有这些内置浮点类型： <tt class="docutils literal"><span class="pre">float float32 float64</span></tt> 。</p>
<p>默认浮点类型是 <tt class="docutils literal"><span class="pre">float</span></tt> 。在当前的实现， <tt class="docutils literal"><span class="pre">float</span></tt> 是64位。</p>
<p>浮点字面值可以有 <em>类型前缀</em> 来指定非默认浮点类型：</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="FloatNumber">0.0</span>      <span class="Comment"># x是 ``float``</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="FloatNumber">0.0'f32</span>  <span class="Comment"># y是 ``float32``</span>
  <span class="Identifier">z</span> <span class="Operator">=</span> <span class="FloatNumber">0.0'f64</span>  <span class="Comment"># z是 ``float64``</span></pre><p>浮点类型支持通用操作符 <tt class="docutils literal"><span class="pre">+ - * / &lt; &lt;= == != &gt; &gt;=</span></tt> 并遵循IEEE-754标准。</p>
<p>自动类型转换在表达式中使用不同类型时执行：短类型转换为长类型。整数类型 <strong>不</strong> 会自动转换为浮点类型，反之亦然。使用 <a class="reference external" href="system.html#toInt">toInt</a> 和 <a class="reference external" href="system.html#toFloat">toFloat</a> 过程来转换。</p>

<h2><a class="toc-backref" id="基本类型-类型转换" href="#基本类型-类型转换">类型转换</a></h2><p>数字类型转换通过使用类型来执行：</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int32</span> <span class="Operator">=</span> <span class="FloatNumber">1.</span><span class="Identifier">int32</span>   <span class="Comment"># 与调用int32(1)相同</span>
  <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int8</span>  <span class="Operator">=</span> <span class="Identifier">int8</span><span class="Punctuation">(</span><span class="CharLit">'a'</span><span class="Punctuation">)</span> <span class="Comment"># 'a' == 97'i8</span>
  <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span> <span class="FloatNumber">2.5</span>       <span class="Comment"># int(2.5)向下取整为2</span>
  <span class="Identifier">sum</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">z</span><span class="Punctuation">)</span> <span class="Comment"># sum == 100</span></pre>
<h1><a class="toc-backref" id="内部类型表示" href="#内部类型表示">内部类型表示</a></h1><p>之前提到过，内置的 <a class="reference external" href="system.html#$">$</a> （字符串化）操作符将基本类型转换成字符串，这样可以用 <tt class="docutils literal"><span class="pre">echo</span></tt> 过程将内容打印到控制台上。但是高级类型和你自定义的类型，需要定义 <tt class="docutils literal"><span class="pre">$</span></tt> 操作符才能使用。 有时你只想在没有写一个高级类型的 <tt class="docutils literal"><span class="pre">$</span></tt> 操作符时调试当前的值，那么你可以用 <a class="reference external" href="system.html#repr">repr</a> 过程，它可以用于任何类型甚至复杂的有环数据图。下面的示例展示了  <tt class="docutils literal"><span class="pre">$</span></tt> and <tt class="docutils literal"><span class="pre">repr</span></tt> 在即使基本类型输出上也有不同：</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">myBool</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Identifier">myCharacter</span> <span class="Operator">=</span> <span class="CharLit">'n'</span>
  <span class="Identifier">myString</span> <span class="Operator">=</span> <span class="StringLit">&quot;nim&quot;</span>
  <span class="Identifier">myInteger</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
  <span class="Identifier">myFloat</span> <span class="Operator">=</span> <span class="FloatNumber">3.14</span>
<span class="Identifier">echo</span> <span class="Identifier">myBool</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myBool</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; true:true</span>
<span class="Identifier">echo</span> <span class="Identifier">myCharacter</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myCharacter</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; n:'n'</span>
<span class="Identifier">echo</span> <span class="Identifier">myString</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myString</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; nim:0x10fa8c050&quot;nim&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">myInteger</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myInteger</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; 42:42</span>
<span class="Identifier">echo</span> <span class="Identifier">myFloat</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myFloat</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; 3.1400000000000001e+00:3.1400000000000001e+00</span></pre>
<h1><a class="toc-backref" id="高级类型" href="#高级类型">高级类型</a></h1><p>在Nim中新类型可以在 <tt class="docutils literal"><span class="pre">type</span></tt> 语句里定义：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">biggestInt</span> <span class="Operator">=</span> <span class="Identifier">int64</span>      <span class="Comment"># 可用的最大整数类型</span>
  <span class="Identifier">biggestFloat</span> <span class="Operator">=</span> <span class="Identifier">float64</span>  <span class="Comment"># 可用的最大浮点类型</span></pre><p>枚举和对象类型只能定义在 <tt class="docutils literal"><span class="pre">type</span></tt> 语句中。</p>

<h2><a class="toc-backref" id="高级类型-枚举" href="#高级类型-枚举">枚举</a></h2><p>枚举类型的变量只能赋值为枚举指定的值。这些值是有序符号的集合。每个符号映射到内部的一个整数类型。第一个符号用运行时的0表示，第二个用1，以此类推。例如：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Direction</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">north</span><span class="Punctuation">,</span> <span class="Identifier">east</span><span class="Punctuation">,</span> <span class="Identifier">south</span><span class="Punctuation">,</span> <span class="Identifier">west</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">south</span>     <span class="Comment"># `x`是`Direction`; 值是`south`</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span>            <span class="Comment"># 向标准输出写&quot;south&quot;</span></pre><p>所有对比操作符可以用枚举类型。</p>
<p>枚举符号</p>
<p>枚举的符号可以被限定以避免歧义： <tt class="docutils literal"><span class="pre">Direction.south</span></tt> 。</p>
<p><tt class="docutils literal"><span class="pre">$</span></tt> 操作符可以将任何枚举值转换为它的名字， <tt class="docutils literal"><span class="pre">ord</span></tt> 过程可以转换为它底层的整数类型。</p>
<p>为了更好的对接其它编程语言，枚举类型可以赋一个显式的序数值，序数值必须是升序。</p>

<h2><a class="toc-backref" id="高级类型-序数类型" href="#高级类型-序数类型">序数类型</a></h2><p>枚举、整型、 <tt class="docutils literal"><span class="pre">char</span></tt> 、 <tt class="docutils literal"><span class="pre">bool</span></tt> （和子范围）叫做序数类型。序数类型有一些特殊操作：</p>
<table border="1" class="docutils"><tr><th>Operation</th><th>Comment</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">ord(x)</span></tt></td><td>返回表示 <tt class="docutils literal"><span class="pre">x</span></tt> 的整数值</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">inc(x)</span></tt></td><td><tt class="docutils literal"><span class="pre">x</span></tt> 递增1</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">inc(x, n)</span></tt></td><td><tt class="docutils literal"><span class="pre">x</span></tt> 递增 <tt class="docutils literal"><span class="pre">n</span></tt>; <tt class="docutils literal"><span class="pre">n</span></tt> 是整数</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">dec(x)</span></tt></td><td><tt class="docutils literal"><span class="pre">x</span></tt> 递减1</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">dec(x, n)</span></tt></td><td><tt class="docutils literal"><span class="pre">x</span></tt> 递减 <tt class="docutils literal"><span class="pre">n</span></tt>; <tt class="docutils literal"><span class="pre">n</span></tt> 是整数</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">succ(x)</span></tt></td><td>返回 <tt class="docutils literal"><span class="pre">x</span></tt> 的下一个值</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">succ(x, n)</span></tt></td><td>返回 <tt class="docutils literal"><span class="pre">x</span></tt> 后的第n个值</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">pred(x)</span></tt></td><td>返回 <tt class="docutils literal"><span class="pre">x</span></tt> 的前一个值</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">pred(x, n)</span></tt></td><td>返回 <tt class="docutils literal"><span class="pre">x</span></tt> 前的第n个值</td></tr>
</table><p><a class="reference external" href="system.html#inc">inc</a>, <a class="reference external" href="system.html#dec">dec</a>, <a class="reference external" href="system.html#succ">succ</a> 和 <a class="reference external" href="system.html#pred">pred</a> 操作通过抛出 <tt class="docutils literal"><span class="pre">EOutOfRange</span></tt> 或 <tt class="docutils literal"><span class="pre">EOverflow</span></tt> 异常而失败。 （如果代码编译时打开了运行时检查。）</p>

<h2><a class="toc-backref" id="高级类型-子范围" href="#高级类型-子范围">子范围</a></h2><p>一个子范围是一个整型或枚举类型值（基本类型）的范围。例如：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MySubrange</span> <span class="Operator">=</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">]</span></pre><p><tt class="docutils literal"><span class="pre">MySubrange</span></tt> 是只包含0到5的 <tt class="docutils literal"><span class="pre">int</span></tt> 范围。赋任何其它值给 <tt class="docutils literal"><span class="pre">MySubrange</span></tt> 类型的变量是编译期或运行时错误。允许给子范围赋值它的基类型，反之亦然。</p>
<p><tt class="docutils literal"><span class="pre">system</span></tt> 模块定义了重要的 <a class="reference external" href="system.html#Natural">Natural</a> 类型 <tt class="docutils literal"><span class="pre">range[0..high(int)]</span></tt> (<a class="reference external" href="system.html#high">high</a> 返回最大值）。其它编程语言可能建议使用无符号整数。这通常是 <strong>不明智的</strong> : 你不希望因为数字不能是负值而使用无符号算术。Nim的 <tt class="docutils literal"><span class="pre">Natural</span></tt> 类型帮助避免这个编程错误。</p>

<h2><a class="toc-backref" id="高级类型-集合类型" href="#高级类型-集合类型">集合类型</a></h2><p>集合模拟了数学集合的概念。 集合的基类型只能是固定大小的序数类型，它们是:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">int8</span></tt>-<tt class="docutils literal"><span class="pre">int16</span></tt></li>
<li><tt class="docutils literal"><span class="pre">uint8</span></tt>/<tt class="docutils literal"><span class="pre">byte</span></tt>-<tt class="docutils literal"><span class="pre">uint16</span></tt></li>
<li><tt class="docutils literal"><span class="pre">char</span></tt></li>
<li><tt class="docutils literal"><span class="pre">enum</span></tt></li>
</ul>
<p>或等价类型。对有符号整数集合的基类型被定义为在 <tt class="docutils literal"><span class="pre">0 .. MaxSetElements-1</span></tt> 的范围内， 其中 <tt class="docutils literal"><span class="pre">MaxSetElements</span></tt> 目前是2^16。</p>
<p>原因是集合被实现为高性能位向量。尝试声明具有更大类型的集将导致错误：</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">int64</span><span class="Punctuation">]</span> <span class="Comment"># 错误: 集合太大</span></pre><p>集合可以通过集合构造器来构造： <tt class="docutils literal"><span class="pre">{}</span></tt> 是空集合。 空集合与其它具体的集合类型兼容。构造器也可以用来包含元素（和元素范围）：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">CharSet</span> <span class="Operator">=</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">CharSet</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">}</span> <span class="Comment"># 构造一个包含'a'到'z'和'0'到'9'的集合</span></pre><p>集合支持的操作符：</p>
<table border="1" class="docutils"><tr><th>操作符</th><th>含义</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">A + B</span></tt></td><td>并集</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A * B</span></tt></td><td>交集</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A - B</span></tt></td><td>差集</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A == B</span></tt></td><td>相等</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A &lt;= B</span></tt></td><td>子集</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A &lt; B</span></tt></td><td>真子集</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">e in A</span></tt></td><td>元素</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">e notin A</span></tt></td><td>A不包含元素e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">contains(A, e)</span></tt></td><td>包含元素e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">card(A)</span></tt></td><td>A的基 (集合A中的元素数量)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">incl(A, elem)</span></tt></td><td>同 <tt class="docutils literal"><span class="pre">A = A + {elem}</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">excl(A, elem)</span></tt></td><td>同 <tt class="docutils literal"><span class="pre">A = A - {elem}</span></tt></td></tr>
</table>
<h3><a class="toc-backref" id="集合类型-位字段" href="#集合类型-位字段">位字段</a></h3><p>集合经常用来定义过程的 <em>标示</em> 。这比定义必须或在一起的整数常量清晰并且类型安全。</p>
<p>枚举、集合和强转可以一起用：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MyFlag</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">size</span><span class="Punctuation">:</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">cint</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">A</span>
    <span class="Identifier">B</span>
    <span class="Identifier">C</span>
    <span class="Identifier">D</span>
  <span class="Identifier">MyFlags</span> <span class="Operator">=</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">MyFlag</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">MyFlags</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">cint</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
<span class="Keyword">proc</span> <span class="Identifier">toFlags</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">MyFlags</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">MyFlags</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">0</span>
<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Identifier">A</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Identifier">D</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">8</span>
<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">C</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">5</span>
<span class="Identifier">assert</span> <span class="Identifier">toFlags</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Punctuation">{</span><span class="Punctuation">}</span>
<span class="Identifier">assert</span> <span class="Identifier">toFlags</span><span class="Punctuation">(</span><span class="DecNumber">7</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Punctuation">{</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span><span class="Punctuation">,</span> <span class="Identifier">C</span><span class="Punctuation">}</span></pre><p>注意集合如何把枚举变成2的指数。</p>
<p>如果和C一起使用枚举和集合，使用distinct cint。</p>
<p>为了和C互通见 <a class="reference external" href="#implementation-specific-pragmas-bitsize-pragma">bitsize pragma</a> 。</p>

<h2><a class="toc-backref" id="高级类型-数组" href="#高级类型-数组">数组</a></h2><p>数组是固定长度的容器。数组中的元素具有相同的类型。数组索引类型可以是任意序数类型。</p>
<p>数组可以用 <tt class="docutils literal"><span class="pre">[]</span></tt> 来构造：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">IntArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># 一个索引为0..5的数​组</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">IntArray</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">low</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Operator">..</span><span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></pre><p><tt class="docutils literal"><span class="pre">x[i]</span></tt> 标记用来访问 <tt class="docutils literal"><span class="pre">x</span></tt> 的第i个元素。数组访问总是有边界检查的 （编译期或运行时）。这些检查可以通过pragmas或调用编译器的命令行开关 <tt class="docutils literal"><span class="pre">--bound_checks:off</span></tt> 来关闭。</p>
<p>数组是值类型，和任何其它Nim类型一样。赋值操作符拷贝整个数组内容。</p>
<p>内置 <a class="reference external" href="system.html#len,TOpenArray">len</a> 过程返回数组长度。 <a class="reference external" href="system.html#low">low(a)</a> 返回数组a的最小索引， <a class="reference external" href="system.html#high">high(a)</a> 返回最大索引。</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Direction</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">north</span><span class="Punctuation">,</span> <span class="Identifier">east</span><span class="Punctuation">,</span> <span class="Identifier">south</span><span class="Punctuation">,</span> <span class="Identifier">west</span>
  <span class="Identifier">BlinkLights</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">off</span><span class="Punctuation">,</span> <span class="Identifier">on</span><span class="Punctuation">,</span> <span class="Identifier">slowBlink</span><span class="Punctuation">,</span> <span class="Identifier">mediumBlink</span><span class="Punctuation">,</span> <span class="Identifier">fastBlink</span>
  <span class="Identifier">LevelSetting</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Operator">..</span><span class="Identifier">west</span><span class="Punctuation">,</span> <span class="Identifier">BlinkLights</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">level</span><span class="Punctuation">:</span> <span class="Identifier">LevelSetting</span>
<span class="Identifier">level</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">on</span>
<span class="Identifier">level</span><span class="Punctuation">[</span><span class="Identifier">south</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">slowBlink</span>
<span class="Identifier">level</span><span class="Punctuation">[</span><span class="Identifier">east</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">fastBlink</span>
<span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">level</span><span class="Punctuation">)</span>  <span class="Comment"># --&gt; [on, fastBlink, slowBlink, off]</span>
<span class="Identifier">echo</span> <span class="Identifier">low</span><span class="Punctuation">(</span><span class="Identifier">level</span><span class="Punctuation">)</span>   <span class="Comment"># --&gt; north</span>
<span class="Identifier">echo</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">level</span><span class="Punctuation">)</span>   <span class="Comment"># --&gt; 4</span>
<span class="Identifier">echo</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">level</span><span class="Punctuation">)</span>  <span class="Comment"># --&gt; west</span></pre><p>嵌套数组的语法，即其它语言中的多维数组，实际上是追加更多中括号因为通常每个维度限制为和其它一样的索引类型。 在Nim中你可以在不同的维度有不同索引类型，所以嵌套语法稍有不同。 基于上面的例子，其中层数定义为枚举的数组被另一个枚举索引，我们可以添加下面的行来添加一个在层数上进行再分割的灯塔类型：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">LightTower</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">1.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">LevelSetting</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">tower</span><span class="Punctuation">:</span> <span class="Identifier">LightTower</span>
<span class="Identifier">tower</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">slowBlink</span>
<span class="Identifier">tower</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="Identifier">east</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">mediumBlink</span>
<span class="Identifier">echo</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">tower</span><span class="Punctuation">)</span>     <span class="Comment"># --&gt; 10</span>
<span class="Identifier">echo</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">tower</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>  <span class="Comment"># --&gt; 4</span>
<span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">tower</span><span class="Punctuation">)</span>    <span class="Comment"># --&gt; [[slowBlink, mediumBlink, ...more output..</span>
<span class="Comment"># 下面的行不能编译因为类型不匹配</span>
<span class="Comment">#tower[north][east] = on</span>
<span class="Comment">#tower[0][1] = on</span></pre><p>注意内置 <tt class="docutils literal"><span class="pre">len</span></tt> 过程如何只返回数组的第一维长度。另一个定义 <tt class="docutils literal"><span class="pre">LightTower</span></tt> 的方法来更好的说明它的嵌套本质是忽略上面定义的 <tt class="docutils literal"><span class="pre">LevelSetting</span></tt> 类型，取而代之是直接将它以第一维类型嵌入。</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">LightTower</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">1.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Operator">..</span><span class="Identifier">west</span><span class="Punctuation">,</span> <span class="Identifier">BlinkLights</span><span class="Punctuation">]</span><span class="Punctuation">]</span></pre><p>从零开始对数组很普遍，有从零到指定索引减1的范围简写语法：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">IntArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># 一个索引为0..5的数​组</span>
  <span class="Identifier">QuickArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="DecNumber">6</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>  <span class="Comment"># 一个索引为0..5的数​组</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">IntArray</span>
  <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">QuickArray</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span>
<span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">x</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">low</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Operator">..</span><span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></pre>
<h2><a class="toc-backref" id="高级类型-序列" href="#高级类型-序列">序列</a></h2><p>序列类似数组但是动态长度，可以在运行时改变（像字符串）。因为序列是大小可变的它们总是分配在堆上，被垃圾回收。</p>
<p>序列总是以从零开始的 <tt class="docutils literal"><span class="pre">int</span></tt> 类型索引。 <a class="reference external" href="system.html#len,seq[T]">len</a> , <a class="reference external" href="system.html#low">low</a> 和 <a class="reference external" href="system.html#high">high</a> 操作符也可用于序列。 <tt class="docutils literal"><span class="pre">x[i]</span></tt> 标记可以用于访问 <tt class="docutils literal"><span class="pre">x</span></tt> 的第i个元素。</p>
<p>序列可以用数组构造器 <tt class="docutils literal"><span class="pre">[]</span></tt> 数组到序列操作符 <tt class="docutils literal"><span class="pre">@</span></tt> 构成。另一个为序列分配空间的方法是调用内置 <a class="reference external" href="system.html#newSeq">newSeq</a> 过程。</p>
<p>序列可以传递给一个开放数组形参。</p>
<p>Example:</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># 整数序列引用</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Comment"># @ 把数组转成分配在堆上的序列</span></pre><p>序列变量用 <tt class="docutils literal"><span class="pre">@[]</span></tt> 初始化。</p>
<p><tt class="docutils literal"><span class="pre">for</span></tt> 语句可以用一到两个变量当和序列一起使用。当你使用一个变量的形式，变量持有序列提供的值。 <tt class="docutils literal"><span class="pre">for</span></tt> 语句是在 <a class="reference external" href="system.html">system</a> 模块中的 <a class="reference external" href="system.html#items.i,seq[T]">items()</a> 迭代器结果上迭代。 但如果你使用两个变量形式，第一个变量将持有索引位置，第二个变量持有值。这里 <tt class="docutils literal"><span class="pre">for</span></tt> 语句是在 <a class="reference external" href="system.html">system</a> 模块中的 <a class="reference external" href="system.html#pairs.i,seq[T]">pairs()</a> 迭代器结果上迭代。例如：</p>
<pre class="listing"><span class="Keyword">for</span> <span class="Identifier">value</span> <span class="Keyword">in</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">]</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">value</span>
<span class="Comment"># --&gt; 3</span>
<span class="Comment"># --&gt; 4</span>
<span class="Comment"># --&gt; 5</span>

<span class="Keyword">for</span> <span class="Identifier">i</span><span class="Punctuation">,</span> <span class="Identifier">value</span> <span class="Keyword">in</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">]</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;index: &quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="Identifier">i</span><span class="Punctuation">,</span> <span class="StringLit">&quot;, value:&quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="Identifier">value</span>
<span class="Comment"># --&gt; index: 0, value:3</span>
<span class="Comment"># --&gt; index: 1, value:4</span>
<span class="Comment"># --&gt; index: 2, value:5</span></pre>
<h2><a class="toc-backref" id="高级类型-开放数组" href="#高级类型-开放数组">开放数组</a></h2><p><strong>注意</strong>: 开放数组只用于形参。</p>
<p>固定大小的数组经常被证明是不够灵活的；过程应当能够处理不同大小的数组。 <span id="开放数组_1">开放数组</span> 类型允许这样。开放数组总是以0开始的 <tt class="docutils literal"><span class="pre">int</span></tt> 索引。 <a class="reference external" href="system.html#len,TOpenArray">len</a>, <a class="reference external" href="system.html#low">low</a> 和 <a class="reference external" href="system.html#high">high</a> 操作符也可以用于开放数组。任何兼容基类型的数组可以传递给开放数组形参, 与索引类型无关。</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">fruits</span><span class="Punctuation">:</span>   <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span>       <span class="Comment"># 字符串序列用 '@[]' 初始化</span>
  <span class="Identifier">capitals</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="Identifier">string</span><span class="Punctuation">]</span>  <span class="Comment"># 固定大小的字符串数组</span>

<span class="Identifier">capitals</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="StringLit">&quot;New York&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;London&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Berlin&quot;</span><span class="Punctuation">]</span>   <span class="Comment"># 数组 'capitals' 允许只有三个元素的赋值</span>
<span class="Identifier">fruits</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="StringLit">&quot;Banana&quot;</span><span class="Punctuation">)</span>          <span class="Comment"># 序列 'fruits' 在运行时动态扩展</span>
<span class="Identifier">fruits</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="StringLit">&quot;Mango&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">openArraySize</span><span class="Punctuation">(</span><span class="Identifier">oa</span><span class="Punctuation">:</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">oa</span><span class="Operator">.</span><span class="Identifier">len</span>

<span class="Identifier">assert</span> <span class="Identifier">openArraySize</span><span class="Punctuation">(</span><span class="Identifier">fruits</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">2</span>     <span class="Comment"># 过程接受一个序列作为形参</span>
<span class="Identifier">assert</span> <span class="Identifier">openArraySize</span><span class="Punctuation">(</span><span class="Identifier">capitals</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">3</span>   <span class="Comment"># 也可以是一个数组</span></pre><p>开放数组类型无法嵌套：多维开放数组不支持，因为这个需求很少见且不能有效的实现。</p>

<h2><a class="toc-backref" id="高级类型-可变参数" href="#高级类型-可变参数">可变参数</a></h2><p><tt class="docutils literal"><span class="pre">varargs</span></tt> 参数像开放数组形参。 它也表示实现传递数量可变的实参给过程。 编译器将实参列表自动转换为数组：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">)</span>
<span class="Comment"># 编译器转为:</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>转换只在可变形参是过程头部的最后一个形参时完成。它也可以在这个情景执行类型转换：</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="FloatNumber">4.0</span><span class="Punctuation">)</span>
<span class="Comment"># 编译器转为:</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="Operator">$</span><span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="FloatNumber">4.0</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>在示例中 <a class="reference external" href="system.html#$">$</a> 适用于任何传递给形参 <tt class="docutils literal"><span class="pre">a</span></tt> 的实参。注意 <a class="reference external" href="system.html#$">$</a> 适用于空字符串指令。</p>

<h2><a class="toc-backref" id="高级类型-切片" href="#高级类型-切片">切片</a></h2><p>切片语法看起来像子范围但用于不同的场景。切片只是一个包含两个边界 <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> 的切片类型对象。 它自己不是很有用，但是其它收集类型定义接受切片对象来定义范围的操作符。</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">a</span> <span class="Operator">=</span> <span class="StringLit">&quot;Nim is a progamming language&quot;</span>
  <span class="Identifier">b</span> <span class="Operator">=</span> <span class="StringLit">&quot;Slices are useless.&quot;</span>

<span class="Identifier">echo</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="FloatNumber">7.</span><span class="Operator">.</span><span class="DecNumber">12</span><span class="Punctuation">]</span> <span class="Comment"># --&gt; 'a prog'</span>
<span class="Identifier">b</span><span class="Punctuation">[</span><span class="FloatNumber">11.</span><span class="Operator">.^</span><span class="DecNumber">2</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="StringLit">&quot;useful&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">b</span> <span class="Comment"># --&gt; 'Slices are useful.'</span></pre><p>在上面的例子中切片用于修改字符串的一部分。切片边界可以持有任何它们的类型支持的值，但它是使用切片对象的过程，它定义了接受的值。</p>
<p>为了理解指定字符串、数组、序列等索引的不同方法， 必须记住Nim使用基于零的索引。</p>
<p>所以字符串 <tt class="docutils literal"><span class="pre">b</span></tt> 长度是19, 两个不同的指定索引的方法是</p>
<pre class="listing"><span class="StringLit">&quot;Slices are useless.&quot;</span>
 <span class="Operator">|</span>          <span class="Operator">|</span>     <span class="Operator">|</span>
 <span class="DecNumber">0</span>         <span class="DecNumber">11</span>    <span class="DecNumber">17</span>   <span class="Identifier">使用索引</span>
<span class="Operator">^</span><span class="DecNumber">19</span>        <span class="Operator">^</span><span class="DecNumber">8</span>    <span class="Operator">^</span><span class="DecNumber">2</span>   <span class="Identifier">使用</span><span class="Operator">^</span></pre><p>其中 <tt class="docutils literal"><span class="pre">b[0..^1]</span></tt> 等价于 <tt class="docutils literal"><span class="pre">b[0..b.len-1]</span></tt> 和 <tt class="docutils literal"><span class="pre">b[0..&lt;b.len]</span></tt> ，它可以看作 <tt class="docutils literal"><span class="pre">^1</span></tt> 提供一个指定 <tt class="docutils literal"><span class="pre">b.len-1</span></tt> 的简写。</p>
<p>在上面的例子中，因为字符串在句号中结束，来获取字符串中&quot;useless&quot;的部分并替换为&quot;useful&quot;。</p>
<p><tt class="docutils literal"><span class="pre">b[11..^2]</span></tt> 是&quot;useless&quot;的部分， <tt class="docutils literal"><span class="pre">b[11..^2] = &quot;useful&quot;</span></tt> 用&quot;useful&quot;替换&quot;useless&quot;，得到结果&quot;Slices are useful.&quot;</p>
<p>注意: 可选方法是 <tt class="docutils literal"><span class="pre">b[^8..^2] = &quot;useful&quot;</span></tt> 或 <tt class="docutils literal"><span class="pre">b[11..b.len-2] = &quot;useful&quot;</span></tt> 或 as <tt class="docutils literal"><span class="pre">b[11..&lt;b.len-1] = &quot;useful&quot;</span></tt> 。</p>

<h2><a class="toc-backref" id="高级类型-对象" href="#高级类型-对象">对象</a></h2><p>在具有名称的单个结构中将不同值打包在一起的默认类型是对象类型。对象是值类型，意味关当对象赋值给一个新变量时它所有的组成部分也一起拷贝。</p>
<p>每个对象类型 <tt class="docutils literal"><span class="pre">Foo</span></tt> 有一个构造函数 <tt class="docutils literal"><span class="pre">Foo(field: value, ...)</span></tt> 其中它的所有字段可以被初始化。没有指定的字段将获得它们的默认值。</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">var</span> <span class="Identifier">person1</span> <span class="Operator">=</span> <span class="Identifier">Person</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span> <span class="Identifier">person1</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Comment"># &quot;Peter&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">person1</span><span class="Operator">.</span><span class="Identifier">age</span>  <span class="Comment"># 30</span>

<span class="Keyword">var</span> <span class="Identifier">person2</span> <span class="Operator">=</span> <span class="Identifier">person1</span> <span class="Comment"># 复制person 1</span>

<span class="Identifier">person2</span><span class="Operator">.</span><span class="Identifier">age</span> <span class="Operator">+=</span> <span class="DecNumber">14</span>

<span class="Identifier">echo</span> <span class="Identifier">person1</span><span class="Operator">.</span><span class="Identifier">age</span> <span class="Comment"># 30</span>
<span class="Identifier">echo</span> <span class="Identifier">person2</span><span class="Operator">.</span><span class="Identifier">age</span> <span class="Comment"># 44</span>


<span class="Comment"># 顺序可以改变</span>
<span class="Keyword">let</span> <span class="Identifier">person3</span> <span class="Operator">=</span> <span class="Identifier">Person</span><span class="Punctuation">(</span><span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">12</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Quentin&quot;</span><span class="Punctuation">)</span>

<span class="Comment"># 不需要指定每个成员</span>
<span class="Keyword">let</span> <span class="Identifier">person4</span> <span class="Operator">=</span> <span class="Identifier">Person</span><span class="Punctuation">(</span><span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">3</span><span class="Punctuation">)</span>
<span class="Comment"># 未指定的成员将用默认值初始化。本例中它是一个空字符串。</span>
<span class="Identifier">doAssert</span> <span class="Identifier">person4</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span></pre><p>在定义的模块外可见的对象字段需要加上 <tt class="docutils literal"><span class="pre">*</span></tt> 。</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Person</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Comment"># 其它模块可见</span>
    <span class="Identifier">name</span><span class="Operator">*:</span> <span class="Identifier">string</span>  <span class="Comment"># 这个类型的字段在其它模块可见</span>
    <span class="Identifier">age</span><span class="Operator">*:</span> <span class="Identifier">int</span></pre>
<h2><a class="toc-backref" id="高级类型-元组" href="#高级类型-元组">元组</a></h2><p>元组和你目前见到的对象很像。它们是赋值时拷贝每个组成部分的值类型。与对象类型不同的是，元组类型是结构化类型，这意味着不同的元组类型是 <em>等价的</em> 如果它们以相同的顺序指定相同类型和相同名称的字段。</p>
<p>构造函数 <tt class="docutils literal"><span class="pre">()</span></tt> 可以用来构造元组。构造函数中字段的顺序必须与元组定义中的顺序匹配。但与对象不同，此处可能不使用元组类型的名称。</p>
<p>如对象类型， <tt class="docutils literal"><span class="pre">t.field</span></tt> 用来访问一个元组的字段。 另一个对象不可用的标记法是 <tt class="docutils literal"><span class="pre">t[i]</span></tt> 访问第 <tt class="docutils literal"><span class="pre">i</span></tt>' 个字段。这里 <tt class="docutils literal"><span class="pre">i</span></tt> 必须是一个常整数。</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Comment"># 类型表示一个人:</span>
  <span class="Comment"># 一个人有名字和年龄。</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">tuple</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  
  <span class="Comment"># 等价类型的语法。</span>
  <span class="Identifier">PersonX</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  
  <span class="Comment"># 匿名字段语法</span>
  <span class="Identifier">PersonY</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
  <span class="Identifier">personX</span><span class="Punctuation">:</span> <span class="Identifier">PersonX</span>
  <span class="Identifier">personY</span><span class="Punctuation">:</span> <span class="Identifier">PersonY</span>

<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>
<span class="Comment"># Person和PersonX等价</span>
<span class="Identifier">personX</span> <span class="Operator">=</span> <span class="Identifier">person</span>

<span class="Comment"># 用匿名字段创建一个元组：</span>
<span class="Identifier">personY</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>

<span class="Comment"># 有匿名字段元组兼容有字段名元组。</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Identifier">personY</span>
<span class="Identifier">personY</span> <span class="Operator">=</span> <span class="Identifier">person</span>

<span class="Comment"># 通常用于短元组初始化语法</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span> <span class="Identifier">person</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Comment"># &quot;Peter&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">person</span><span class="Operator">.</span><span class="Identifier">age</span>  <span class="Comment"># 30</span>

<span class="Identifier">echo</span> <span class="Identifier">person</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Comment"># &quot;Peter&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">person</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Comment"># 30</span>

<span class="Comment"># 你不需要在一个独立类型段中声明元组。</span>
<span class="Keyword">var</span> <span class="Identifier">building</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">street</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">number</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
<span class="Identifier">building</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Rue del Percebe&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">13</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">building</span><span class="Operator">.</span><span class="Identifier">street</span>

<span class="Comment"># 下面的行不能编译，它们是不同的元组。</span>
<span class="Comment">#person = building</span>
<span class="Comment"># --&gt; Error: type mismatch: got (tuple[street: string, number: int])</span>
<span class="Comment">#     but expected 'Person'</span></pre><p>即使你不需要为元组声明类型就可以使用，不同字段名创建的元组将认为是不同的对象，尽管有相同的字段类型。</p>
<p>元组只有在变量赋值期间可以 <em>解包</em> 。 这方便将元组字段直接一个个赋值给命名变量。一个例子是 <a class="reference external" href="os.html">os module</a> 模块中的 <a class="reference external" href="os.html#splitFile">splitFile</a> 过程， 它同时返回一个路径的目录、名称和扩展名。元组解包必须使用小括号括住你想赋值的解包变量，否则你将为每个变量赋同样的值！例如：</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">os</span>

<span class="Keyword">let</span>
  <span class="Identifier">path</span> <span class="Operator">=</span> <span class="StringLit">&quot;usr/local/nimc.html&quot;</span>
  <span class="Punctuation">(</span><span class="Identifier">dir</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="Identifier">ext</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">splitFile</span><span class="Punctuation">(</span><span class="Identifier">path</span><span class="Punctuation">)</span>
  <span class="Identifier">baddir</span><span class="Punctuation">,</span> <span class="Identifier">badname</span><span class="Punctuation">,</span> <span class="Identifier">badext</span> <span class="Operator">=</span> <span class="Identifier">splitFile</span><span class="Punctuation">(</span><span class="Identifier">path</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">dir</span>      <span class="Comment"># 输出 `usr/local`</span>
<span class="Identifier">echo</span> <span class="Identifier">name</span>     <span class="Comment"># 输出 `nimc`</span>
<span class="Identifier">echo</span> <span class="Identifier">ext</span>      <span class="Comment"># 输出 `.html`</span>
<span class="Comment"># 下面输出同样的行:</span>
<span class="Comment"># `(dir: usr/local, name: nimc, ext: .html)`</span>
<span class="Identifier">echo</span> <span class="Identifier">baddir</span>
<span class="Identifier">echo</span> <span class="Identifier">badname</span>
<span class="Identifier">echo</span> <span class="Identifier">badext</span></pre><p>元组字段总是公有的，你不必像对象类型字段显式的标记来导出。</p>

<h2><a class="toc-backref" id="高级类型-引用和指针类型" href="#高级类型-引用和指针类型">引用和指针类型</a></h2><p>引用（类似其它编程语言中的指针）是引入多对一关系的方式。这表示不同的引用可以指向和修改相同的内存位置。</p>
<p>Nim区分 <span id="被追踪_1">被追踪</span> 和 <span id="未追踪_1">未追踪</span> 引用。未追踪引用也被称为 <em>指针</em> 。追踪的引用指向垃圾回收堆里的对象，未追踪引用指向手动分配对象或内存中其它地方的对象。因此未追踪引用是 <em>不安全的</em> 。 为了某些低级的操作（例如，访问硬件），未追踪的引用是必须的。</p>
<p>追踪的引用用 <strong>ref</strong> 关键字声明；未追踪引用用 <strong>ptr</strong> 关键字声明。</p>
<p>空 <tt class="docutils literal"><span class="pre">[]</span></tt> 下标标记可以用来 <em>解引用</em> 一个引用，表示获取引用指向的内容。 <tt class="docutils literal"><span class="pre">.</span></tt> （访问一个元组/对象字段操作符）和 <tt class="docutils literal"><span class="pre">[]</span></tt> (数组/字符串/序列索引操作符）操作符为引用类型执行隐式解引用操作：</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Keyword">var</span>
  <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="DecNumber">9</span>
<span class="Comment"># 不必写n[].data; 实际上n[].data是不提倡的!</span></pre><p>为了分配一个新追踪的对象，必须使用内置过程 <tt class="docutils literal"><span class="pre">new</span></tt> 。 为了处理未追踪内存， 可以用 <tt class="docutils literal"><span class="pre">alloc</span></tt>, <tt class="docutils literal"><span class="pre">dealloc</span></tt> 和 <tt class="docutils literal"><span class="pre">realloc</span></tt> 。 <a class="reference external" href="system.html">system</a> 模块文档包含更多细节。</p>
<p>如果一个引用指向 <em>nothing</em>, 它的值是 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</p>

<h2><a class="toc-backref" id="高级类型-过程类型" href="#高级类型-过程类型">过程类型</a></h2><p>过程类型是指向过程的指针。 <tt class="docutils literal"><span class="pre">nil</span></tt> 是过程类型变量允许的值。Nim使用过程类型达到 <span id="函数式_1">函数式</span> 编程技术。</p>
<p>Example:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">echoItem</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="Identifier">x</span>

<span class="Keyword">proc</span> <span class="Identifier">forEach</span><span class="Punctuation">(</span><span class="Identifier">action</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">const</span>
    <span class="Identifier">data</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">7</span><span class="Punctuation">,</span> <span class="DecNumber">11</span><span class="Punctuation">]</span>
  <span class="Keyword">for</span> <span class="Identifier">d</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">action</span><span class="Punctuation">(</span><span class="Identifier">d</span><span class="Punctuation">)</span>

<span class="Identifier">forEach</span><span class="Punctuation">(</span><span class="Identifier">echoItem</span><span class="Punctuation">)</span></pre><p>过程类型的一个小问题是调用规约影响类型兼容性：过程类型只兼容如果他们有相同的调用规约。不同的调用规约列在 <a class="reference external" href="manual.html#types-procedural-type">manual</a> 。</p>

<h2><a class="toc-backref" id="高级类型-distinct类型" href="#高级类型-distinct类型">Distinct类型</a></h2><p>一个Distinct类型允许用于创建“非基本类型的子类型”。你必须 <strong>显式</strong> 定义distinct类型的所有行为。 为了帮助这点，distinct类型和它的基类型可以相互强转。 示例提供在 <a class="reference external" href="manual.html#types-distinct-type">manual</a> 。</p>

<h1><a class="toc-backref" id="模块" href="#模块">模块</a></h1><p>Nim支持用模块的概念把一个程序拆分成片段。每个模块在它自己的文件里。模块实现了 <span id="信息隐藏_1">信息隐藏</span> 和 <span id="编译隔离_1">编译隔离</span> 。一个模块可以通过 <span id="import_1">import</span> 语句访问另一个模块符号。 只有标记了星号(<tt class="docutils literal"><span class="pre">*</span></tt>)的顶级符号被导出：</p>
<pre class="listing"><span class="Comment"># Module A</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Comment"># 分配新序列：</span>
  <span class="Identifier">newSeq</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Comment"># 两个序列相乘：</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">*</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>

<span class="Keyword">when</span> <span class="Identifier">isMainModule</span><span class="Punctuation">:</span>
  <span class="Comment"># 测试序列乘 ``*`` :</span>
  <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span> <span class="Operator">*</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">9</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>上面的模块导出 <tt class="docutils literal"><span class="pre">x</span></tt> 和 <tt class="docutils literal"><span class="pre">*</span></tt>, 但没有 <tt class="docutils literal"><span class="pre">y</span></tt> 。</p>
<p>一个模块的顶级语句在程序开始时执行，比如这可以用来初始化复杂数据结构。</p>
<p>每个模块有特殊的魔法常量 <tt class="docutils literal"><span class="pre">isMainModule</span></tt> 在作为主文件编译时为真。 如上面所示，这对模块内的嵌入测试非常有用。</p>
<p>一个模块的符号 <em>可以</em> 用 <tt class="docutils literal"><span class="pre">module.symbol</span></tt> 语法 <em>限定</em> 。如果一个符号有歧义，它 <em>必须</em> 被限定。一个符号有歧义如果定义在两个或多个不同的模块并且被第三个模块导入：</p>
<pre class="listing"><span class="Comment"># Module A</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*:</span> <span class="Identifier">string</span></pre><pre class="listing"><span class="Comment"># Module B</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*:</span> <span class="Identifier">int</span></pre><pre class="listing"><span class="Comment"># Module C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># error: x 有歧义</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># okay: 用了限定</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 没有歧义: 使用模块C的x</span></pre><p>但这个规则不适用于过程或迭代器。重载规则适用于:</p>
<pre class="listing"><span class="Comment"># Module A</span>
<span class="Keyword">proc</span> <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">a</span></pre><pre class="listing"><span class="Comment"># Module B</span>
<span class="Keyword">proc</span> <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">a</span></pre><pre class="listing"><span class="Comment"># Module C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">)</span>   <span class="Comment"># no error: A.x is called</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">(</span><span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span>  <span class="Comment"># no error: B.x is called</span>

<span class="Keyword">proc</span> <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">)</span>   <span class="Comment"># 歧义: 调用哪个 `x` ?</span></pre>
<h2><a class="toc-backref" id="模块-排除符号" href="#模块-排除符号">排除符号</a></h2><p>普通的 <tt class="docutils literal"><span class="pre">import</span></tt> 语句将带来所有导出的符号。这可以用 <tt class="docutils literal"><span class="pre">except</span></tt> 标识符点名限制哪个符号应当被排除。</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">mymodule</span> <span class="Keyword">except</span> <span class="Identifier">y</span></pre>
<h2><a class="toc-backref" id="模块-from语句" href="#模块-from语句">From语句</a></h2><p>我们已经看到简单的 <tt class="docutils literal"><span class="pre">import</span></tt> 语句导入所有导出的符号。一个只导入列出来的符号的可选方法是使用 <tt class="docutils literal"><span class="pre">from import</span></tt> 语句：</p>
<pre class="listing"><span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">import</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span></pre><p><tt class="docutils literal"><span class="pre">from</span></tt> 语句也可以强制限定符号的命名空间，因此可以使符号可用，但需要限定。</p>
<pre class="listing"><span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">import</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span>

<span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>           <span class="Comment"># 没有任何限定使用x</span></pre><pre class="listing"><span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">import</span> <span class="Keyword">nil</span>

<span class="Identifier">mymodule</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>  <span class="Comment"># 必须用模块名前缀限定x</span>

<span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>           <span class="Comment"># 没有限定使用x是编译错误</span></pre><p>因为模块普遍比较长方便描述，你也可以在限定符号时使用短的别名。</p>
<pre class="listing"><span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">as</span> <span class="Identifier">m</span> <span class="Keyword">import</span> <span class="Keyword">nil</span>

<span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>         <span class="Comment"># m是mymodule别名</span></pre>
<h2><a class="toc-backref" id="模块-include语句" href="#模块-include语句">Include语句</a></h2><p><tt class="docutils literal"><span class="pre">include</span></tt> 语句和导入一个模块做不同的基础工作：它只包含一个文件的内容。 <tt class="docutils literal"><span class="pre">include</span></tt> 语句在把一个大模块拆分为几个文件时有用：</p>
<pre class="listing"><span class="Keyword">include</span> <span class="Identifier">fileA</span><span class="Punctuation">,</span> <span class="Identifier">fileB</span><span class="Punctuation">,</span> <span class="Identifier">fileC</span></pre>
<h1><a class="toc-backref" id="part-2" href="#part-2">Part 2</a></h1><p>那么, 既然我们完成了基本的，让我们看看Nim除了为过程编程提供漂亮的语法外还有哪些： <a class="reference external" href="tut2.html">Part II</a></p>
</p>
  
  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small>Made with Nim. Generated: 2020-03-14 05:20:00 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
