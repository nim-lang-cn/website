<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>doc/docs/matching</title>
<link rel="stylesheet" type="text/css" href="nimdoc.out.css">

<script type="text/javascript" src="dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }

  function switchTheme(e) {
      if (e.target.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
      } else {
          document.documentElement.setAttribute('data-theme', 'light');
          localStorage.setItem('theme', 'light');
      }
  }

  const toggleSwitch = document.querySelector('.theme-switch input[type="checkbox"]');
  if (toggleSwitch !== null) {
    toggleSwitch.addEventListener('change', switchTheme, false);
  }

  var currentTheme = localStorage.getItem('theme');
  if (!currentTheme && window.matchMedia('(prefers-color-scheme: dark)').matches) {
    currentTheme = 'dark';
  }
  if (currentTheme) {
    document.documentElement.setAttribute('data-theme', currentTheme);

    if (currentTheme === 'dark' && toggleSwitch !== null) {
      toggleSwitch.checked = true;
    }
  }
}

window.addEventListener('DOMContentLoaded', main);
</script>

</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">doc/docs/matching</h1>
    <blockquote><p>
"you can probably make a macro for that" -- Rika, 22-09-2020 10:41:51
</p></blockquote><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">Author:</th><td>haxscramper</td></tr>
</tbody></table><p>This module implements pattern matching for objects, tuples, sequences, key-value pairs, case and derived objects. DSL can also be used to create object trees (AST).</p>

<h1 id="use-example">Use example</h1><pre class="listing"><span class="Keyword">case</span> <span class="Punctuation">[</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">]</span><span class="Punctuation">:</span>
  <span class="Keyword">of</span> <span class="Punctuation">[</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">_</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">_</span><span class="Punctuation">]</span><span class="Punctuation">:</span> <span class="DecNumber">1</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="DecNumber">999</span></pre>
<h1 id="quick-reference">Quick reference</h1><table border="1" class="docutils"><tr><th>Example</th><th>Explanation</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">(fld: @val)</span></tt></td><td>Field <tt class="docutils literal"><span class="pre">fld</span></tt> into variable <tt class="docutils literal"><span class="pre">@val</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">Kind()</span></tt></td><td>Object with <tt class="docutils literal"><span class="pre">.kind == Kind()</span></tt> <sup><strong><a class="reference internal" href="#footnote-1">[1]</a></strong></sup></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">of Derived()</span></tt></td><td>Match object of derived type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">(@val, _)</span></tt></td><td>First element in tuple in <tt class="docutils literal"><span class="pre">@val</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">(@val, @val)</span></tt></td><td>Tuple with two equal elements</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">{&quot;key&quot; : @val}</span></tt></td><td>Table with &quot;key&quot;, capture into <tt class="docutils literal"><span class="pre">@val</span></tt> <sup><strong><a class="reference internal" href="#footnote-2">[2]</a></strong></sup></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[_, _]</span></tt></td><td>Sequence with <tt class="docutils literal"><span class="pre">len == 2</span></tt> <sup><strong><a class="reference internal" href="#footnote-3">[3]</a></strong></sup></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[_, .._]</span></tt></td><td>At least one element</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[_, all @val]</span></tt></td><td>All elements starting from index <tt class="docutils literal"><span class="pre">1</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[until @val == &quot;2&quot;, .._]</span></tt></td><td>Capture all elements <em>until</em> first <tt class="docutils literal"><span class="pre">&quot;2&quot;</span></tt> <sup><strong><a class="reference internal" href="#footnote-4">[4]</a></strong></sup></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[until @val == 1, @val]</span></tt></td><td>All <em>including</em> first match</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[all @val == 12]</span></tt></td><td>All elements are <tt class="docutils literal"><span class="pre">== 12</span></tt>, capture into <tt class="docutils literal"><span class="pre">@val</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[some @val == 12]</span></tt></td><td>At least <em>one</em> is <tt class="docutils literal"><span class="pre">== 12</span></tt>, capture all matching into <tt class="docutils literal"><span class="pre">@val</span></tt></td></tr>
</table><ul class="simple"><li>[1] Kind fields can use shorted enum names - both <tt class="docutils literal"><span class="pre">nnkStrLit</span></tt> and <tt class="docutils literal"><span class="pre">StrLit</span></tt> will work (prefix <tt class="docutils literal"><span class="pre">nnk</span></tt> can be omitted)</li>
<li>[2] Or any object with <tt class="docutils literal"><span class="pre">contains</span></tt> and <tt class="docutils literal"><span class="pre">[]</span></tt> defined (for necessary types)</li>
<li>[3] Or any object with <tt class="docutils literal"><span class="pre">len</span></tt> proc or field</li>
<li>[4] Note that sequence must mathc <em>fully</em> and it is necessary to have <tt class="docutils literal"><span class="pre">.._</span></tt> at the end in order to accept sequences of arbitrary length.</li>
</ul>

<h1 id="supported-match-elements">Supported match elements</h1><ul class="simple"><li><em>seqs</em> - matched using <tt class="docutils literal"><span class="pre">[Patt1(), Patt2(), ..]</span></tt>. Must have <tt class="docutils literal"><span class="pre">len(): int</span></tt> and <tt class="docutils literal"><span class="pre">[int]: T</span></tt> defined.</li>
<li><em>tuples</em> - matched using <tt class="docutils literal"><span class="pre">(Patt1(), Patt2(), ..)</span></tt>.</li>
<li><em>pairable</em> - matched using <tt class="docutils literal"><span class="pre">{Key: Patt()}</span></tt>. Must have <tt class="docutils literal"><span class="pre">[Key]: T</span></tt> defined. <tt class="docutils literal"><span class="pre">Key</span></tt> is not a pattern - search for whole collection won't be performed.</li>
<li><em>set</em> - matched using <tt class="docutils literal"><span class="pre">{Val1, Val2, .._}</span></tt>. Must have <tt class="docutils literal"><span class="pre">contains</span></tt> defined. If variable is captured then <tt class="docutils literal"><span class="pre">Val1</span></tt> must be comparable and collection should also implement <tt class="docutils literal"><span class="pre">items</span></tt> and <tt class="docutils literal"><span class="pre">incl</span></tt>.</li>
<li><em>object</em> - matched using <tt class="docutils literal"><span class="pre">(field: Val)</span></tt>. Case objects are matched using <tt class="docutils literal"><span class="pre">Kind(field: Val)</span></tt>. If you want to check agains multiple values for kind field <tt class="docutils literal"><span class="pre">(kind: in SomeSetOfKinds)</span></tt></li>
</ul>

<h1 id="element-access">Element access</h1><p>To determine whether or not particular object matches pattern <em>access path</em> is generated - sequence of fields and <tt class="docutils literal"><span class="pre">[]</span></tt> operators that you would normally write by hand, like <tt class="docutils literal"><span class="pre">fld.subfield[&quot;value&quot;].len</span></tt>. Due to support for <a class="reference external" href="https://nim-lang.org/docs/manual.html#procedures-method-call-syntax">method call syntax</a> there is no difference between field acccess and proc call, so things like <tt class="docutils literal"><span class="pre">(len: &lt; 12)</span></tt> also work as expected.</p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">(fld: &quot;3&quot;)</span></tt> Match field <tt class="docutils literal"><span class="pre">fld</span></tt> against <tt class="docutils literal"><span class="pre">&quot;3&quot;</span></tt>. Generated access</dt>
<dd>is <tt class="docutils literal"><span class="pre">expr.fld == &quot;3&quot;</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">[&quot;2&quot;]</span></tt> Match first element of expression agains patt. Generate</dt>
<dd>acess <tt class="docutils literal"><span class="pre">expr[pos] == &quot;2&quot;</span></tt>, where <tt class="docutils literal"><span class="pre">pos</span></tt> is an integer index for current position in sequence.</dd>
</dl>
<p><tt class="docutils literal"><span class="pre">(&quot;2&quot;)</span></tt> For each field generate access using <tt class="docutils literal"><span class="pre">[1]</span></tt></p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">{&quot;key&quot;: &quot;val&quot;}</span></tt> First check <tt class="docutils literal"><span class="pre">&quot;key&quot; in expr</span></tt> and then</dt>
<dd><tt class="docutils literal"><span class="pre">expr[&quot;key&quot;] == &quot;val&quot;</span></tt>. No exception on missing keys, just fail match.</dd>
</dl>
<p>It is possible to have mixed assess for objects. Mixed object access via <tt class="docutils literal"><span class="pre">(gg: _, [], {})</span></tt> creates the same code for checking. E.g <tt class="docutils literal"><span class="pre">([_])</span></tt> is the same as <tt class="docutils literal"><span class="pre">[_]</span></tt>, <tt class="docutils literal"><span class="pre">({&quot;key&quot;: &quot;val&quot;})</span></tt> is is identical to just <tt class="docutils literal"><span class="pre">{&quot;key&quot;: &quot;val&quot;}</span></tt>. You can also call functions and check their values (like <tt class="docutils literal"><span class="pre">(len: _(it &lt; 10))</span></tt> or <tt class="docutils literal"><span class="pre">(len: in {0 .. 10})</span></tt>) to check for sequence length.</p>

<h1 id="checks">Checks</h1><ul class="simple"><li>Any operators with exception of <tt class="docutils literal"><span class="pre">is</span></tt> (subpattern) and <tt class="docutils literal"><span class="pre">of</span></tt> (derived object subpattern) is considered final comparison and just pasted as-is into generated pattern match code. E.g. <tt class="docutils literal"><span class="pre">fld: in {2,3,4}</span></tt> will generate <tt class="docutils literal"><span class="pre">expr.fld in {2,3,4}</span></tt></li>
<li><tt class="docutils literal"><span class="pre">(fld: is Patt())</span></tt> - check if <tt class="docutils literal"><span class="pre">expr.fld</span></tt> matches pattern <tt class="docutils literal"><span class="pre">Patt()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">(fld: _.matchesPredicate())</span></tt> - if call to <tt class="docutils literal"><span class="pre">matchesPredicate(expr.fld)</span></tt> evaluates to true.</li>
</ul>
<p>Notation: <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt> refers to any possible combination of checks. For example</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">fld: in {1,2,3}</span></tt> - <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt> is <tt class="docutils literal"><span class="pre">in {1,2,3}</span></tt></li>
<li><tt class="docutils literal"><span class="pre">[_]</span></tt> - <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt> is <tt class="docutils literal"><span class="pre">_</span></tt></li>
<li><tt class="docutils literal"><span class="pre">fld: is Patt()</span></tt> - <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt> is <tt class="docutils literal"><span class="pre">is Patt()</span></tt></li>
</ul>

<h2 id="examples">Examples</h2><ul class="simple"><li><tt class="docutils literal"><span class="pre">(fld: 12)</span></tt> If rhs for key-value pair is integer, string or identifier then <tt class="docutils literal"><span class="pre">==</span></tt> comparison will be generated.</li>
<li><tt class="docutils literal"><span class="pre">(fld: == ident(&quot;33&quot;))</span></tt> if rhs is a prefix of <tt class="docutils literal"><span class="pre">==</span></tt> then <tt class="docutils literal"><span class="pre">==</span></tt> will be generated. Any for of prefix operator will be converted to <tt class="docutils literal"><span class="pre">expr.fld &lt;op&gt; &lt;rhs&gt;</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">(fld: in {1, 3, 3})</span></tt> or <tt class="docutils literal"><span class="pre">(fld: in Anything)</span></tt> creates <tt class="docutils literal"><span class="pre">fld.expr in Anything</span></tt>. Either <tt class="docutils literal"><span class="pre">in</span></tt> or <tt class="docutils literal"><span class="pre">notin</span></tt> can be used.</li>
</ul>

<h1 id="variable-binding">Variable binding</h1><p>Match can be bound to new varaible. All variable declarations happen via <tt class="docutils literal"><span class="pre">@varname</span></tt> syntax.</p>
<ul class="simple"><li>To bind element to variable without any additional checks do: <tt class="docutils literal"><span class="pre">(fld: @varname)</span></tt></li>
<li>To bind element with some additional operator checks do:<ul class="simple"><li><tt class="docutils literal"><span class="pre">(fld: @varname &lt;operator&gt; Value)</span></tt> first perform check using <tt class="docutils literal"><span class="pre">&lt;operator&gt;</span></tt> and then add <tt class="docutils literal"><span class="pre">Value</span></tt> to <tt class="docutils literal"><span class="pre">@varname</span></tt><ul class="simple"><li><tt class="docutils literal"><span class="pre">(fld: @hello is (&quot;2&quot; | &quot;3&quot;))</span></tt></li>
</ul>
</li>
</ul>
</li>
<li>Predicate checks: <tt class="docutils literal"><span class="pre">fld: @a.matchPredicate()</span></tt></li>
<li>Arbitrary expression: <tt class="docutils literal"><span class="pre">fld: @a(it mod 2 == 0)</span></tt>. If expression has no type it is considered <tt class="docutils literal"><span class="pre">true</span></tt>.</li>
</ul>

<h2 id="bind-order">Bind order</h2><p>Bind order: if check evaluates to true variable is bound immediately, making it possible to use in other checks. <tt class="docutils literal"><span class="pre">[@head, any @tail != head]</span></tt> is a valid pattern. First match <tt class="docutils literal"><span class="pre">head</span></tt> and then any number of <tt class="docutils literal"><span class="pre">@tail</span></tt> elements. Can use <tt class="docutils literal"><span class="pre">any _(if it != head: tail.add it)</span></tt> and declare <tt class="docutils literal"><span class="pre">tail</span></tt> externally.</p>
<p>Variable is never rebound. After it is bound, then it will have the value of first binding.</p>

<h2 id="bind-variable-type">Bind variable type</h2><ul class="simple"><li>Any variadics are mapped to sequence</li>
<li>Only once in alternative is option</li>
<li>Explicitly optional is option</li>
<li>Optional with default value is regular value</li>
<li>Variable can be used only once if in alternative</li>
</ul>
<table border="1" class="docutils"><tr><th>Pattern</th><th>Ijected variables</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">[@a]</span></tt></td><td><tt class="docutils literal"><span class="pre">var a: typeof(expr[0])</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">{&quot;key&quot;: @val}</span></tt></td><td><tt class="docutils literal"><span class="pre">var val: typeof(expr[&quot;key&quot;])</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[all @a]</span></tt></td><td><tt class="docutils literal"><span class="pre">var a: seq[typeof(expr[0])]</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[opt @val]</span></tt></td><td><tt class="docutils literal"><span class="pre">var a: Option[typeof(expr[0])]</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[opt @val or default]</span></tt></td><td><tt class="docutils literal"><span class="pre">var a: typeof(expr[0])</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">(fld: @val)</span></tt></td><td><tt class="docutils literal"><span class="pre">var val: typeof(expr.fld)</span></tt></td></tr>
</table>
<h1 id="matching-different-things">Matching different things</h1>
<h2 id="sequence-matching">Sequence matching</h2><p>Input sequence: <tt class="docutils literal"><span class="pre">[1,2,3,4,5,6,5,6]</span></tt></p>
<table border="1" class="docutils"><tr><th>Pattern</th><th>Result</th><th>Comment</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">[_]</span></tt></td><td><strong>Fail</strong></td><td>Input sequence size mismatch</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[.._]</span></tt></td><td><strong>Ok</strong></td><td></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[@a]</span></tt></td><td><strong>Fail</strong></td><td>Input sequence size mismatch</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[@a, .._]</span></tt></td><td><strong>Ok</strong>, <tt class="docutils literal"><span class="pre">a = 1</span></tt></td><td></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[any @a, .._]</span></tt></td><td><strong>Error</strong></td><td></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[any @a(it &lt; 10)]</span></tt></td><td><strong>Ok</strong>, <tt class="docutils literal"><span class="pre">a = [1..6]</span></tt></td><td>Capture all elements that match</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[until @a == 6, .._]</span></tt></td><td><strong>Ok</strong></td><td>All until first ocurrence of <tt class="docutils literal"><span class="pre">6</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[all @a == 6, .._]</span></tt></td><td><strong>Ok</strong> <tt class="docutils literal"><span class="pre">a = []</span></tt></td><td>All leading <tt class="docutils literal"><span class="pre">6</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[any @a(it &gt; 100)]</span></tt></td><td><strong>Fail</strong></td><td>No elements <tt class="docutils literal"><span class="pre">&gt; 100</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[none @a(it in {6 .. 10})]</span></tt></td><td><strong>Fail</strong></td><td>There is an element <tt class="docutils literal"><span class="pre">== 6</span></tt></td></tr>
</table><dl class="docutils"><dt><tt class="docutils literal"><span class="pre">until</span></tt></dt>
<dd>non-greedy. Match everything until <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt><ul class="simple"><li><tt class="docutils literal"><span class="pre">until &lt;expr&gt;</span></tt>: match all until frist element that matches Expr</li>
</ul>
</dd>
<dt><tt class="docutils literal"><span class="pre">all</span></tt></dt>
<dd>greedy. Match everything that matches <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt><ul class="simple"><li><tt class="docutils literal"><span class="pre">all &lt;expr&gt;</span></tt>: all elements should match Expr</li>
<li><tt class="docutils literal"><span class="pre">all @val is &lt;expr&gt;</span></tt>: capture all elements in <tt class="docutils literal"><span class="pre">@val</span></tt> if <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt> is true for every one of them.</li>
</ul>
</dd>
<dt><tt class="docutils literal"><span class="pre">opt</span></tt></dt>
<dd>Single element match<ul class="simple"><li><tt class="docutils literal"><span class="pre">opt @a</span></tt>: match optional element and bind it to a</li>
<li><tt class="docutils literal"><span class="pre">opt @a or &quot;default&quot;</span></tt>: either match element to a or set a to &quot;default&quot;</li>
</ul>
</dd>
<dt><tt class="docutils literal"><span class="pre">any</span></tt></dt>
<dd>greedy. Consume all sequence elements until the end and succed only if any element has matched.<ul class="simple"><li><tt class="docutils literal"><span class="pre">any @val is &quot;d&quot;</span></tt>: capture all element that match <tt class="docutils literal"><span class="pre">is &quot;d&quot;</span></tt></li>
</ul>
</dd>
<dt><tt class="docutils literal"><span class="pre">none</span></tt></dt>
<dd>greedy. Consume all sequence elements until the end and succed only if any element has matched. EE</dd>
<dt><tt class="docutils literal"><span class="pre">[m .. n @capture]</span></tt></dt>
<dd>Capture slice of elements from index <tt class="docutils literal"><span class="pre">m</span></tt> to <tt class="docutils literal"><span class="pre">n</span></tt></dd>
</dl>
<p>Greedy patterns match until the end of a sequence and cannot be followed by anything else.</p>
<p>For sequence to match is must either be completely matched by all subpatterns or have trailing <tt class="docutils literal"><span class="pre">.._</span></tt> in pattern.</p>
<table border="1" class="docutils"><tr><th>Sequence</th><th>Pattern</th><th>Match result</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">[1,2,3]</span></tt></td><td><tt class="docutils literal"><span class="pre">[1,2]</span></tt> <tt class="docutils literal"><span class="pre">[1, .._]</span></tt> <tt class="docutils literal"><span class="pre">[1,2,_]</span></tt></td><td><strong>Fail</strong> <strong>Ok</strong> <strong>Ok</strong></td></tr>
</table><p>More use examples</p>
<ul class="simple"><li>capture all elements in sequence: <tt class="docutils literal"><span class="pre">[all @elems]</span></tt></li>
<li>get all elements until (not including &quot;d&quot;): <tt class="docutils literal"><span class="pre">[until @a is &quot;d&quot;]</span></tt></li>
<li>All leading &quot;d&quot;: <tt class="docutils literal"><span class="pre">[all @leading is &quot;d&quot;]</span></tt></li>
<li>Match first two elements and ignore the rest <tt class="docutils literal"><span class="pre">[_, _, .._]</span></tt></li>
<li>Match optional third element <tt class="docutils literal"><span class="pre">[_, _, opt @trail]</span></tt></li>
<li>Match third element and if not matched use default value <tt class="docutils literal"><span class="pre">[_, _, opt @trail or &quot;default&quot;]</span></tt></li>
<li>Capture all elements until first separator: <tt class="docutils literal"><span class="pre">[until @leading is &quot;sep&quot;, @middle is &quot;sep&quot;, all @trailing]</span></tt></li>
<li>Extract all conditions from IfStmt: <tt class="docutils literal"><span class="pre">IfStmt([all ElseIf([@cond, _]), .._])</span></tt></li>
</ul>
<p>How different sequence matching keywords map to regular for-loops?</p>
<pre class="listing"><span class="Comment"># all</span>
<span class="Keyword">var</span> <span class="Identifier">allOk</span> <span class="Operator">=</span> <span class="Identifier">false</span>
<span class="Keyword">while</span> <span class="Identifier">position</span> <span class="Operator">&lt;</span> <span class="Identifier">len</span><span class="Punctuation">:</span>
  <span class="Keyword">if</span> <span class="Identifier">matchExpr</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">inc</span> <span class="Identifier">position</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">allOk</span> <span class="Operator">=</span> <span class="Identifier">false</span><span class="Punctuation">;</span> <span class="Keyword">break</span>

<span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">allOk</span><span class="Punctuation">:</span> <span class="Comment"># Fail match</span></pre><pre class="listing"><span class="Comment"># any</span>
<span class="Keyword">var</span> <span class="Identifier">foundOk</span> <span class="Operator">=</span> <span class="Identifier">false</span>
<span class="Keyword">while</span> <span class="Identifier">position</span> <span class="Operator">&lt;</span> <span class="Identifier">len</span><span class="Punctuation">:</span>
  <span class="Keyword">if</span> <span class="Identifier">matchExpr</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">foundOk</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Identifier">inc</span> <span class="Identifier">position</span>

<span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">foundOk</span><span class="Punctuation">:</span> <span class="Comment"># Fail match</span></pre><pre class="listing"><span class="Comment"># until</span>
<span class="Keyword">var</span> <span class="Identifier">foundOk</span> <span class="Operator">=</span> <span class="Identifier">false</span>
<span class="Keyword">while</span> <span class="Identifier">position</span> <span class="Operator">&lt;</span> <span class="Identifier">len</span><span class="Punctuation">:</span>
  <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">matchExpr</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">break</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">inc</span> <span class="Identifier">position</span>

<span class="Comment"># Continue with next matches</span></pre>
<h2 id="tuple-matching">Tuple matching</h2><p>Input tuple: <tt class="docutils literal"><span class="pre">(1, 2, &quot;fa&quot;)</span></tt></p>
<table border="1" class="docutils"><tr><th>Pattern</th><th>Result</th><th>Comment</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">(_, _, _)</span></tt></td><td><strong>Ok</strong></td><td>Match all</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">(@a, @a, _)</span></tt></td><td><strong>Fail</strong></td><td></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">(@a is (1 | 2), @a, _)</span></tt></td><td><strong>Error</strong></td><td></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">(1, 1 | 2, _)</span></tt></td><td><strong>Ok</strong></td><td></td></tr>
</table>
<h2 id="case-object-matching">Case object matching</h2><p>Input AST</p>
<pre class="listing"><span class="Identifier">ForStmt</span>
  <span class="Identifier">Ident</span> <span class="StringLit">&quot;i&quot;</span>
  <span class="Identifier">Infix</span>
    <span class="Identifier">Ident</span> <span class="StringLit">&quot;..&quot;</span>
    <span class="Identifier">IntLit</span> <span class="DecNumber">1</span>
    <span class="Identifier">IntLit</span> <span class="DecNumber">10</span>
  <span class="Identifier">StmtList</span>
    <span class="Identifier">Command</span>
      <span class="Identifier">Ident</span> <span class="StringLit">&quot;echo&quot;</span>
      <span class="Identifier">IntLit</span> <span class="DecNumber">12</span></pre><ul class="simple"><li><tt class="docutils literal"><span class="pre">ForStmt([== ident(&quot;i&quot;), .._])</span></tt> Only for loops with <tt class="docutils literal"><span class="pre">i</span></tt> as variable</li>
<li><tt class="docutils literal"><span class="pre">ForStmt([@a is Ident(), .._])</span></tt> Capture for loop variable</li>
<li><tt class="docutils literal"><span class="pre">ForStmt([@a.isTuple(), .._])</span></tt> for loops in which first subnode satisfies predicate <tt class="docutils literal"><span class="pre">isTuple()</span></tt>. Bind match to <tt class="docutils literal"><span class="pre">a</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ForStmt([_, _, (len: in {1 .. 10})])</span></tt> between one to ten statements in the for loop body</li>
</ul>

<h2 id="ref-object-matching">Ref object matching</h2><p>Matching for ref objects is not really different from regular one - the only difference is that you need to use <tt class="docutils literal"><span class="pre">of</span></tt> operator explicitly. For example, if you want to do <tt class="docutils literal"><span class="pre">case</span></tt> match for different object kinds - and</p>
<pre class="listing"><span class="Keyword">case</span> <span class="Identifier">Obj</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">of</span> <span class="Keyword">of</span> <span class="Identifier">StmtList</span><span class="Punctuation">(</span><span class="Identifier">subfield</span><span class="Punctuation">:</span> <span class="Operator">@</span><span class="Identifier">capture</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Comment"># do something with `capture`</span></pre><p>You can use <tt class="docutils literal"><span class="pre">of</span></tt> as prefix operator - things like <tt class="docutils literal"><span class="pre">{12 : of SubRoot(fld1: @fld1)}</span></tt>, or  <tt class="docutils literal"><span class="pre">[any of Derived()]</span></tt>.</p>

<h2 id="kvminuspairs-matching">KV-pairs matching</h2><p>Input json string</p>
<pre class="listing">{&quot;menu&quot;: {
  &quot;id&quot;: &quot;file&quot;,
  &quot;value&quot;: &quot;File&quot;,
  &quot;popup&quot;: {
    &quot;menuitem&quot;: [
      {&quot;value&quot;: &quot;New&quot;, &quot;onclick&quot;: &quot;CreateNewDoc()&quot;},
      {&quot;value&quot;: &quot;Open&quot;, &quot;onclick&quot;: &quot;OpenDoc()&quot;},
      {&quot;value&quot;: &quot;Close&quot;, &quot;onclick&quot;: &quot;CloseDoc()&quot;}
    ]
  }
}}</pre><ul class="simple"><li>Get input <tt class="docutils literal"><span class="pre">[&quot;menu&quot;][&quot;file&quot;]</span></tt> from node and</li>
</ul>
<pre class="listing"><span class="Keyword">case</span> <span class="Identifier">inj</span><span class="Punctuation">:</span>
  <span class="Keyword">of</span> <span class="Punctuation">{</span><span class="StringLit">&quot;menu&quot;</span> <span class="Punctuation">:</span> <span class="Punctuation">{</span><span class="StringLit">&quot;file&quot;</span><span class="Punctuation">:</span> <span class="Operator">@</span><span class="Identifier">file</span> <span class="Keyword">is</span> <span class="Identifier">JString</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Comment"># ...</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">raiseAssert</span><span class="Punctuation">(</span><span class="StringLit">&quot;Expected [menu][file] as string, but found &quot;</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Identifier">inj</span><span class="Punctuation">)</span></pre>
<h2 id="option-matching">Option matching</h2><p><tt class="docutils literal"><span class="pre">Some(@x)</span></tt> and <tt class="docutils literal"><span class="pre">None()</span></tt> is a special case that will be rewritten into <tt class="docutils literal"><span class="pre">(isSome: true, get: @x)</span></tt> and <tt class="docutils literal"><span class="pre">(isNone: true)</span></tt> respectively. This is made to allow better integration with optional types.  <sup><strong><a class="reference internal" href="#footnote-9">[9]</a></strong></sup> .</p>

<h1 id="tree-construction">Tree construction</h1><p><tt class="docutils literal"><span class="pre">makeTree</span></tt> provides 'reversed' implementation of pattern matching, which allows to <em>construct</em> tree from pattern, using variables. Example of use</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">HtmlNodeKind</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">htmlBase</span> <span class="Operator">=</span> <span class="StringLit">&quot;base&quot;</span>
    <span class="Identifier">htmlHead</span> <span class="Operator">=</span> <span class="StringLit">&quot;head&quot;</span>
    <span class="Identifier">htmlLink</span> <span class="Operator">=</span> <span class="StringLit">&quot;link&quot;</span>
  
  <span class="Identifier">HtmlNode</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">kind</span><span class="Operator">*:</span> <span class="Identifier">HtmlNodeKind</span>
    <span class="Identifier">text</span><span class="Operator">*:</span> <span class="Identifier">string</span>
    <span class="Identifier">subn</span><span class="Operator">*:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">HtmlNode</span><span class="Punctuation">]</span>

<span class="Keyword">func</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">HtmlNode</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">HtmlNode</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">subn</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">s</span>

<span class="Keyword">discard</span> <span class="Identifier">makeTree</span><span class="Punctuation">(</span><span class="Identifier">HtmlNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">base</span><span class="Punctuation">:</span>
    <span class="Identifier">link</span><span class="Punctuation">(</span><span class="Identifier">text</span><span class="Punctuation">:</span> <span class="StringLit">&quot;hello&quot;</span><span class="Punctuation">)</span></pre><p>In order to construct tree, <tt class="docutils literal"><span class="pre">kind=</span></tt> and <tt class="docutils literal"><span class="pre">add</span></tt> have to be defined. Internally DSL just creats resulting object, sets <tt class="docutils literal"><span class="pre">kind=</span></tt> and then repeatedly <tt class="docutils literal"><span class="pre">add</span></tt> elements to it. In order to properties for objects either the field has to be exported, or <tt class="docutils literal"><span class="pre">fld=</span></tt> has to be defined (where <tt class="docutils literal"><span class="pre">fld</span></tt> is the name of property you want to set). </p>



    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small style="color: var(--hint);">Made with Nim. Generated: 2021-10-20 00:31:49 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
