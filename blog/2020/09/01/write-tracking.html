<!doctype html>
<html lang="zh-CN">
  <head>
  <meta name="charset" content="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Nim 语言是一种简洁、快速的编程语言， 可被编译成 C 、 C++ 甚至 JavaScript 。">
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="https://nim-lang-cn.org/assets/img/logo_bw.png" />

  
  <title>Write Tracking for Nim (Part 2) - Nim博客</title>
  
  <link rel="stylesheet" href="https://nim-lang-cn.org/assets/css/pure.min.css">
  <link rel="stylesheet" href="https://nim-lang-cn.org/assets/css/pure-grids-responsive.min.css">
  <!-- <link href="https://use.fontawesome.com/releases/v5.0.2/css/all.css" rel="stylesheet"> -->
  <link href="https://cdn.bootcss.com/font-awesome/5.10.2/css/all.min.css" rel="stylesheet">
  <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"> -->
  
  <link rel="stylesheet" href="https://nim-lang-cn.org/assets/css/highlight/github.css">
  

  <meta name="keyword" content="nim,nim中文,Nim中文社区,nim中文网,nim语言,nim编程语言">

  <!-- <link href="https://fonts.googleapis.com/css?family=Inconsolata|Open+Sans|Titillium+Web" rel="stylesheet"> -->
  <link href="https://fonts.font.im/css?family=Inconsolata|Open+Sans|Titillium+Web" rel="stylesheet">
  <link rel="stylesheet" href="https://nim-lang-cn.org/assets/css/main.css?t=1634689864454356343">

  <!-- <meta name="twitter:title" content="Write Tracking for Nim (Part 2)"> -->

  
  <!-- <meta name="twitter:description" content="7 years ago I wrote how Nim would get “write tracking” as an alternative to adding const to Nim’s type system. This year it finally made it into Nim nightly! Since then the feature was reimplemented and all the details how it works did change."> -->
  <meta property="og:description" content="7 years ago I wrote how Nim would get “write tracking” as an alternative to adding const to Nim’s type system. This year it finally made it into Nim nightly! Since then the feature was reimplemented and all the details how it works did change.">
  

  <!-- <meta name="twitter:site" content="@nim_lang"> -->
  <!-- <meta name="twitter:card" content="summary_large_image"> -->
  <!-- <meta name="twitter:image" content="https://nim-lang.org/assets/img/twitter_banner.png">  -->

  <meta property="og:title" content="Write Tracking for Nim (Part 2)" />
  <meta property="og:site_name" content="Nim中文社区" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="https://nim-lang-cn.org/assets/img/twitter_banner.png" />
  <meta property="og:image:type" content="image/png" />
  <meta property="og:image:width" content="1000" />
  <meta property="og:image:height" content="500" />
  <meta property="og:image:alt" content="Nim中文" />

  <meta name="copyright" content="Nim中文社区">

  <!-- SEO START -->
  <!-- baidu -->
  <meta name="baidu-site-verification" content="D5uE3gaRue" />
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-144592616-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-144592616-1');
  </script>
  <!-- bing -->
  <meta name="msvalidate.01" content="664E5CE055C5DCC50BB1238208911CDF" />
  <!-- yandex -->
  <meta name="yandex-verification" content="24900ce4c46b3893" />
  <!-- SEO END -->

  <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
</head>

  <body class="site">
    <header>
  <nav class="pure-menu pure-menu-horizontal pure-menu-scrollable">
    <div class="nav-content">
      <a href="https://nim-lang-cn.org/" class="pure-menu-heading pure-menu-link site-logo-container">
        <img class="site-logo" src="https://nim-lang-cn.org/assets/img/logo.svg" height="28" alt="Nim">
      </a>
      <ul class="pure-menu-list">
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://tea.nim-lang-cn.org/">早茶</a>
        </li>
        
        <li class="pure-menu-item">
          <a href="https://nim-lang-cn.org/blog.html"
             class="pure-menu-link ">
            博客
          </a>
        </li>
        
        <li class="pure-menu-item">
          <a href="https://nim-lang-cn.org/features.html"
             class="pure-menu-link ">
            特点
          </a>
        </li>
        
        <li class="pure-menu-item">
          <a href="https://nim-lang-cn.org/install.html"
             class="pure-menu-link ">
            下载
          </a>
        </li>
        
        <li class="pure-menu-item">
          <a href="https://nim-lang-cn.org/documentation.html"
             class="pure-menu-link ">
            Documentation
          </a>
        </li>
        
        <li class="pure-menu-item">
          <a href="https://nim-lang-cn.org/community.html"
             class="pure-menu-link ">
            社区
          </a>
        </li>
        
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://github.com/nim-lang/Nim">源码</a>
        </li>
      </ul>
    </div>
    <div class="menu-fade"></div>
  </nav>
</header>

    <div class="site-content post-page">
      <div class="content">
        <div class="width-reduced">
          <h1 class="post-title">
            Write Tracking for Nim (Part 2)
          </h1>
          <h3 class="post-meta">
            <span>
              <i class="far fa-calendar-alt" aria-hidden="true"></i>
              01 September 2020
            </span>
            
            <span>
              <i class="fa fa-user-circle" aria-hidden="true"></i>
              Araq
            </span>
            
          </h3>
          <p>7 years ago I wrote how Nim would get <a href="https://nim-lang.org/araq/writetracking.html">“write
tracking”</a>
as an alternative to adding <code class="language-plaintext highlighter-rouge">const</code> to Nim’s type system.
This year it finally made it into Nim nightly!
Since then the feature was reimplemented and all the details how it works did change.</p>

<p>My special thanks go to <a href="https://github.com/Clyybber">Clyybber</a> who
simplified my initial proposal (see
<a href="https://github.com/nim-lang/RFCs/issues/234">https://github.com/nim-lang/RFCs/issues/234</a>) so that this feature
could be added to Nim without any new pragma at all! Quite an
achievement.</p>

<h2 id="status-quo">Status quo</h2>

<p>Nim already has a strong notion of immutability, every parameter that
does not use the <code class="language-plaintext highlighter-rouge">var T</code> type modifier is immutable.
In fact, Nim’s parameter passing semantics continue to be one of my
favorite features of the language and are a hidden gem.
Nim gets the defaults exactly right.
However, as usual, pointers complicate matters.
This code compiles without any warning:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span>
  <span class="n">Node</span> <span class="o">=</span> <span class="k">ref</span> <span class="k">object</span>
    <span class="n">data</span><span class="p">:</span> <span class="kt">string</span>
    <span class="n">next</span><span class="p">:</span> <span class="n">Node</span>

<span class="k">func</span> <span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span> <span class="kt">int</span> <span class="o">=</span>
  <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">var</span> <span class="n">it</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">while</span> <span class="n">it</span> <span class="o">!=</span> <span class="k">nil</span><span class="p">:</span>
    <span class="n">inc</span> <span class="n">result</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">it</span><span class="p">.</span><span class="n">next</span>
  <span class="c"># nasty code here:</span>
  <span class="n">n</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="s">"mutated!"</span>
</code></pre></div></div>

<p>The reason is that while <code class="language-plaintext highlighter-rouge">n</code> itself is a parameter and immutable, <code class="language-plaintext highlighter-rouge">n.data</code>
remains mutable due to the pointer indirection! This is sometimes called
“shallow immutability”.</p>

<p>As a reminder, the <code class="language-plaintext highlighter-rouge">func x(args)</code> notation is a shortcut for
<code class="language-plaintext highlighter-rouge">proc x(args) {.noSideEffect.}</code>.</p>

<h2 id="flawed-idea-const-t">Flawed idea: const T</h2>

<p>The problem of adding <code class="language-plaintext highlighter-rouge">const</code> to a type system is that it’s inconvenient.
To see why, let us imagine that a <code class="language-plaintext highlighter-rouge">const</code> type modifier would be added to Nim.
<code class="language-plaintext highlighter-rouge">proc p(param: const T)</code> then would mean that no location reachable from
<code class="language-plaintext highlighter-rouge">param</code> is allowed to be mutated by <code class="language-plaintext highlighter-rouge">p</code>.
This is sometimes called “deep immutability”.</p>

<p>So far, so good:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">p</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="k">const</span> <span class="n">Node</span><span class="p">)</span> <span class="o">=</span>
  <span class="c"># does not compile:</span>
  <span class="n">n</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="s">"mutated!"</span>
</code></pre></div></div>

<p>But our <code class="language-plaintext highlighter-rouge">count</code> example has a problem:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span>
  <span class="n">Node</span> <span class="o">=</span> <span class="k">ref</span> <span class="k">object</span>
    <span class="n">data</span><span class="p">:</span> <span class="kt">string</span>
    <span class="n">next</span><span class="p">:</span> <span class="n">Node</span> <span class="c"># note: this is not 'const Node' as some operations</span>
               <span class="c"># on singly linked lists really can mutate this field.</span>

<span class="k">func</span> <span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="k">const</span> <span class="n">Node</span><span class="p">):</span> <span class="kt">int</span> <span class="o">=</span>
  <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">var</span> <span class="n">it</span><span class="p">:</span> <span class="k">const</span> <span class="n">Node</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">while</span> <span class="n">it</span> <span class="o">!=</span> <span class="k">nil</span><span class="p">:</span>
    <span class="n">inc</span> <span class="n">result</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">it</span><span class="p">.</span><span class="n">next</span>
    <span class="c">#  ^ this would require an implicit conversion from 'Node' to 'const Node'!</span>
</code></pre></div></div>

<p>The type of the <code class="language-plaintext highlighter-rouge">next</code> field is <code class="language-plaintext highlighter-rouge">Node</code> and not <code class="language-plaintext highlighter-rouge">const Node</code> and so the naive
iteration over a singly linked list does not work.
Now you can argue that the iteration mechanism should be hidden inside an
iterator anyway where we can also hide the dangerous looking but benign type conversion.</p>

<p>Unfortunately there are many more examples where these type conversions would come up.
In fact, for many simple operations like <code class="language-plaintext highlighter-rouge">id</code> or <code class="language-plaintext highlighter-rouge">select</code> what to use as the
return type is problematic:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">select</span><span class="p">(</span><span class="n">cond</span><span class="p">:</span> <span class="kt">bool</span><span class="p">;</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="k">const</span> <span class="n">Node</span><span class="p">):</span> <span class="n">Node</span> <span class="o">=</span>
  <span class="n">result</span> <span class="o">=</span> <span class="k">if</span> <span class="n">cond</span><span class="p">:</span> <span class="n">a</span> <span class="k">else</span><span class="p">:</span> <span class="n">b</span>
  <span class="c"># type mismatch: cannot convert from 'const Node' to 'Node'</span>

<span class="k">proc </span><span class="nf">mutate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="kp">false</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">x</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="s">"mutated!"</span>
</code></pre></div></div>

<p>Since this doesn’t compile, let’s try a different variant:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">select</span><span class="p">(</span><span class="n">cond</span><span class="p">:</span> <span class="kt">bool</span><span class="p">;</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="k">const</span> <span class="n">Node</span><span class="p">):</span> <span class="k">const</span> <span class="n">Node</span> <span class="o">=</span>
  <span class="n">result</span> <span class="o">=</span> <span class="k">if</span> <span class="n">cond</span><span class="p">:</span> <span class="n">a</span> <span class="k">else</span><span class="p">:</span> <span class="n">b</span>

<span class="k">proc </span><span class="nf">mutate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="kp">false</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
  <span class="c">#        ^  convert back to a mutable node</span>
  <span class="n">x</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="s">"mutated!"</span>
</code></pre></div></div>

<p>The problem with this solution is that it shouldn’t be <code class="language-plaintext highlighter-rouge">select</code>’s business to
decide for me that the selected node cannot be mutated afterwards, that’s the
caller’s choice to make.
These problems are not unique to Nim, for instance in C++ you cannot pass a
<code class="language-plaintext highlighter-rouge">vector&lt;string&gt;</code> to a <code class="language-plaintext highlighter-rouge">vector&lt;const string&gt;</code>.</p>

<h2 id="idea-mutation-is-an-effect">Idea: Mutation is an effect</h2>

<p>There is a better way to model deep immutability.
What we really want to say is that <code class="language-plaintext highlighter-rouge">select</code> does not mutate any node passed
to it, the dangerous pattern to watch out for is something like
<code class="language-plaintext highlighter-rouge">x.field = value</code> or <code class="language-plaintext highlighter-rouge">x[] = value</code>, stores to the heap.
(Here “heap” means the heap according to formal semantics, I’m not talking about
the heap-vs-stack memory region that a typical language implementation uses.)</p>

<p>If we attach an effect like <code class="language-plaintext highlighter-rouge">storeEffect</code> to patterns like <code class="language-plaintext highlighter-rouge">param.field = value</code>
we can effectively communicate the dangerous operations via Nim’s existing
effect system.
Now Clyybber’s brilliant insight was that this effect can be incorporated into
the existing <code class="language-plaintext highlighter-rouge">noSideEffect</code> effect!
No new effect is required, we simply tweak the language definition!</p>

<p><code class="language-plaintext highlighter-rouge">noSideEffect</code> in Nim means “does not access a global or thread-local variable
nor does it call a routine that does”.
We add another criterion to what it means to have a “side effect”:</p>

<p>Mutating an object reachable from a parameter does count as a side effect.</p>

<p>There is a new experimental mode written as <code class="language-plaintext highlighter-rouge">{.experimental: "strictFuncs".}</code>
to enable this stricter interpretation of what a “side effect” means.</p>

<p>Here is how it looks in practice:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{.</span><span class="n">experimental</span><span class="p">:</span> <span class="s">"strictFuncs"</span><span class="p">.}</span>

<span class="k">type</span>
  <span class="n">Node</span> <span class="o">=</span> <span class="k">ref</span> <span class="k">object</span>
    <span class="n">data</span><span class="p">:</span> <span class="kt">string</span>
    <span class="n">next</span><span class="p">:</span> <span class="n">Node</span>

<span class="k">func</span> <span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span> <span class="kt">int</span> <span class="o">=</span>
  <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">var</span> <span class="n">it</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">while</span> <span class="n">it</span> <span class="o">!=</span> <span class="k">nil</span><span class="p">:</span>
    <span class="n">inc</span> <span class="n">result</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">it</span><span class="p">.</span><span class="n">next</span>
  <span class="c"># does not compile anymore!</span>
  <span class="n">n</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="s">"mutated!"</span>
  <span class="c">#  Error: 'count' can have side effects</span>
  <span class="c"># an object reachable from 'n' is potentially mutated</span>
</code></pre></div></div>

<p>As usual, the devil is in the details.
Any algorithm that we use should be smart enough to detect hidden mutations 
via local aliases:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{.</span><span class="n">experimental</span><span class="p">:</span> <span class="s">"strictFuncs"</span><span class="p">.}</span>

<span class="k">type</span>
  <span class="n">Node</span> <span class="o">=</span> <span class="k">ref</span> <span class="k">object</span>
    <span class="n">data</span><span class="p">:</span> <span class="kt">string</span>
    <span class="n">next</span><span class="p">:</span> <span class="n">Node</span>

<span class="k">func</span> <span class="n">p</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
  <span class="n">y</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="s">"mutated!"</span>
</code></pre></div></div>

<p>And indeed the compiler is smart:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">p</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">=</span>
  <span class="c"># Error: 'p' can have side effects</span>
  <span class="c"># an object reachable from 'n' is potentially mutated</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="c"># is the statement that connected the mutation to the parameter</span>
  <span class="n">y</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="s">"mutated!"</span> <span class="c">#  the mutation is here</span>
</code></pre></div></div>

<p>It is not fooled by function calls either:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">id</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span> <span class="n">Node</span> <span class="o">=</span> <span class="n">n</span>

<span class="k">func</span> <span class="n">p</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">id</span> <span class="n">n</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">id</span> <span class="n">x</span>
  <span class="n">y</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="s">"mutated!"</span>
</code></pre></div></div>

<p>Internally the compiler constructs an abstract graph and looks for
subgraphs that are both mutated and “connected” to an input parameter.
The analysis does not depend on the control flow, two locations
<code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are connected if there is a pattern like <code class="language-plaintext highlighter-rouge">a = f(b)</code> in the source code.</p>

<h2 id="mutability-via-var">Mutability via var</h2>

<p>Some mutations remain to be allowed and do not count as a “side” effect:</p>

<div class="language-nim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">add</span><span class="o">*[</span><span class="n">T</span><span class="o">]</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="k">var</span> <span class="kt">seq</span><span class="o">[</span><span class="n">T</span><span class="o">]</span><span class="p">;</span> <span class="n">x</span><span class="p">:</span> <span class="n">sink</span> <span class="n">T</span><span class="p">)</span> <span class="o">=</span>
  <span class="c"># valid: mutates 's'.</span>
  <span class="k">let</span> <span class="n">oldLen</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span>
  <span class="n">setLen</span> <span class="n">s</span><span class="p">,</span> <span class="n">oldLen</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="n">s</span><span class="o">[</span><span class="n">oldLen</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span>
</code></pre></div></div>

<p>The idea here is that no matter what <code class="language-plaintext highlighter-rouge">T</code> is instantiated with, <code class="language-plaintext highlighter-rouge">x</code> should be
deeply immutable, but the seq <code class="language-plaintext highlighter-rouge">s</code> is mutated.
Mutations to <code class="language-plaintext highlighter-rouge">var T</code> parameters remain valid.</p>

<h2 id="summary">Summary</h2>

<p>“strict” funcs are an answer to a long standing design question, fit
Nim’s existing design in a most natural way (“hey, this is the
definition of side effect that I always had in mind!”) and can enable
Nim’s optimizer to be more effective.</p>

<p>If you use Nim devel (1.3.x) this feature is already available to you
and can be accessed via <code class="language-plaintext highlighter-rouge">{.experimental: "strictFuncs".}</code>
in your source code or via <code class="language-plaintext highlighter-rouge">--experimental:strictFuncs</code> on the command line.
Please try it out and give us your feedback!</p>

        </div>
      </div>
    </div>
    <footer>
  <section class="content">
    <div class="pure-g">
      <div class="copyright pure-u-2-3">
        <p>
          除非另有说明，本页内容遵从
          <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0</a>
          许可。
          网站显示的代码遵从MIT许可。
        </p>
        <p>
          本网站在
          <a href="https://github.com/nim-lang-cn/website">GitHub</a>
          上可用并且欢迎提供贡献。
          官方网站由
          <a href="https://github.com/dom96">Dominik Picheta</a>和
          <a href="https://github.com/Calinou">Hugo Locurcio</a>设计。
          Logo由<a href="https://github.com/josephwecker">Joseph Wecker</a>设计。
        </p>
        <p>
          中文翻译由Nim中文社区提供。
          服务器和域名由<a href="https://blog.doylee.cn/">ch4o5</a>提供。
          <a href="https://github.com/gogolxdong">sheldon</a>提供了文档翻译和其他翻译支持。
        </p>
      </div>
      <div class="pure-u-1-3 right-center">
        <script data-cfbadgetype="a" data-cfbadgeskin="dkgray" type="text/javascript">
          //<![CDATA[
          try { window.CloudFlare || function () { var a = window.document, b = a.createElement("script"), a = a.getElementsByTagName("script")[0]; window.CloudFlare = []; b.type = "text/javascript"; b.async = !0; b.src = "//ajax.cloudflare.com/cdn-cgi/nexp/cloudflare.js"; a.parentNode.insertBefore(b, a) }(), CloudFlare.push(function (a) { a(["cloudflare/badge"]) }) } catch (e$$5) { try { console.error("CloudFlare badge code could not be loaded. " + e$$5.message) } catch (e$$6) { } };
          //]]>
        </script>
      </div>
    </div>
  </section>

</footer>
<script>
  (function () {
    function setTracking(a) {
      var url = a.href;
      a.onclick = function () {
        if (typeof (ga) !== "undefined") {
          ga('send', 'event', 'outbound', 'click', url, {
            'transport': 'beacon',
            'hitCallback': function () { document.location = url; }
          });
        }
      };
    }

    var a = document.getElementsByTagName("a");
    for (var i = 0; i < a.length; ++i) {
      if (a[i].hostname != location.hostname &&
        a[i].getAttribute("target") !== "_blank"
      ) {
        setTracking(a[i])
      }
    }
  })();
</script>
<script>
  $(function () {
    $("section a").attr("target", "_blank");
  });
</script>
<script>
  // 百度统计
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?c81f717a4630758267f3b86f9efa48f0";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  
  </body>
</html>
